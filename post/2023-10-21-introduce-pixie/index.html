<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="使用 Pixie 实现 Kubernetes 服务可观测性（4）"><meta property="og:title" content="使用 Pixie 实现 Kubernetes 服务可观测性（4）"><meta property="twitter:title" content="使用 Pixie 实现 Kubernetes 服务可观测性（4）"><meta name=description content="Pixie 是一个用于 Kubernetes 应用程序的开源可观察性平台。Pixie 使用 eBPF 自动捕获遥测数据，可以使用 Pixie 查看集群的状态（服务映射、集群资源、应用程序流量），还可以深入查看更详细的视图（pod 状态、火焰图、应用程序单个请求生命周期）。Pixie 由 New Relic 公司于 2021 年 6 月捐赠给 [CNCF](https://www.cncf.io/) 作为孵化项目。"><meta property="og:description" content="Pixie 是一个用于 Kubernetes 应用程序的开源可观察性平台。Pixie 使用 eBPF 自动捕获遥测数据，可以使用 Pixie 查看集群的状态（服务映射、集群资源、应用程序流量），还可以深入查看更详细的视图（pod 状态、火焰图、应用程序单个请求生命周期）。Pixie 由 New Relic 公司于 2021 年 6 月捐赠给 [CNCF](https://www.cncf.io/) 作为孵化项目。"><meta property="twitter:description" content="Pixie 是一个用于 Kubernetes 应用程序的开源可观察性平台。Pixie 使用 eBPF 自动捕获遥测数据，可以使用 Pixie 查看集群的状态（服务映射、集群资源、应用程序流量），还可以深入查看更详细的视图（pod 状态、火焰图、应用程序单个请求生命周期）。Pixie 由 New Relic 公司于 2021 年 6 月捐赠给 [CNCF](https://www.cncf.io/) 作为孵化项目。"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>使用 Pixie 实现 Kubernetes 服务可观测性（4） | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2023-10-21-introduce-pixie/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a>
<a class=tag href=/tags/pixie title=pixie>pixie</a>
<a class=tag href=/tags/ebpf title=eBPF>eBPF</a></div><h1>使用 Pixie 实现 Kubernetes 服务可观测性（4）</h1><h2 class=subheading>Pixie 是一个开源的观测和调试平台，旨在实时捕获、查询和可视化云原生应用程序的数据。它提供了一种轻量级的方式来收集和分析 Kubernetes 集群中的数据，以便进行实时观察、调试和监控。</h2><span class=meta>Posted by
陈谭军
on
Saturday, October 21, 2023
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2023-10-21-introduce-pixie/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 3339 字</span>，阅读约 <span class=more-meta>7 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=bpftrace>bpftrace</h1><p>bpftrace 是 Linux eBPF 的高级跟踪语言。
它的语言受到 awk 和 C 以及其他跟踪器（例如 DTrace 和 SystemTap）的启发。bpftrace 开发语言是 shell，支持 x86_64、arm64和s390x 架构，要求 linux>=4.x（视功能而定）以上，依赖 BCC 和 LLVM 等基础环境。bpftrace 是一个基于 BPF (Berkley Packet Filter) 技术的高级、安全的跟踪工具。它提供了一种简单而强大的方式来观察和分析系统的运行时行为，特别是对于 Linux 系统的内核和用户空间的活动进行监视和跟踪。</p><p>这个工具有几个关键的特点和功能：</p><ul><li>简单易用： bpftrace 使用一种类似于 AWK 的语法，让用户能够快速编写简洁的脚本来跟踪系统活动。</li><li>灵活性： 它支持在不需要重新编译内核的情况下，动态地加载和执行 BPF 程序，从而可以实时地监视系统的各种活动。</li><li>强大的观察能力： bpftrace 可以监视和跟踪诸如函数调用、系统调用、硬件事件等系统级别的行为。它可以用于分析性能瓶颈、调试问题以及收集各种指标。</li><li>安全性： BPF 技术的设计使得 bpftrace 是一个安全的工具，因为它可以执行内核级别的跟踪和监视，同时确保对系统的影响最小化。</li><li>社区支持和持续更新： bpftrace 是一个活跃的开源项目，有一个积极的社区不断更新和改进这个工具，增加新的功能和改善性能</li></ul><h1 id=介绍>介绍</h1><p>Pixie 是一个用于 Kubernetes 应用程序的开源可观察性平台。Pixie 使用 eBPF 自动捕获遥测数据，可以使用 Pixie 查看集群的状态（服务映射、集群资源、应用程序流量），还可以深入查看更详细的视图（pod 状态、火焰图、应用程序单个请求生命周期）。Pixie 由 <a href=https://newrelic.com/>New Relic</a> 公司于 2021 年 6 月捐赠给 <a href=https://www.cncf.io/>CNCF</a> 作为孵化项目。</p><h1 id=架构>架构</h1><p><img src=/images/2023-10-21-introduce-pixie/1.png alt></p><p>pixie 提供以下主要功能：</p><ul><li>自动遥测：Pixie 使用 eBPF 自动收集遥测数据，如整个请求、资源和网络指标、应用程序配置文件等。</li><li>集群边缘计算：Pixie 在集群中本地收集、存储和查询所有遥测数据，Pixie 使用的集群 CPU 不到 5%，在大多数情况下不到 2%。</li><li>可脚本化：PxL 是 Pixie 灵活的 Python 查询语言，可以在 Pixie 的 UI、CLI 和客户端 API 中使用。Pixie 提供了一组<a href=https://docs.px.dev/tutorials/pixie-101/>社区脚本</a>常见示例。</li></ul><h2 id=简介>简介</h2><p>Pixie 由以下组件组成：</p><ul><li>Pixie 边缘模块（PEM）：Pixie 的代理，在每个节点安装，PEM 使用 eBPF 来收集数据，这些数据存储在节点的本地。</li><li>Vizier：Pixie 的收集器，按集群粒度进行安装，负责查询执行和 PEM 管理。</li><li>Pixie Cloud：用于用户管理、身份验证和数据代理，可以托管或自托管。</li><li>Pixie CLI: 用于部署 Pixie，还可以用于运行查询和管理资源，如 API keys。</li><li>Pixie Client API：用于对 Pixie 进行编程访问（例如集成、Slackbots 和需要 Pixie 数据作为输入的自定义用户逻辑）。</li></ul><p>主要核心组件：</p><ul><li>Vizier：Pixie 的数据面，用于进行数据收集和处理，每个需要监控的集群都会部署一个 Vizier 实例。</li><li>Cloud：Pixie 的控制面，用于服务 Pixie 的 API 和 UI，以及管理和跟踪元数据（例如组织、用户、Viziers）。</li><li>Vizier Operator：Pixie 的 <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/operator/>Kubernetes Operator</a>，用于帮助在集群上部署和管理 Vizier，如保持所有组件运行和同步最新版本。</li></ul><p>按照具体功能划分如下所示：</p><p><img src=/images/2023-10-21-introduce-pixie/2.png alt></p><h2 id=vizier>Vizier</h2><p>Vizier 数据平面主要包含以下部分：</p><ol><li>Pixie Edge Moudle(PEM）：<ul><li>数据收集，通过守护进程部署到每个节点；</li><li>短期存储，所有数据最多存储 24 小时；</li><li>执行脚本，在收到脚本执行请求时进行脚本处理。</li></ul></li><li>Collector（Kelvin）：<ul><li>处理数据：将 PEM 预处理的数据聚合成集群级视图；</li><li>聚合连接数据：完成所有数据的预处理执行步骤。</li></ul></li><li>Metadata：<ul><li>元数据中心，存储所有 Vizer 的元数据。</li></ul></li><li>Cloud Connector<ul><li>Vizer 和 Pixie Cloud 进行消息传递；</li><li>Vizer 整体状态：包括心跳以及脚本执行请求结果。</li></ul></li><li>Query Broker：<ul><li>编译脚本：处理所有脚本执行，并分发到 PEM；</li><li>代理数据：将编译脚本的结果代理回云端。</li></ul></li></ol><h2 id=cloud>Cloud</h2><p>Cloud 控制平面为 Pixie 的 API 和 UI 提供服务，以便轻松查询和访问 Viziers 的数据。
它还管理系统中的元数据，例如组织、用户和 Vizier，按照功能划分为以下四类：</p><ol><li>用户准入：<ul><li>Nginx & Envoy 代理</li><li>Auth 鉴权</li><li>API 服务</li></ul></li><li>组件通讯：<ul><li>Vizier 连接器</li></ul></li><li>管理版本：<ul><li>Vizier 管理器：管理 Vizier 状态；</li><li>Artifact Tracker：管理所有 Pixie 组件版本；</li><li>Plugin：管理插件信息。</li></ul></li><li>数据存储：<ul><li>索引器：以 Elastic 为索引引擎，NATS/STAN 为消息总线</li><li>配置文件</li></ul></li></ol><h2 id=vizier-operator>Vizier Operator</h2><p>Vizier Operator 用于管理集群上的 Vizier：</p><ol><li>最佳部署：Operator执行 Vizier 的初始部署，决定未指定的 Vizier 的最适合环境；</li><li>监视 Vizier 的整体状态：这包括根据 Pixie Cloud 的最新版本信息重新启动任何失败的依赖项并使 Vizier 保持最新状态。</li></ol><h2 id=数据源>数据源</h2><p>Pixie 可以由用户配置为从 Go 应用程序代码中收集动态日志，并运行自定义的 BPFTrace 脚本，Pixie 默认附带了一组数据源，用户也可以对其进行扩展，Pixie 会自动收集以下数据：</p><ul><li>协议 Trace：应用程序 pod 之间的整个请求生命周期，跟踪当前支持以下协议列表。</li><li>资源指标：pod 的 CPU、内存和 I/O 指标。</li><li>网络度量：网络层和连接级别的 RX/TX 统计信息。</li><li>JVM 度量：Java 应用程序的 JVM 内存管理度量。</li><li>应用程序 CPU 配置文件：从应用程序中采样堆栈跟踪。Pixie 的持续分析器始终在运行，帮助在需要时识别应用程序性能瓶颈。目前支持编译语言（Go、Rust、C/C++）。</li></ul><p>Pixie 自动支持跟踪的协议如下所示：</p><table><thead><tr><th>Protocol</th><th>Support</th><th>Notes</th></tr></thead><tbody><tr><td>HTTP</td><td>Supported</td><td></td></tr><tr><td>HTTP2</td><td>Supported for <a href=https://github.com/grpc/grpc-go>Golang gRPC</a>(with and without TLS).</td><td>Golang apps must have <a href=https://docs.px.dev/reference/admin/debug-info/>debug information</a>.</td></tr><tr><td>DNS</td><td>Supported</td><td></td></tr><tr><td>NATS</td><td>Supported</td><td>Requires a NATS build with <a href=https://docs.px.dev/reference/admin/debug-info/>debug information</a>.</td></tr><tr><td>MySQL</td><td>Supported</td><td></td></tr><tr><td>PostgreSQL</td><td>Supported</td><td></td></tr><tr><td>Cassandra</td><td>Supported</td><td></td></tr><tr><td>Redis</td><td>Supported</td><td></td></tr><tr><td>Kafka</td><td>Supported</td><td></td></tr><tr><td>AMQP</td><td>Supported</td><td></td></tr></tbody></table><h1 id=初识-pixie-的-ebpf>初识 Pixie 的 eBPF</h1><h2 id=pxl-与-bpftrace>pxl 与 bpftrace</h2><p>Pixie eBPF 的功能主要分为两部分，自带的 pxl 格式以及分发的 bpftrace 格式。</p><ul><li><p>自带的 eBPF 功能包括：</p><ul><li>协议追踪：网络调用 send() 和 recv()；</li><li>跟踪：TSL/SSL 连接，通过 TLS 库 API 直接截获加密之前的数据；</li><li>应用程序 CPU 采样；</li><li>分发分布式 bpftrace 脚本。</li></ul></li><li><p>PxL 格式使用说明：</p><ul><li><p>Pixie Language (PxL) ，是 pixie 自己的语言，是一种流数据语言。</p></li><li><p>PxL 可以通过 Pixie 平台使用基于 Web 的 UI、API 或 CLI 来执行。</p></li><li><p>PxL 的支持类型：</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>INT64</td><td>64-bit integer</td></tr><tr><td>UINT128</td><td>Unsigned 128-bit integer</td></tr><tr><td>FLOAT64</td><td>Double precision floating point</td></tr><tr><td>TIME64NS</td><td>Time represented as 64-bit integer in nanoseconds since UNIX epoch</td></tr><tr><td>STRING</td><td>UTF-8 encoded string value</td></tr><tr><td>BOOLEAN</td><td>Bool</td></tr></tbody></table></li><li><p>PxL 的设计理念：</p><ul><li>Pxl 是一种声明语言，声明程序要执行的操作；</li><li>所有 PxL 的值类型不可变；</li><li>PxL 的每个复制会创建一个隐式副本（引擎会自动优化）</li><li>PxL 的基本操作单元是数据帧，数据帧是元数据表和相关操作。</li></ul></li></ul></li><li><p>eBPF 每一个功能的架构是：</p><ul><li>data.pxl</li><li>manifest.yaml</li><li>vis.json</li></ul></li><li><p>直接使用 bpftrace：</p><ul><li>【printf 捕获】Pixie 的分布式，bpftrace 部署功能捕获通过 <code>bpftrace printf</code> 语句生成的输出，并将参数推送到自动创建的表中</li><li>要求：<ul><li>该程序必须至少有 1 条 printf 语句。</li><li>如果程序有超过 1 个 printf 语句，则所有语句的格式字符串 printfs 必须完全相同，因为它定义了表输出列。</li><li>BEGIN 与 END 块中不应有任何 printf 语句。</li><li>如果希望指定列名称，则必须通过在格式说明符前添加冒号（例如：name:%d）来完成，列名不能包含任何空格。</li><li>要以 Pixie 可识别的方式输出时间，请标记该列 time_ 并传递参数 nsecs。</li></ul></li></ul></li></ul><h2 id=cpu-内核栈调用原理>CPU 内核栈调用原理</h2><p>实现逻辑：</p><ul><li>采样逻辑：<ul><li>程序经过固定时间对 CPU 进行采样，触发 CPU 中断并收集此刻内核堆栈信息，包括当前上下文中的进程 pid、内核栈 id、用户栈 id。用户态收到内核态传入的上述信息后，将对应的堆栈地址转换为对应符号，进行可视化统计。</li></ul></li><li>触发条件：<ul><li>CPU 时钟触发器 <code>PERF_TYPE_SOFTWARE/PERF_COUNT_SW_CPU_CLOCK</code> 到达指定时间 <code>sampling_period_millis</code> 的倍数。</li></ul></li></ul><p>关键内核数据结构及函数说明：</p><p><img src=/images/2023-10-21-introduce-pixie/4.png alt></p><p>stack_traces 与 histogram 存储的数据结构示意图说明：</p><p><img src=/images/2023-10-21-introduce-pixie/3.png alt></p><p>eBPF 内核函数</p><ul><li>功能：<ul><li>获取当前上下文中用户 pid、内核栈 id、用户栈 id。</li><li>将用户 pid、内核栈 id、用户栈 id作为键值 key，统计出现次数。</li></ul></li><li>内核函数源代码：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>sample_stack_trace</span>(<span style=color:#ff79c6>struct</span> bpf_perf_event_data<span style=color:#ff79c6>*</span> ctx) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Sample the user stack trace, and record in the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>stack_traces structure.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> user_stack_id <span style=color:#ff79c6>=</span> stack_traces.get_stackid(<span style=color:#ff79c6>&amp;</span>ctx<span style=color:#ff79c6>-&gt;</span>regs, BPF_F_USER_STACK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Sample the kernel stack trace, and record in the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>stack_traces structure.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> kernel_stack_id <span style=color:#ff79c6>=</span> stack_traces.get_stackid(<span style=color:#ff79c6>&amp;</span>ctx<span style=color:#ff79c6>-&gt;</span>regs, <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Update the counters for this user+kernel stack trace
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>pair.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> stack_trace_key_t key <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>key.pid <span style=color:#ff79c6>=</span> bpf_get_current_pid_tgid() <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>32</span>;
</span></span><span style=display:flex><span>key.user_stack_id <span style=color:#ff79c6>=</span> user_stack_id;
</span></span><span style=display:flex><span>key.kernel_stack_id <span style=color:#ff79c6>=</span> kernel_stack_id;
</span></span><span style=display:flex><span>histogram.increment(key); <span style=color:#6272a4>//map.increment()的功能是将key对应的value的值增加1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用户态：</p><ol><li>设置定期运行的触发条件</li><li>从 BPF map 中提取收集数据</li><li>将堆栈收集到的地址从机器语言转化为符号（human readable symbols）</li></ol><p>时钟触发器：</p><ul><li>使用 BCC 自带的 <code>attach_perf_event</code> 功能，将 CPU 事件进行绑定，生成 CPU 触发事件代码。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>bcc<span style=color:#ff79c6>-&gt;</span>attach_perf_event(PERF_TYPE_SOFTWARE,
</span></span><span style=display:flex><span>PERF_COUNT_SW_CPU_CLOCK, std<span style=color:#ff79c6>::</span>string(probe_fn),sampling_period_millis
</span></span><span style=display:flex><span><span style=color:#ff79c6>*</span> kNanosPerMilli, <span style=color:#bd93f9>0</span>);
</span></span></code></pre></div><p>收集内核映射的 map 数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>ebpf<span style=color:#ff79c6>::</span>BPFStackTable stack_traces <span style=color:#ff79c6>=</span> bcc<span style=color:#ff79c6>-&gt;</span>get_stack_table(kStackTracesMapName);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ebpf<span style=color:#ff79c6>::</span>BPFHashTable<span style=color:#ff79c6>&lt;</span>stack_trace_key_t, <span style=color:#8be9fd>uint64_t</span><span style=color:#ff79c6>&gt;</span> histogram <span style=color:#ff79c6>=</span> bcc<span style=color:#ff79c6>-&gt;</span>get_hash_table<span style=color:#ff79c6>&lt;</span>stack_trace_key_t, <span style=color:#8be9fd>uint64_t</span><span style=color:#ff79c6>&gt;</span>(kHistogramMapName);
</span></span></code></pre></div><p>将内核堆栈地址转化为符号：</p><ul><li>BCC 自带功能 <code>stack_traces.get_stack_symbol</code>，它将堆栈跟踪中的地址列表转换为符号列表。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>std<span style=color:#ff79c6>::</span>map<span style=color:#ff79c6>&lt;</span>std<span style=color:#ff79c6>::</span>string, <span style=color:#8be9fd>int</span><span style=color:#ff79c6>&gt;</span> result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#ff79c6>for</span> (<span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> [key, count] <span style=color:#ff79c6>:</span> histogram.get_table_offline()) {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span> (key.pid <span style=color:#ff79c6>!=</span> target_pid) {
</span></span><span style=display:flex><span>     <span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   std<span style=color:#ff79c6>::</span>string stack_trace_str;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span> (key.user_stack_id <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>     std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>std<span style=color:#ff79c6>::</span>string<span style=color:#ff79c6>&gt;</span> user_stack_symbols <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>         stack_traces.get_stack_symbol(key.user_stack_id, key.pid);
</span></span><span style=display:flex><span>     <span style=color:#ff79c6>for</span> (<span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> <span style=color:#8be9fd;font-style:italic>sym</span> : user_stack_symbols) {
</span></span><span style=display:flex><span>       stack_trace_str <span style=color:#ff79c6>+=</span> sym;
</span></span><span style=display:flex><span>       stack_trace_str <span style=color:#ff79c6>+=</span> <span style=color:#f1fa8c>&#34;;&#34;</span>;
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span> (key.kernel_stack_id <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>     std<span style=color:#ff79c6>::</span>vector<span style=color:#ff79c6>&lt;</span>std<span style=color:#ff79c6>::</span>string<span style=color:#ff79c6>&gt;</span> user_stack_symbols <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>         stack_traces.get_stack_symbol(key.kernel_stack_id, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>     <span style=color:#ff79c6>for</span> (<span style=color:#ff79c6>const</span> <span style=color:#ff79c6>auto</span><span style=color:#ff79c6>&amp;</span> <span style=color:#8be9fd;font-style:italic>sym</span> : user_stack_symbols) {
</span></span><span style=display:flex><span>       stack_trace_str <span style=color:#ff79c6>+=</span> sym;
</span></span><span style=display:flex><span>       stack_trace_str <span style=color:#ff79c6>+=</span> <span style=color:#f1fa8c>&#34;;&#34;</span>;
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   result[stack_trace_str] <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h1 id=示例>示例</h1><p>官网的演示实例如下所示：<a href=https://youtu.be/5oY_ova5GrA>https://youtu.be/5oY_ova5GrA</a>。</p><p>其中 pixie 的示例界面如下所示：</p><p><img src=/images/2023-10-21-introduce-pixie/5.png alt></p><p><img src=/images/2023-10-21-introduce-pixie/6.png alt></p><p><img src=/images/2023-10-21-introduce-pixie/7.png alt></p><p><img src=/images/2023-10-21-introduce-pixie/8.png alt></p><p><img src=/images/2023-10-21-introduce-pixie/9.png alt></p><p><img src=/images/2023-10-21-introduce-pixie/10.png alt></p><h1 id=安装>安装</h1><p>具体安装 Pixie 可参见官网 <a href=https://docs.px.dev/installing-pixie/>https://docs.px.dev/installing-pixie/</a>，下次分享 Pixie 安装过程。</p><h1 id=参考>参考</h1><ol><li><a href=https://docs.px.dev/>https://docs.px.dev/</a></li></ol><hr><ul class=pager><li class=previous><a href=/post/2023-10-14-cilium-hubble/ data-toggle=tooltip data-placement=top title="使用 Hubble 实现 Kubernetes 服务可观测性（3）">&larr;
Previous Post</a></li><li class=next><a href=/post/2023-11-04-ebpf-ecosystem/ data-toggle=tooltip data-placement=top title="eBPF 周边生态圈明星产品">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>