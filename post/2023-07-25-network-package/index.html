<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="Linux 是如何处理网络数据包？"><meta property="og:title" content="Linux 是如何处理网络数据包？"><meta property="twitter:title" content="Linux 是如何处理网络数据包？"><meta name=description content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="og:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>Linux 是如何处理网络数据包？ | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2023-07-25-network-package/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/linux title=Linux>Linux</a>
<a class=tag href=/tags/network title=network>network</a></div><h1>Linux 是如何处理网络数据包？</h1><h2 class=subheading>当网络数据包到达网卡时，数据包从网卡是如何到 Linux（以内核4.19举例） 网络协议栈？</h2><span class=meta>Posted by
陈谭军
on
Tuesday, July 25, 2023
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2023-07-25-network-package/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 2347 字</span>，阅读约 <span class=more-meta>5 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>当网络数据包到达网卡时，数据包从网卡是如何到 Linux（以内核4.19举例） 网络协议栈？先回顾 OSI 七层模型与 TCP/IP 五层模型，如下所示：</p><p><img src=/images/2023-07-25-network-package/1.png alt></p><p>TCP/IP 应用层数据包的格式如下所示：</p><p><img src=/images/2023-07-25-network-package/2.png alt></p><p>我们先来了解一下 Linux 中的网络协议模型和网络子系统。</p><ul><li><p>网络协议模型（网络协议栈）</p><ul><li>应用层提供 socket 接口来供用户进程访问内核空间的网络协议栈</li><li>传输层、网络层协议由 Linux 内核网络协议栈实现</li><li>链路层协议靠网卡驱动来实现</li><li>物理层协议由硬件网卡实现</li></ul></li><li><p>网络子系统（网络子系统是 Linux 内核中的一部分，由多个模块和驱动程序组成，它负责管理和控制系统的网络功能以实现网络通信）</p><ul><li>System call interface：为应用程序获取内核的网络系统提供了接口，例如 socket</li><li>Protocol agnostic interface：为和各种传输层协议的网络交互提供的一层公共接口</li><li>Network protocals：对各种传输层协议的实现，如 TCP、UDP、IP 等</li><li>Device agnostic interface：为各种底层网络设备抽象出的公共接口，与各种网络设备驱动连接在一起</li><li>Device drivers：与各种网络设备交互的驱动</li></ul></li></ul><p>当 Linux 接收一个数据包的时候，这个包是怎么经过 Linux 的内核从而被应用程序拿到的呢？如下所示：</p><p><img src=/images/2023-07-25-network-package/3.png alt></p><p>1、数据到达网卡（NIC，Network Interface Card）</p><p>首先数据包到达网卡之后，网卡会校验接收到的数据包中的目的 MAC 地址是不是自己的 MAC 地址，如果不是的话通常就会丢弃掉。这种只接受发送给自己的数据包（其余的扔掉）的工作模式称为非混杂模式（Non-Promiscuous Mode）。混杂模式（Promiscuous Mode）则是网卡会接收通过网络传输的所有数据包，而不仅仅是发送给它自己的数据包。非混杂模式是网卡默认的工作模式，可以尽可能的保护网络安全和减少网络负载。网卡在校验完 MAC 地址之后还会校验数据帧（Data Frame）中校验字段 FCS 来一次确保接收到的数据包是正确的。</p><p>2、网卡硬件缓冲区 -> 系统内存（Ring Buffer）</p><p>当网卡接收到数据包时，它将数据包的内容存储在硬件缓冲区中，然后通过 DMA 将接收到的数据从硬件缓冲区传输到系统内存中的指定位置，这个位置通常是一个环形缓冲区（Ring Buffer）。</p><p>3、触发硬中断</p><p>当网卡将数据包 DMA 到用于接收的环形缓冲区（Ring Buffer）之后，就会触发一个硬中断来告诉 CPU 已经收到数据包。什么时候会触发一个硬中断，可以通过下面的参数来进行配置：</p><ul><li>rx-usecs：当过这么长时间过后，一个中断就会被产生。</li><li>rx-frames：当累计接收到这么多个数据帧后，一个中断就会被产生。</li></ul><p>当 Ring Buffer 满了之后，新来的数据包将给丢弃。CPU 收到硬中断之后就会停止手中的活，保存上下文，然后去调用网卡驱动注册的硬中断处理函数。为数据包分配 skb_buff，并将接收到的数据拷贝到 skb_buff 缓冲区中。当一个数据包经过了网卡引起中断之后，每一个包都会在内存中分配一块区域，称为 skb_buff (套接字缓存，socket buffer) skb_buff是 Linux 网络的一个核心数据结构。</p><p>4、触发软中断</p><ol><li>网卡的硬中断处理函数处理完之后驱动先关闭硬中断，然后开启软中断。待 Ring Buffer 中的所有数据包被处理完成后，开启网卡的硬中断，这样下次网卡再收到数据的时候就会通知 CPU。</li><li>调用 net_rx_action 函数，它会通过 poll 函数去 rx_ring 中拿数据帧，获取的时候顺便把 rx_ring 上的数据给删除。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>net_rx_action</span>(<span style=color:#ff79c6>struct</span> softirq_action <span style=color:#ff79c6>*</span>h)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> softnet_data <span style=color:#ff79c6>*</span>sd <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>&amp;</span>__get_cpu_var(softnet_data);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> time_limit <span style=color:#ff79c6>=</span> jiffies <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> budget <span style=color:#ff79c6>=</span> netdev_budget;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>have;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    local_irq_disable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> (<span style=color:#ff79c6>!</span>list_empty(<span style=color:#ff79c6>&amp;</span>sd<span style=color:#ff79c6>-&gt;</span>poll_list)) {
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>        n <span style=color:#ff79c6>=</span> list_first_entry(<span style=color:#ff79c6>&amp;</span>sd<span style=color:#ff79c6>-&gt;</span>poll_list, <span style=color:#ff79c6>struct</span> napi_struct, poll_list);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        work <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (test_bit(NAPI_STATE_SCHED, <span style=color:#ff79c6>&amp;</span>n<span style=color:#ff79c6>-&gt;</span>state)) {
</span></span><span style=display:flex><span>            work <span style=color:#ff79c6>=</span> n<span style=color:#ff79c6>-&gt;</span>poll(n, weight);
</span></span><span style=display:flex><span>            trace_napi_poll(n);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        budget <span style=color:#ff79c6>-=</span> work;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>除此之外，poll 函数会把 Ring Buffer 中的数据包转换成内核网络模块能够识别的 skb 格式（即 socket kernel buffer）。</li><li>最后进入 netif_receive_skb 处理流程，它是数据链路层接收数据帧的最后一关。根据注册在全局数组 ptype_all 和 ptype_base 里的网络层数据帧类型去调用第三层协议的接收函数处理。例如对于 ip 包来讲，就会进入到 ip_rcv；如果是 arp 包的话，会进入到 arp_rcv。</li></ol><p>5、到达网络层（以 IP 协议为例）</p><p>IP 层的入口函数在 ip_rcv 函数，调用 ip_rcv 函数进入三层协议栈。首先会对数据包进行各种检查（检查 IP Header），然后调用 netfilter 中的钩子函数：NF_INET_PRE_ROUTING。NF_INET_PRE_ROUTING 会根据预设的规则对数据包进行判断并根据判断结果做相关的处理（修改或者丢弃数据包）。处理完成后，数据包交由 ip_rcv_finish 处理，该函数根据路由判决结果，决定数据包是交由本机上层应用处理，还是需要进行转发。如果是交由本机处理，则会交由 ip_local_deliver 本地上交流程；如果需要转发，则交由 ip_forward 函数走转发流程。</p><p>6、到达传输层（以 TCP 为例）</p><p>传输层 TCP 处理入口在 tcp_v4_rcv 函数，首先检查数据包的 TCP 头部等信息，确保数据包的完整性和正确性。然后去查找该数据包对应的已经打开的 socket，如果找不到匹配的 socket，表示该数据包不属于任何一个已建立的连接，因此该数据包会被丢弃。如果找到了匹配的 socket，TCP 会进一步检查该 socket 和连接的状态，如果状态正常，TCP 会将数据包从内核传输到用户空间，放入 socket 的接收缓冲区（socket receive buffer）。</p><p>7、应用层</p><p>当数据包到达操作系统内核的传输层时，应用程序可以从套接字的接收缓冲区（socket receive buffer）中读取数据包。一般有两种方式读取数据，一种是 recvfrom 函数阻塞在那里等着数据来，这种情况下当 socket 收到通知后，recvfrom 就会被唤醒，然后读取接收队列的数据。另一种是通过 epoll 或者 select 监听相应的 socket，当收到通知后，再调用 recvfrom 函数去读取接收队列的数据。</p><p>总结一下 Linux 网络收包流程：</p><ul><li>数据到达网卡之后，网卡通过 DMA 将数据放到内存分配好的一块 Ring Buffer 中，然后触发硬中断；</li><li>CPU 收到硬中断之后简单的处理了一下（分配 skb_buffer），然后触发软中断；</li><li>软中断进程 ksoftirqd 执行一系列操作（例如把数据帧从 ring ruffer 上取下来）然后将数据送到三层协议栈中；</li><li>在三层协议栈中数据被进一步处理发送到四层协议栈；</li><li>在四层协议栈中，数据会从内核拷贝到用户空间，供应用程序读取；</li><li>最后被处在应用层的应用程序去读取；</li></ul><hr><ul class=pager><li class=previous><a href=/post/2023-06-25-caretta-ebpf/ data-toggle=tooltip data-placement=top title="使用 caretta 实现 Kubernetes 服务可观测性（1）">&larr;
Previous Post</a></li><li class=next><a href=/post/2023-08-12-cilium-mesh-example/ data-toggle=tooltip data-placement=top title="Cilium Mesh 常见场景与示例">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>