<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="简介 eBPF 常见跟踪点类型"><meta property="og:title" content="简介 eBPF 常见跟踪点类型"><meta property="twitter:title" content="简介 eBPF 常见跟踪点类型"><meta name=description content="通过 eBPF 可以对多种类型的事件进行跟踪，例如 kprobe、kretprobe、tracepoint、uprobe、uretprobe、socket filter、tc filter、perf events 等，本文主要介绍上述事件 Hook 跟踪点。"><meta property="og:description" content="通过 eBPF 可以对多种类型的事件进行跟踪，例如 kprobe、kretprobe、tracepoint、uprobe、uretprobe、socket filter、tc filter、perf events 等，本文主要介绍上述事件 Hook 跟踪点。"><meta property="twitter:description" content="通过 eBPF 可以对多种类型的事件进行跟踪，例如 kprobe、kretprobe、tracepoint、uprobe、uretprobe、socket filter、tc filter、perf events 等，本文主要介绍上述事件 Hook 跟踪点。"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>简介 eBPF 常见跟踪点类型 | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2023-04-05-ebpf-category/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/ebpf title=ebpf>ebpf</a>
<a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a></div><h1>简介 eBPF 常见跟踪点类型</h1><h2 class=subheading></h2><span class=meta>Posted by
陈谭军
on
Wednesday, April 5, 2023
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2023-04-05-ebpf-category/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 6860 字</span>，阅读约 <span class=more-meta>14 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>通过 eBPF 可以对多种类型的事件进行跟踪，例如 kprobe、kretprobe、tracepoint、uprobe、uretprobe、socket filter、tc filter、perf events 等，本文主要介绍上述事件 hook 跟踪点。</p><h1 id=kprobe>kprobe</h1><p>Linux kprobes 调试技术是内核开发者们专门为了便于跟踪内核函数执行状态所设计的一种轻量级内核调试技术。利用 kprobes 技术，内核开发人员可以在内核的绝大多数指定函数中动态的插入探测点来收集所需的调试状态信息而基本不影响内核原有的执行流程。当然，也不是所有的函数都是支持 kprobe 机制，可以通过 <code>cat /sys/kernel/debug/tracing/available_filter_functions</code> 查看当前系统支持的函数。</p><ul><li>kprobe 允许在内核函数的入口处插入一个断点。当 CPU 执行到这个位置时，会触发一个陷入（trap），CPU 切换到你预先定义的处理函数（probe handler）执行。这个处理函数可以访问和修改内核的状态，包括 CPU 寄存器、内核栈、全局变量等。执行完处理函数后，CPU 会返回到断点处，继续执行原来的内核代码。</li><li>kretprobe 允许在内核函数返回时插入探测点。这对于追踪函数的返回值或者函数的执行时间非常有用。kretprobe 的工作原理是在函数的返回地址前插入一个断点。当函数返回时，CPU 会先跳转到你的处理函数，然后再返回到原来的地址。具体可参见 <a href=https://github.com/torvalds/linux/blob/master/samples/kprobes/kprobe_example.c>kprobe_example.c</a> ，kprobe 是如何跟踪内核事件的。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>// SPDX-License-Identifier: GPL-2.0-only
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Here&#39;s a sample kernel module showing the use of kprobes to dump a
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * stack trace and selected registers when kernel_clone() is called.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * For more information on theory of operation of kprobes, see
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Documentation/trace/kprobes.rst
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * You will see the trace data in /var/log/messages and on the console
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * whenever kernel_clone() is invoked to create a new process.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#define pr_fmt(fmt) &#34;%s: &#34; fmt, __func__
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/kernel.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/module.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/kprobes.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>char</span> symbol[KSYM_NAME_LEN] <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;kernel_clone&#34;</span>;
</span></span><span style=display:flex><span>module_param_string(symbol, symbol, KSYM_NAME_LEN, <span style=color:#bd93f9>0644</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* For each probe you need to allocate a kprobe structure */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>struct</span> kprobe kp <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>	.symbol_name	<span style=color:#ff79c6>=</span> symbol,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* kprobe pre_handler: called just before the probed instruction is executed */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> __kprobes <span style=color:#50fa7b>handler_pre</span>(<span style=color:#ff79c6>struct</span> kprobe <span style=color:#ff79c6>*</span>p, <span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>regs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_X86
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, ip = %lx, flags = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>ip, regs<span style=color:#ff79c6>-&gt;</span>flags);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_PPC
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, nip = 0x%lx, msr = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>nip, regs<span style=color:#ff79c6>-&gt;</span>msr);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_MIPS
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, epc = 0x%lx, status = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>cp0_epc, regs<span style=color:#ff79c6>-&gt;</span>cp0_status);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_ARM64
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, pc = 0x%lx, pstate = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>pc, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>pstate);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_ARM
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, pc = 0x%lx, cpsr = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>ARM_pc, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>ARM_cpsr);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_RISCV
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, pc = 0x%lx, status = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>epc, regs<span style=color:#ff79c6>-&gt;</span>status);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_S390
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr, 0x%p, ip = 0x%lx, flags = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>psw.addr, regs<span style=color:#ff79c6>-&gt;</span>flags);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_LOONGARCH
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, era = 0x%lx, estat = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>csr_era, regs<span style=color:#ff79c6>-&gt;</span>csr_estat);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* A dump_stack() here will give a stack backtrace */</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* kprobe post_handler: called after the probed instruction is executed */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> __kprobes <span style=color:#50fa7b>handler_post</span>(<span style=color:#ff79c6>struct</span> kprobe <span style=color:#ff79c6>*</span>p, <span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>regs,
</span></span><span style=display:flex><span>				<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_X86
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, flags = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>flags);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_PPC
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, msr = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>msr);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_MIPS
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, status = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>cp0_status);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_ARM64
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, pstate = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>pstate);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_ARM
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, cpsr = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, (<span style=color:#8be9fd>long</span>)regs<span style=color:#ff79c6>-&gt;</span>ARM_cpsr);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_RISCV
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, status = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>status);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_S390
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr, 0x%p, flags = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>flags);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#ifdef CONFIG_LOONGARCH
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>	pr_info(<span style=color:#f1fa8c>&#34;&lt;%s&gt; p-&gt;addr = 0x%p, estat = 0x%lx</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		p<span style=color:#ff79c6>-&gt;</span>symbol_name, p<span style=color:#ff79c6>-&gt;</span>addr, regs<span style=color:#ff79c6>-&gt;</span>csr_estat);
</span></span><span style=display:flex><span><span style=color:#ff79c6>#endif
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> __init <span style=color:#50fa7b>kprobe_init</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> ret;
</span></span><span style=display:flex><span>	kp.pre_handler <span style=color:#ff79c6>=</span> handler_pre;
</span></span><span style=display:flex><span>	kp.post_handler <span style=color:#ff79c6>=</span> handler_post;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ret <span style=color:#ff79c6>=</span> register_kprobe(<span style=color:#ff79c6>&amp;</span>kp);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>		pr_err(<span style=color:#f1fa8c>&#34;register_kprobe failed, returned %d</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, ret);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;Planted kprobe at %p</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, kp.addr);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> __exit <span style=color:#50fa7b>kprobe_exit</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	unregister_kprobe(<span style=color:#ff79c6>&amp;</span>kp);
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;kprobe at %p unregistered</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, kp.addr);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>module_init(kprobe_init)
</span></span><span style=display:flex><span>module_exit(kprobe_exit)
</span></span><span style=display:flex><span>MODULE_LICENSE(<span style=color:#f1fa8c>&#34;GPL&#34;</span>);
</span></span></code></pre></div><p>使用 kprobe 针对 kernel_clone 进行探测，kprobe 是有其特定的开发模式，需要将 kprobe 代码编译成为一个 LKM 模块加载到内核中才能使用。除了开发比较繁琐之外，还因为是通过 LKM 加载到内核中，还容易造成内核崩溃。但是 eBPF 使用 kprobe 机制就很简单，见 <a href=https://github.com/torvalds/linux/blob/master/samples/bpf/test_overhead_kprobe.bpf.c>test_overhead_kprobe.bpf.c</a> 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>/* Copyright (c) 2016 Facebook
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * This program is free software; you can redistribute it and/or
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * modify it under the terms of version 2 of the GNU General Public
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * License as published by the Free Software Foundation.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;vmlinux.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/version.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_helpers.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_tracing.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_core_read.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kprobe/__set_task_comm&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> prog(<span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> signal_struct <span style=color:#ff79c6>*</span>signal;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> task_struct <span style=color:#ff79c6>*</span>tsk;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>char</span> oldcomm[TASK_COMM_LEN] <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>char</span> newcomm[TASK_COMM_LEN] <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>	u16 oom_score_adj;
</span></span><span style=display:flex><span>	u32 pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	tsk <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>)PT_REGS_PARM1_CORE(ctx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pid <span style=color:#ff79c6>=</span> BPF_CORE_READ(tsk, pid);
</span></span><span style=display:flex><span>	bpf_core_read_str(oldcomm, <span style=color:#ff79c6>sizeof</span>(oldcomm), <span style=color:#ff79c6>&amp;</span>tsk<span style=color:#ff79c6>-&gt;</span>comm);
</span></span><span style=display:flex><span>	bpf_core_read_str(newcomm, <span style=color:#ff79c6>sizeof</span>(newcomm),
</span></span><span style=display:flex><span>				  (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>)PT_REGS_PARM2(ctx));
</span></span><span style=display:flex><span>	signal <span style=color:#ff79c6>=</span> BPF_CORE_READ(tsk, signal);
</span></span><span style=display:flex><span>	oom_score_adj <span style=color:#ff79c6>=</span> BPF_CORE_READ(signal, oom_score_adj);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kprobe/fib_table_lookup&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> prog2(<span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>char</span> _license[] SEC(<span style=color:#f1fa8c>&#34;license&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;GPL&#34;</span>;
</span></span><span style=display:flex><span>u32 _version <span style=color:#50fa7b>SEC</span>(<span style=color:#f1fa8c>&#34;version&#34;</span>) <span style=color:#ff79c6>=</span> LINUX_VERSION_CODE;
</span></span></code></pre></div><p><code>SEC("kprobe/fib_table_lookup")</code> 是一个宏 SEC，它将 eBPF 程序与特定的 kprobe 关联起来。在这个例子中，它将 eBPF 程序与 fib_table_lookup 函数的 kprobe 关联起来。fib_table_lookup 是 Linux 内核中的一个函数，它用于在 <code>FIB（Forwarding Information Base）</code> 表中查找路由信息。
<code>SEC("kprobe/__set_task_comm")</code> 是一个宏 SEC，它将 eBPF 程序与特定的 kprobe 关联起来。在这个例子中，它将 eBPF 程序与 __set_task_comm 函数的 kprobe 关联起来。__set_task_comm 是 Linux 内核中的一个函数，它用于设置任务（即进程）的名称。在这个 eBPF 程序中，它首先获取了被调用 __set_task_comm 函数的任务结构体 task_struct 的指针，然后读取了任务的 PID、旧的名称、新的名称和 OOM（Out of Memory）得分调整值。</p><h1 id=kretprobe>kretprobe</h1><p>kretprobe 的使用基本上和 kprobe 是一致的，参见代码库 <a href=https://github.com/torvalds/linux/blob/611da07b89fdd53f140d7b33013f255bf0ed8f34/samples/kprobes/kretprobe_example.c>kretprobe_example.c</a> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>// SPDX-License-Identifier: GPL-2.0-only
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * kretprobe_example.c
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Here&#39;s a sample kernel module showing the use of return probes to
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * report the return value and total time taken for probed function
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * to run.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * usage: insmod kretprobe_example.ko func=&lt;func_name&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * If no func_name is specified, kernel_clone is instrumented
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * For more information on theory of operation of kretprobes, see
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Documentation/trace/kprobes.rst
</span></span></span><span style=display:flex><span><span style=color:#6272a4> *
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Build and insert the kernel module as done in the kprobe example.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * You will see the trace data in /var/log/messages and on the console
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * whenever the probed function returns. (Some messages may be suppressed
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * if syslogd is configured to eliminate duplicate messages.)
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/kernel.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/module.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/kprobes.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/ktime.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;linux/sched.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>char</span> func_name[KSYM_NAME_LEN] <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;kernel_clone&#34;</span>;
</span></span><span style=display:flex><span>module_param_string(func, func_name, KSYM_NAME_LEN, <span style=color:#bd93f9>0644</span>);
</span></span><span style=display:flex><span>MODULE_PARM_DESC(func, <span style=color:#f1fa8c>&#34;Function to kretprobe; this module will report the&#34;</span>
</span></span><span style=display:flex><span>			<span style=color:#f1fa8c>&#34; function&#39;s execution time&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* per-instance private data */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> my_data {
</span></span><span style=display:flex><span>	ktime_t entry_stamp;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* Here we use the entry_hanlder to timestamp function entry */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>entry_handler</span>(<span style=color:#ff79c6>struct</span> kretprobe_instance <span style=color:#ff79c6>*</span>ri, <span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>regs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> my_data <span style=color:#ff79c6>*</span>data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>current<span style=color:#ff79c6>-&gt;</span>mm)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;	<span style=color:#6272a4>/* Skip kernel threads */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	data <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> my_data <span style=color:#ff79c6>*</span>)ri<span style=color:#ff79c6>-&gt;</span>data;
</span></span><span style=display:flex><span>	data<span style=color:#ff79c6>-&gt;</span>entry_stamp <span style=color:#ff79c6>=</span> ktime_get();
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>NOKPROBE_SYMBOL(entry_handler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/*
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * Return-probe handler: Log the return value and duration. Duration may turn
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * out to be zero consistently, depending upon the granularity of time
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * accounting on the platform.
</span></span></span><span style=display:flex><span><span style=color:#6272a4> */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>ret_handler</span>(<span style=color:#ff79c6>struct</span> kretprobe_instance <span style=color:#ff79c6>*</span>ri, <span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>regs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> retval <span style=color:#ff79c6>=</span> regs_return_value(regs);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> my_data <span style=color:#ff79c6>*</span>data <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> my_data <span style=color:#ff79c6>*</span>)ri<span style=color:#ff79c6>-&gt;</span>data;
</span></span><span style=display:flex><span>	s64 delta;
</span></span><span style=display:flex><span>	ktime_t now;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	now <span style=color:#ff79c6>=</span> ktime_get();
</span></span><span style=display:flex><span>	delta <span style=color:#ff79c6>=</span> ktime_to_ns(ktime_sub(now, data<span style=color:#ff79c6>-&gt;</span>entry_stamp));
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;%s returned %lu and took %lld ns to execute</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>			func_name, retval, (<span style=color:#8be9fd>long</span> <span style=color:#8be9fd>long</span>)delta);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>NOKPROBE_SYMBOL(ret_handler);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>struct</span> kretprobe my_kretprobe <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>	.handler		<span style=color:#ff79c6>=</span> ret_handler,
</span></span><span style=display:flex><span>	.entry_handler		<span style=color:#ff79c6>=</span> entry_handler,
</span></span><span style=display:flex><span>	.data_size		<span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> my_data),
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Probe up to 20 instances concurrently. */</span>
</span></span><span style=display:flex><span>	.maxactive		<span style=color:#ff79c6>=</span> <span style=color:#bd93f9>20</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> __init <span style=color:#50fa7b>kretprobe_init</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	my_kretprobe.kp.symbol_name <span style=color:#ff79c6>=</span> func_name;
</span></span><span style=display:flex><span>	ret <span style=color:#ff79c6>=</span> register_kretprobe(<span style=color:#ff79c6>&amp;</span>my_kretprobe);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>		pr_err(<span style=color:#f1fa8c>&#34;register_kretprobe failed, returned %d</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, ret);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;Planted return probe at %s: %p</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>			my_kretprobe.kp.symbol_name, my_kretprobe.kp.addr);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>void</span> __exit <span style=color:#50fa7b>kretprobe_exit</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	unregister_kretprobe(<span style=color:#ff79c6>&amp;</span>my_kretprobe);
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;kretprobe at %p unregistered</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, my_kretprobe.kp.addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* nmissed &gt; 0 suggests that maxactive was set too low. */</span>
</span></span><span style=display:flex><span>	pr_info(<span style=color:#f1fa8c>&#34;Missed probing %d instances of %s</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>		my_kretprobe.nmissed, my_kretprobe.kp.symbol_name);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>module_init(kretprobe_init)
</span></span><span style=display:flex><span>module_exit(kretprobe_exit)
</span></span><span style=display:flex><span>MODULE_LICENSE(<span style=color:#f1fa8c>&#34;GPL&#34;</span>);
</span></span></code></pre></div><p>在这个模块中，它首先定义了一个 kretprobe 结构体 my_kretprobe，并设置了它的处理函数 ret_handler 和 entry_handler，以及用于存储每个实例数据的空间大小 data_size。entry_handler 函数在被跟踪的函数开始执行时被调用，它记录了函数开始执行的时间戳。ret_handler 函数在被跟踪的函数返回时被调用，它计算了函数的执行时间（即当前时间减去开始执行的时间戳），并打印了函数的返回值和执行时间。在 kretprobe_init 函数中，它注册了 kretprobe，使得内核开始跟踪指定的函数。在 kretprobe_exit 函数中，它注销了 kretprobe，使得内核停止跟踪该函数。这个模块可以通过 insmod 命令加载到内核中，然后你就可以在系统日志中看到被跟踪函数的执行时间和返回值。</p><h1 id=tracepoint>tracepoint</h1><p>tracepoints 是 Linux 内核中的一种机制，它们是在内核源代码中预定义的钩子点，用于插入用于跟踪和调试的代码。tracepoints 在内核中的特定位置被硬编码，每个 tracepoint 都有一个唯一的名称和一组相关的参数。</p><ul><li>tracepoints 的主要优点是它们对性能的影响非常小。当没有激活 tracepoint 时，它几乎不会影响系统性能。只有当一个 tracepoint 被激活，并且有一个或多个回调函数（也称为探针）附加到它时，它才会消耗 CPU 时间。tracepoints 非常适合在生产环境中使用，因为它们可以在需要时打开，而在不需要时关闭，以最小化性能影响。</li><li>tracepoints 的另一个优点是它们提供了一种稳定的 ABI（应用程序二进制接口）。这意味着，即使在内核版本升级后，tracepoint 的名称和参数不会改变，这使得开发者可以编写依赖于特定 tracepoint 的代码，而不用担心在未来的内核版本中这些 tracepoint 会改变。</li></ul><p>在 eBPF 中，你可以使用 tracepoint 来捕获内核中发生的事件。你可以编写一个 eBPF 程序，然后将它附加到一个 tracepoint 上。当 tracepoint 被触发时，你的 eBPF 程序会被调用，你可以在你的 eBPF 程序中访问 tracepoint 的参数，以获取有关事件的详细信息。tracepoints 和 kprobes/kretprobes 都是 Linux 内核中用于动态跟踪的机制，但它们在使用和性能方面有一些关键的区别。以下是 tracepoints 和 kprobes/kretprobes 的一些优缺点：</p><p>tracepoints：
优点：</p><ul><li>稳定性：Tracepoints 是内核开发者在代码中明确定义的，因此它们的位置和语义在内核版本之间是稳定的。</li><li>性能：Tracepoints 的开销通常比 kprobes/kretprobes 小，因为它们是在编译时直接嵌入到内核代码中的。</li><li>安全性：Tracepoints 不会改变内核代码，因此它们不会引入新的安全风险。
缺点：</li><li>灵活性：Tracepoints 的数量和位置是固定的，你不能在任意位置添加新的 tracepoints。</li><li>覆盖范围：并非所有的内核函数和事件都有对应的 tracepoints。</li></ul><p>Kprobes/Kretprobes：
优点：</p><ul><li>灵活性：你可以在任意的内核函数入口和退出点设置 kprobes/kretprobes，这使得它们可以覆盖到内核中的任何代码。</li><li>动态性：你可以在系统运行时动态地添加和移除 kprobes/kretprobes，而不需要重新编译或者重启内核。</li><li>稳定性：kprobes/kretprobes 的位置和语义可能会在不同的内核版本之间变化，因为它们依赖于具体的内核代码。
缺点：</li><li>性能：kprobes/kretprobes 的开销通常比 tracepoints 大，因为它们需要在运行时修改内核代码。</li><li>安全性：虽然 kprobes/kretprobes 有一些机制来防止它们引入新的安全风险，但是它们仍然比 tracepoints 更容易出错，因为它们需要在运行时修改内核代码。</li></ul><h1 id=socket>socket</h1><p>socket 就是和网络包相关的事件，常见的网络包处理函数有 sock_filter 和 sockops。eBPF 所有可以处理的事件类型都在 bpf.h 文件中定义。其中和 socket 相关的事件有：</p><ul><li>BPF_PROG_TYPE_SOCKET_FILTER: 这种类型的 eBPF 程序设计用于处理网络数据包；</li><li>BPF_PROG_TYPE_SOCK_OPS 和 BPF_PROG_TYPE_SK_SKB: 这两种类型的 eBPF 程序设计用于处理 socket 操作和 socket 缓冲区中的数据包；</li><li>BPF_PROG_TYPE_SK_MSG：用于处理 socket 消息；</li></ul><p>BPF_PROG_TYPE_SOCKET_FILTER 对应的 eBPF 代码是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;include/bpf.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;include/bpf_helpers.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;socket/sock_filter&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> socket_sock_filter(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;new packet received</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这段 eBPF 代码是一个 socket filter 程序，它不需要绑定到特定的内核函数上。相反，socket filter 程序会被附加到用户态创建的套接字上，然后对通过该套接字收发的所有数据包进行处理。<code>SEC("socket/sock_filter")</code> 是一个标记，表示这个 eBPF 程序应该作为一个 socket filter 使用。当你在用户态加载这个程序并将其附加到一个套接字上时，每当有新的数据包经过这个套接字时，这个程序就会被执行。在这个程序中，<code>bpf_printk("new packet received\n");</code> 语句会在每次接收到新数据包时向内核日志输出一条消息。返回值 0 表示该数据包应被接受（即不被丢弃）。</p><p>所以，对于这种类型的 eBPF 程序，你不需要指定要绑定的内核函数。你只需要在用户态创建一个套接字，并将这个 eBPF 程序附加到这个套接字上。对应用户端的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>newSocketPair</span>() (SocketPair, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> syscall.<span style=color:#50fa7b>Socketpair</span>(syscall.AF_UNIX, syscall.SOCK_DGRAM, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>	m <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>manager.Manager{
</span></span><span style=display:flex><span>		Probes: []<span style=color:#ff79c6>*</span>manager.Probe{
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				Section:      <span style=color:#f1fa8c>&#34;socket/sock_filter&#34;</span>,
</span></span><span style=display:flex><span>				EbpfFuncName: <span style=color:#f1fa8c>&#34;socket_sock_filter&#34;</span>,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	err <span style=color:#ff79c6>:=</span> m.<span style=color:#50fa7b>Init</span>(bytes.<span style=color:#50fa7b>NewReader</span>(_bytecode))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sockPair, err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>newSocketPair</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m.Probes[<span style=color:#bd93f9>0</span>].SocketFD = sockPair[<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过 <code>m.Probes[0].SocketFD = sockPair[0]</code>，将创建的 <code>socket/sock_filter</code> 对应的程序绑定到 <code>sockPair[0]</code> (即 socket 的输入)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>trigger</span>(sockPair SocketPair) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Sending a message through the socket pair to trigger the probes ...&#34;</span>)
</span></span><span style=display:flex><span>	_， err <span style=color:#ff79c6>:=</span> syscall.<span style=color:#50fa7b>Write</span>(sockPair[<span style=color:#bd93f9>1</span>]， <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	_， err = syscall.<span style=color:#50fa7b>Read</span>(sockPair[<span style=color:#bd93f9>0</span>]， <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过 <code>syscall.Write(sockPair[1]， nil)</code> 和 <code>syscall.Read(sockPair[0]， nil)</code> 触发 eBPF。实际的运行结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo cat /sys/kernel/debug/tracing/trace_pipe
</span></span><span style=display:flex><span> ___go_build_soc-3814323 <span style=color:#ff79c6>[</span>009<span style=color:#ff79c6>]</span> d...1 1508306.501709: bpf_trace_printk: new packet received
</span></span></code></pre></div><p>成功输出 <code>new packet received</code> 说明程序成功执行。</p><h1 id=sockops>sockops</h1><p>除了有 BPF_PROG_TYPE_SOCKET_FILTER，还有 BPF_PROG_TYPE_SOCK_OPS 类型的事件，BPF_PROG_TYPE_SOCK_OPS 类型的 eBPF 程序用于 TCP 事件的处理，例如连接的建立和断开、拥塞控制等。这种类型的程序可以用于获取和修改 socket 操作的各种参数，例如发送和接收窗口的大小，重传超时时间等。内核态的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;include/bpf.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;include/bpf_helpers.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;sockops&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> bpf_sockops(<span style=color:#ff79c6>struct</span> bpf_sock_ops <span style=color:#ff79c6>*</span>skops)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> (skops<span style=color:#ff79c6>-&gt;</span>op) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>default</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    		bpf_printk(<span style=color:#f1fa8c>&#34;eBPF sockops : %d </span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,skops<span style=color:#ff79c6>-&gt;</span>op);
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd>char</span> _license[] SEC(<span style=color:#f1fa8c>&#34;license&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;GPL&#34;</span>;
</span></span><span style=display:flex><span>__u32 _version <span style=color:#50fa7b>SEC</span>(<span style=color:#f1fa8c>&#34;version&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0xFFFFFFFE</span>;
</span></span></code></pre></div><p>bpf_sock_ops 在文件 bpf.h 中定义。由于 bpf_sock_ops 的定义较长，这里只列出部分代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bpf_sock_ops
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	__u32 op;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>union</span> {
</span></span><span style=display:flex><span>		__u32 args[<span style=color:#bd93f9>4</span>];		<span style=color:#6272a4>/* Optionally passed to bpf program */</span>
</span></span><span style=display:flex><span>		__u32 reply;		<span style=color:#6272a4>/* Returned by bpf program	    */</span>
</span></span><span style=display:flex><span>		__u32 replylong[<span style=color:#bd93f9>4</span>]; <span style=color:#6272a4>/* Optionally returned by bpf prog  */</span>
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>	__u32 family;
</span></span><span style=display:flex><span>	__u32 remote_ip4;	<span style=color:#6272a4>/* Stored in network byte order */</span>
</span></span><span style=display:flex><span>	__u32 local_ip4;	 <span style=color:#6272a4>/* Stored in network byte order */</span>
</span></span><span style=display:flex><span>	__u32 remote_ip6[<span style=color:#bd93f9>4</span>]; <span style=color:#6272a4>/* Stored in network byte order */</span>
</span></span><span style=display:flex><span>	__u32 local_ip6[<span style=color:#bd93f9>4</span>];  <span style=color:#6272a4>/* Stored in network byte order */</span>
</span></span><span style=display:flex><span>	__u32 remote_port;   <span style=color:#6272a4>/* Stored in network byte order */</span>
</span></span><span style=display:flex><span>	__u32 local_port;	<span style=color:#6272a4>/* stored in host byte order */</span>
</span></span><span style=display:flex><span>	__u32 is_fullsock;   <span style=color:#6272a4>/* Some TCP fields are only valid if
</span></span></span><span style=display:flex><span><span style=color:#6272a4>				 * there is a full socket. If not, the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>				 * fields read as zero.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>				 */</span>
</span></span><span style=display:flex><span>	.....
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>内核态的代码含义很简单明确，根据 skops->op 的值进行分支处理。<code>struct bpf_sock_ops</code> 是一个用于描述 socket 操作的结构体，其中的 op 字段表示当前的操作类型，默认情况下会通过 <code>bpf_printk</code> 输出，用户态代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>trigger</span>() {
</span></span><span style=display:flex><span>	fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Generating some network traffic to trigger the probes ...&#34;</span>)
</span></span><span style=display:flex><span>	_, _ = http.<span style=color:#50fa7b>Get</span>(<span style=color:#f1fa8c>&#34;https://www.bing.com/&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>detectCgroupPath</span>() (<span style=color:#8be9fd>string</span>, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	f, err <span style=color:#ff79c6>:=</span> os.<span style=color:#50fa7b>Open</span>(<span style=color:#f1fa8c>&#34;/proc/mounts&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;&#34;</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> f.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	scanner <span style=color:#ff79c6>:=</span> bufio.<span style=color:#50fa7b>NewScanner</span>(f)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> scanner.<span style=color:#50fa7b>Scan</span>() {
</span></span><span style=display:flex><span>		fields <span style=color:#ff79c6>:=</span> strings.<span style=color:#50fa7b>Split</span>(scanner.<span style=color:#50fa7b>Text</span>(), <span style=color:#f1fa8c>&#34; &#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(fields) <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>3</span> <span style=color:#ff79c6>&amp;&amp;</span> fields[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;cgroup2&#34;</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> fields[<span style=color:#bd93f9>1</span>], <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#f1fa8c>&#34;&#34;</span>, errors.<span style=color:#50fa7b>New</span>(<span style=color:#f1fa8c>&#34;cgroup2 is not mounted&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>manager.Manager{
</span></span><span style=display:flex><span>		Probes: []<span style=color:#ff79c6>*</span>manager.Probe{
</span></span><span style=display:flex><span>			{
</span></span><span style=display:flex><span>				Section:      <span style=color:#f1fa8c>&#34;sockops&#34;</span>,
</span></span><span style=display:flex><span>				EbpfFuncName: <span style=color:#f1fa8c>&#34;bpf_sockops&#34;</span>,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	err <span style=color:#ff79c6>:=</span> m.<span style=color:#50fa7b>Init</span>(bytes.<span style=color:#50fa7b>NewReader</span>(_bytecode))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	result, err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>detectCgroupPath</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	m.Probes[<span style=color:#bd93f9>0</span>].CGroupPath = result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> m.<span style=color:#50fa7b>Start</span>(); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fmt.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;successfully started, head over to /sys/kernel/debug/tracing/trace_pipe&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	time.<span style=color:#50fa7b>Sleep</span>(time.Second <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Generate some network traffic to trigger the probe
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>trigger</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Close the manager
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> m.<span style=color:#50fa7b>Stop</span>(manager.CleanAll); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		fmt.<span style=color:#50fa7b>Println</span>(err)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 sockops 是针对 TCP 事件的处理，所以可以通过构造一个网络事件来触发 sockops 的执行。在使用 eBPF 进行网络监控和处理时，指定 sockops 的 CGroupPath 是为了将 eBPF 程序限定在特定的 cgroup2 控制组中生效.cgroup（控制组）是 Linux 内核中的一个特性，用于对进程进行分组和限制资源的使用。通过将 eBPF 程序关联到特定的 cgroup2 控制组，可以实现对该组内的进程进行网络流量监控和处理。</p><p>具体来说，sockops 在 eBPF 中是一个用于监控和处理套接字操作的功能或钩子。它允许你捕获和处理诸如套接字创建、连接、关闭等事件。通过指定 CGroupPath，你可以使 sockops 程序仅在特定的 cgroup2 控制组中生效，只监控该组内的套接字操作。这样做的好处是可以针对特定的进程或应用程序进行网络监控和处理，而不会干扰其他进程或应用程序。同时，也能够提供更精细的网络流量控制和安全策略，增强系统的安全性和性能。</p><p>需要注意的是，指定 CGroupPath 前提是系统中已经挂载了 cgroup2 文件系统，并且相关的权限和配置已正确设置。否则，可能会导致无法在指定的 cgroup2 控制组中启用 eBPF 程序。最终通过 <code>http.Get("https://www.bing.com/")</code> 触发 socket 执行，最终运行的结果如下所示：</p><p><img src=/images/2023-04-05-ebpf-category/1.png alt></p><p>关于 socket 的妙用，可以参考 <a href=https://docs.daocloud.io/blogs/230508-cilium/>Cilium 基于 eBPF 实现 socket 加速</a>、<a href=https://atbug.com/accelerate-network-packets-transmission/>使用 eBPF 技术实现更快的网络数据包传输</a>。</p><h1 id=tc>tc</h1><p>tc 的全程是 traffic control，即流量控制。通过 tc 可以对网络流量进行控制，例如限速，限流，负载均衡等等。从 Kernel 4.1 开始，TC 支持加载 eBPF 程序到子系统的 Hook 点，并且在之后的 Kernel 4.4 中引入了 direct-action 模式，Cilium、Calico 等网络插件大量使用 TC Hook 来控制网络包的转发。子系统包括 qdisc、class、classifier（filter）、action 等概念，eBPF 程序可以作为 classifier 被挂载。想比其他类型的事件，需要额外引入 uapi/linux/pkt_cls.h 文件、pkt_cls.h 头文件提供了一组用于数据包分类的常量、数据结构和函数原型，例如 <code>struct __sk_buff</code> 结构体，它是 eBPF 中用于表示网络数据包的重要数据结构。</p><p>示例内核态代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;classifier/egress&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> egress_cls_func(<span style=color:#ff79c6>struct</span> __sk_buff <span style=color:#ff79c6>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;new packet captured on egress (TC)</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;classifier/ingress&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> ingress_cls_func(<span style=color:#ff79c6>struct</span> __sk_buff <span style=color:#ff79c6>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;new packet captured on ingress (TC)</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> TC_ACT_OK;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中 egress 表示出流量，ingress 表示进流量，TC_ACT_OK 表示数据包在经过 TC 分类器处理后，应该继续传递到下一个阶段或进行转发操作。</p><p>示例用户态代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>m <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>manager.Manager{
</span></span><span style=display:flex><span>	Probes: []<span style=color:#ff79c6>*</span>manager.Probe{
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			Section:          <span style=color:#f1fa8c>&#34;classifier/egress&#34;</span>,
</span></span><span style=display:flex><span>			EbpfFuncName:     <span style=color:#f1fa8c>&#34;egress_cls_func&#34;</span>,
</span></span><span style=display:flex><span>			Ifname:           <span style=color:#f1fa8c>&#34;wlp3s0&#34;</span>, <span style=color:#6272a4>// change this to the interface connected to the internet
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			NetworkDirection: manager.Egress,
</span></span><span style=display:flex><span>			SkipLoopback:     <span style=color:#ff79c6>true</span>, <span style=color:#6272a4>// ignore loopback traffic
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		},
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			Section:          <span style=color:#f1fa8c>&#34;classifier/ingress&#34;</span>,
</span></span><span style=display:flex><span>			EbpfFuncName:     <span style=color:#f1fa8c>&#34;ingress_cls_func&#34;</span>,
</span></span><span style=display:flex><span>			Ifname:           <span style=color:#f1fa8c>&#34;wlp3s0&#34;</span>, <span style=color:#6272a4>// change this to the interface connected to the internet
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			NetworkDirection: manager.Ingress,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>相比之前事件类型，tc 的 Probe 配置也额外多了几项，分别是 <code>Ifname/SkipLoopback/NetworkDirection</code>。</p><ul><li>Ifname：指定要附加到的网络接口的名称。这是一个字符串，需要根据实际运行的机器上的网卡地址的名称进行修改，常见的网卡名称就是 &ldquo;eth0&rdquo;。在本机上，可以通过 <code>ip addr</code> 命令查看网卡名称。</li><li>SkipLoopback：指示是否跳过回环设备的标志。当设置为 true 时，如果数据包是通过回环设备（loopback）发送或接收的，则不会触发 eBPF 程序。这在一些情况下很有用，因为回环设备上的数据包通常不需要进行额外的处理。</li><li>NetworkDirection：指定网络流量的方向。它可以是 manager。Ingress（入站）、manager 或者 Egress（出站）。这决定了 eBPF 程序将被应用于哪个方向的流量。请注意，在某些情况下，如果你在虚拟以太网对的主机侧进行挂钩，则 Ingress 和 Egress 的含义可能会相反。</li></ul><p><img src=/images/2023-04-05-ebpf-category/3.png alt></p><h1 id=xdp>xdp</h1><p>XDP 机制的主要目标是在接收数据包时尽早处理它们，以提高网络性能和降低延迟。它通过将 eBPF 程序附加到网络设备的接收路径上来实现这一目标。具体而言，XDP 程序会在数据包进入网络设备的接收队列之前执行，这样可以在内核中进行快速的数据包过滤和处理，而无需将数据包传递给用户空间。tc（Traffic Control）和 xdp（eXpress Data Path）是 Linux 网络中两种不同的数据包处理机制，他们的区别如下：</p><ul><li>位置不同: tc 位于 Linux 网络协议栈的较高层，主要用于在网络设备的出入口处对数据包进行分类、调度和限速等操作。而 xdp 位于网络设备驱动程序的接收路径上，用于快速处理数据包并决定是否将其传递给协议栈。</li><li>执行时机不同: tc 在数据包进入或离开网络设备时执行，通常在内核空间中进行。而 xdp 在数据包进入网络设备驱动程序的接收路径时执行，可以在内核空间中或用户空间中执行。</li><li>处理能力不同: tc 提供了更复杂的流量控制和分类策略，可以实现各种 QoS（Quality of Service）功能。它可以对数据包进行过滤、限速、排队等操作。而 xdp 主要用于快速的数据包过滤和处理，以降低延迟和提高性能。</li></ul><p>xdp 和 tc 的代码基本相同，除了 Section 不同之外，其他的都是一样的，示例代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;xdp/ingress&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> egress_cls_func(<span style=color:#ff79c6>struct</span> __sk_buff <span style=color:#ff79c6>*</span>skb)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;new packet captured (XDP)</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> XDP_PASS;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>用户态的代码也和 tc 的代码一致，不做说明。</p><h1 id=uprobe>uprobe</h1><p>uprobe 是 &ldquo;User Probe&rdquo; 的缩写，它利用了 Linux 内核中的 ftrace（function trace）框架来实现。通过 uprobe，可以在用户空间程序的指定函数入口或出口处插入探测点，当该函数被调用或返回时，可以触发事先定义的处理逻辑。kprobe 是用于监控内核态的程序，uprobe 就是用于监控用户态的程序。目前 uprobe 最常用的做法就是用在获取 bash 的命令。内核态代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;uprobe/readline&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> uprobe_readline(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;new bash command detected</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这个内核态的代码是用于监控 bash 命令的，当 bash 命令被执行时，就会触发 <code>uprobe_readline</code> 的执行，基本上和其他类型的监控事件没有差别。用户态代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>m <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>manager.Manager{
</span></span><span style=display:flex><span>	Probes: []<span style=color:#ff79c6>*</span>manager.Probe{
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			Section:          <span style=color:#f1fa8c>&#34;uprobe/readline&#34;</span>,
</span></span><span style=display:flex><span>			EbpfFuncName:     <span style=color:#f1fa8c>&#34;uprobe_readline&#34;</span>,
</span></span><span style=display:flex><span>			AttachToFuncName: <span style=color:#f1fa8c>&#34;readline&#34;</span>,
</span></span><span style=display:flex><span>			BinaryPath:       <span style=color:#f1fa8c>&#34;/usr/bin/bash&#34;</span>,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	},
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>uprobe 监控相比其他类型事件的监控存在一个很明显的差别，需要额外配置 BinaryPath。原因是因为 uprobe 针对用户态程序的监控，所以需要指定用户态程序的路径。在本例中，我们针对的是 bash 进程，所以需要指定 <code>/usr/bin/bash</code>，最终运行的结果如下所示：</p><p><img src=/images/2023-04-05-ebpf-category/2.png alt></p><hr><ul class=pager><li class=previous><a href=/post/2023-04-01-ebpf-introduce/ data-toggle=tooltip data-placement=top title="简单了解与学习 eBPF">&larr;
Previous Post</a></li><li class=next><a href=/post/2023-04-20-cilium-mesh-one-mesh/ data-toggle=tooltip data-placement=top title="译文：Cilium Mesh - Mesh 连接所有应用">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2023</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>