<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）"><meta property="og:title" content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）"><meta property="twitter:title" content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）"><meta name=description content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="og:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>深入理解 Kubernetes Scheduler Framework 调度框架（Part 1） | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2024-04-06-scheduler-framework-01/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a>
<a class=tag href=/tags/scheduler-framework title="Scheduler Framework">Scheduler Framework</a></div><h1>深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）</h1><h2 class=subheading>Scheduler Framework 框架整体架构与 Pod 调度到 Node 流程插件拓展点</h2><span class=meta>Posted by
陈谭军
on
Saturday, April 6, 2024
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2024-04-06-scheduler-framework-01/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 5421 字</span>，阅读约 <span class=more-meta>11 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Scheduler 分两个 cycle：Scheduling Cycle 和 Binding Cycle。在 Scheduling Cycle 中为了提升效率的一个重要原则就是 Pod、 Node 等信息从本地缓存中获取，而具体的实现原理就是先使用 list 获取所有 Node、Pod 的信息，然后再 watch 他们的变化更新本地缓存。在 Bind Cycle 中，会有两次外部 api 调用：调用 pv controller 绑定 pv 和调用 kube-apiserver 绑定 Node，api 调用是耗时的，所以将 bind 扩展点拆分出来，另起一个 go 协程进行 bind。调度周期是串行，绑定周期是并行的。本文主要介绍 Scheduler Framework 框架整体架构与 Pod 调度到 Node 流程插件拓展点。</p><p><a href=https://tanjunchen.github.io/post/2024-04-07-scheduler-framework-02/>深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）</a><br><a href=https://tanjunchen.github.io/post/2024-04-06-scheduler-framework-01/>深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）</a></p><h1 id=调度器介绍>调度器介绍</h1><p>Kubernetes 官方对于 scheduler 调度器的解释如下所示：</p><pre tabindex=0><code>The Kubernetes scheduler is a control plane process which assigns Pods to Nodes. 
The scheduler determines which Nodes are valid placements for each Pod in the scheduling queue 
according to constraints and available resources. 
The scheduler then ranks each valid Node and binds the Pod to a suitable Node. 
Multiple different schedulers may be used within a cluster.
kube-scheduler is the reference implementation.
</code></pre><p>Pod 调度到 Node 上，Kubernetes 各个组件交互流程如下所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/1.png alt></p><p>Pod 调度到 Node 上，Kubernetes Scheduler 的核心流程如下所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/2.png alt></p><h1 id=基于预选与优选调度器>基于预选与优选调度器</h1><p>在 Kubernetes 1.14 版本之前，Scheduler 是基于预选（Predicates-Filtering）与优选（Priorities-Scoring）策略的调度器，如下图所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/3.png alt></p><p>其中影响上述 Pod 调度到 Node 常见因素如下所示：</p><ul><li>podspec nodename</li><li>podspec nodeselector</li><li>Pod Priority（优先级） 与 Preemption（抢占）</li><li>Pod Affinity（亲和性）与 Anti-affinity（反亲和性）</li><li>Node Affinity（亲和性）与 Anti-affinity（反亲和性）</li><li>Node Taints（污点）与 Tolerations（容忍度）</li><li>Pod Disruption Budgets(PDB) 限制由于自愿中断（例如维护、升级、重新调度等）</li></ul><h1 id=扩展-scheduler-调度器>扩展 Scheduler 调度器</h1><p>一般来说，有4种扩展 Kubernetes 调度器的方法，如下所示：</p><table><thead><tr><th>扩展方式</th><th>优缺点</th><th>备注</th></tr></thead><tbody><tr><td>修改 kube-scheduler 源码</td><td>不易维护</td><td></td></tr><tr><td>multiple schedulers</td><td>可能会产生调度冲突问题，比如一个 scheduler bind 的时候实际资源已经被另一个 scheduler 已分配</td><td></td></tr><tr><td>extend scheduler</td><td>policy 文件可配置 Webhook，支持 Predicate、Priority、Bind、preemption 扩展点，实现简单 webhook 性能上会有一定损失，在有大量pod调度的时候会变慢，内部没有资源视图，需要自己获取</td><td><a href=https://github.com/AliyunContainerService/gpushare-scheduler-extender>gpushare-scheduler-extender</a></td></tr><tr><td>Scheduler Framework</td><td>Kubernetes v1.15 引入，extend scheduler即将被废弃，推荐 Scheduler Framework 插件形式扩展，方便和社区同步与原生 scheduler 联编，性能不会有问题</td><td></td></tr></tbody></table><h1 id=scheduler-framework-调度器>Scheduler Framework 调度器</h1><h2 id=整体架构>整体架构</h2><p><img src=/images/2024-04-06-scheduler-framework-01/4.png alt></p><h2 id=调度流程>调度流程</h2><p>Scheduler 分两个 cycle：Scheduling Cycle 和 Binding Cycle。在 Scheduling Cycle 中为了提升效率的一个重要原则就是 Pod、 Node 等信息从本地缓存中获取，而具体的实现原理就是先使用 list 获取所有 Node、Pod 的信息，然后再 watch 他们的变化更新本地缓存。在 Bind Cycle 中，会有两次外部 api 调用：调用 pv controller 绑定 pv 和调用 kube-apiserver 绑定 Node，api 调用是耗时的，所以将 bind 扩展点拆分出来，另起一个 go 协程进行 bind。</p><h2 id=等待调度阶段>等待调度阶段</h2><h3 id=preenqueue>PreEnqueue</h3><p>Pod 处于 ready for scheduling 的阶段。只有当所有 PreEnqueue 插件返回Success时，Pod 才允许进入活动队列。否则，它将被放置在内部无法调度的 Pod 列表中，并且不会获得Unschedulable状态。调度失败就不会进入调度队列，更不会进入调度流程。</p><h3 id=queuesort>QueueSort</h3><p>排序扩展点，对调度队列（scheduling queue）内的 pod 进行排序，决定先调度哪些 pods，代码位于 kubernetes 的 pkg/scheduler/framework/interface.go 中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// QueueSortPlugin is an interface that must be implemented by &#34;QueueSort&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins are used to sort pods in the scheduling queue. Only one queue sort
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// plugin may be enabled at a time.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> QueueSortPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Less are used to sort pods in the scheduling queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Less</span>(<span style=color:#ff79c6>*</span>QueuedPodInfo, <span style=color:#ff79c6>*</span>QueuedPodInfo) <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>也就是只需要实现 Less 方法即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Less</span>(podInfo1, podInfo2 <span style=color:#ff79c6>*</span>framework.PodInfo) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>GetPodPriority</span>(podInfo1) &gt; <span style=color:#50fa7b>GetPodPriority</span>(podInfo2)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>sort 类型的扩展点只有一个，而且这个扩展点下面只能有一个插件可以运行，如果同时 enable 多个 sort 插件，scheduler 会退出。在 k8s 中，待调度的 Pod 会放在一个叫 activeQ 队列中，这个队列是一个基于堆实现的优先队列（priority queue）。因为可以对 Pod 设置优先级，将认为需要优先调度的 Pod 优先级调大，如果队列里有多个 Pod 需要调度，就会出现抢占现象，优先级高的 Pod 会移动到队列头部，scheduler 会优先取出这个 Pod 进行调度。那么这个优先级怎么设置呢？</p><ol><li>如使用 k8s 默认 sort 插件，则可以给 Pod 设置 PriorityClass（创建 PriorityClass 资源并配置 deployment）；如果所有 Pod 都没有设置 PriorityClass，那么会根据 Pod 创建的时间先后顺序进行调度。PriorityClass 和 Pod 创建时间是系统默认的排序依据。</li><li>实现自己的 sort 插件定制排序算法，根据该排序算法实现抢占，例如可以将包含特定标签的 Pod 移到队头。</li></ol><h2 id=调度阶段scheduling-cycle>调度阶段（Scheduling cycle）</h2><p>filter 类型扩展点有3个：prefilter，filter，postfilter。各个扩展点有多个插件组成的插件集合根据 Pod 的配置共同过滤 Node。</p><p>preFilter 扩展点主要有两个作用，一是为后面的扩展点计算 Pod 的一些信息，例如 preFilter 阶段的 NodeResourcesFit 算法不会去判断节点合适与否，而是计算这个Pod需要多少资源，然后存储这个信息。Filter 扩展点的 NodeResourcesFit 插件会把之前算出来的资源拿出来做判断；另外一个作用就是过滤一些明显不符合要求的节点，这样可以减少后续扩展点插件一些无意义的计算。</p><p>filter 扩展点主要的作用就是根据各个插件定义的顺序依次执行，筛选出符合 Pod 的节点，这些插件会在 preFilter 后留下的每个 Node 上运行，如果能够通过所有插件，那么这个节点就留下来了。如果某个插件判断这个节点不符合，那么剩余的所有插件都不会对该节点做计算。</p><p>postFilter 扩展点只会在 filter 结束后没有任何 Node 符合 Pod 的情况下才会运行，否则这个扩展点会被跳过。这个扩展点在系统只有一个默认的插件，这个默认插件的作用遍历这个 Pod 所在的命名空间下面的所有 Pod，查找是否有可以被抢占的 Pod，如果有的话选出一个最合适的 Pod 然后 delete 掉这个Pod，并在待调度的 Pod 的 status 字段下面配置 nominateNode 为这个被抢占的 Pod。</p><ul><li>prefilter<ul><li>NodeResourcesFit</li><li>NodePorts</li><li>VolumeRestrictions</li><li>PodTopologySpread</li><li>InterPodAffinity</li><li>VolumeBinding</li><li>NodeAffinity</li></ul></li><li>filter<ul><li>NodeUnschedulable</li><li>NodeName</li><li>TaintToleration</li><li>NodeAffinity</li><li>NodePorts</li><li>NodeResourcesFit</li><li>VolumeRestrictions</li><li>NodeVolumeLimits</li><li>VolumeBinding</li><li>VolumeZone</li><li>PodTopologySpread</li><li>InterPodAffinity</li></ul></li><li>postfilter<ul><li>DefaultPreemption</li></ul></li></ul><h3 id=prefilter>PreFilter</h3><p>预过滤器插件应实现 PreFilter 函数，如果 PreFilter 返回错误，则调度周期将中止。Pre-filter 插件可以选择实现 PreFilterExtensions 接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PreFilterPlugin is an interface that must be implemented by &#34;PreFilter&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins are called at the beginning of the scheduling cycle.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PreFilterPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// PreFilter is called at the beginning of the scheduling cycle. All PreFilter
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// plugins must return success or the pod will be rejected. PreFilter could optionally
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// return a PreFilterResult to influence which nodes to evaluate downstream. This is useful
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// for cases where it is possible to determine the subset of nodes to process in O(1) time.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PreFilter</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod) (<span style=color:#ff79c6>*</span>PreFilterResult, <span style=color:#ff79c6>*</span>Status)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// PreFilterExtensions returns a PreFilterExtensions interface if the plugin implements one,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// or nil if it does not. A Pre-filter plugin can provide extensions to incrementally
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// modify its pre-processed info. The framework guarantees that the extensions
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// AddPod/RemovePod will only be called after PreFilter, possibly on a cloned
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// CycleState, and may call those functions more than once before calling
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Filter again on a specific node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PreFilterExtensions</span>() PreFilterExtensions
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#6272a4>// PreFilterExtensions is an interface that is included in plugins that allow specifying
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// callbacks to make incremental updates to its supposedly pre-calculated
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// state.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PreFilterExtensions <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// AddPod is called by the framework while trying to evaluate the impact
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// of adding podToAdd to the node while scheduling podToSchedule.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>AddPod</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, podToSchedule <span style=color:#ff79c6>*</span>v1.Pod, podInfoToAdd <span style=color:#ff79c6>*</span>PodInfo, nodeInfo <span style=color:#ff79c6>*</span>NodeInfo) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// RemovePod is called by the framework while trying to evaluate the impact
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// of removing podToRemove from the node while scheduling podToSchedule.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>RemovePod</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, podToSchedule <span style=color:#ff79c6>*</span>v1.Pod, podInfoToRemove <span style=color:#ff79c6>*</span>PodInfo, nodeInfo <span style=color:#ff79c6>*</span>NodeInfo) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>输入<ul><li>podToSchedule *v1.Pod 是待调度的 pod；</li><li>state 表示调度的上下文，可用于保存一些状态信息；</li></ul></li><li>输出<ul><li>只要有任何一个 plugin 返回失败，这个 pod 的调度就失败了；</li><li>所有已经注册的 PreFilter plugins 都成功之后，pod 才会进入到下一个环节；</li></ul></li></ul><h3 id=filter>Filter</h3><p>可以过滤掉那些不满足要求的 Node，针对每个 Node，调度器会按配置顺序依次执行 filter plugins。
任何一个插件 返回失败，这个 node 就被排除；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// FilterPlugin is an interface for Filter plugins. These plugins are called at the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// filter extension point for filtering out hosts that cannot run a pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// This concept used to be called &#39;predicate&#39; in the original scheduler.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins should return &#34;Success&#34;, &#34;Unschedulable&#34; or &#34;Error&#34; in Status.code.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// However, the scheduler accepts other valid codes as well.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Anything other than &#34;Success&#34; will lead to exclusion of the given host from running the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> FilterPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Filter is called by the scheduling framework.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// All FilterPlugins should return &#34;Success&#34; to declare that
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the given node fits the pod. If Filter doesn&#39;t return &#34;Success&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// it will return &#34;Unschedulable&#34;, &#34;UnschedulableAndUnresolvable&#34; or &#34;Error&#34;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// For the node being evaluated, Filter plugins should look at the passed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// nodeInfo reference for this particular node&#39;s information (e.g., pods
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// considered to be running on the node) instead of looking it up in the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// NodeInfoSnapshot because we don&#39;t guarantee that they will be the same.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// For example, during preemption, we may pass a copy of the original
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// nodeInfo object that has some pods removed from it to evaluate the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// possibility of preempting them to schedule the target pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Filter</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod, nodeInfo <span style=color:#ff79c6>*</span>NodeInfo) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>输入<ul><li>nodeInfo 是当前给定的 node 的信息，Filter() 程序判断这个 node 是否符合要求；</li></ul></li><li>输出<ul><li>放行或拒绝；
对于给定 node，如果所有 Filter plugins 都返回成功，该 node 才算通过筛选， 成为备选 node 之一。</li></ul></li></ul><h3 id=postfilter>PostFilter</h3><p>如果 Filter 阶段之后，所有 nodes 都被筛掉了，一个都没剩，才会执行这个阶段；否则不会执行这个阶段的 plugins。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PostFilterPlugin is an interface for &#34;PostFilter&#34; plugins. These plugins are called after a pod cannot be scheduled.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PostFilterPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// A PostFilter plugin should return one of the following statuses:
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// - Unschedulable: the plugin gets executed successfully but the pod cannot be made schedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// - Success: the plugin gets executed successfully and the pod can be made schedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// - Error: the plugin aborts due to some internal error.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Informational plugins should be configured ahead of other ones, and always return Unschedulable status.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Optionally, a non-nil PostFilterResult may be returned along with a Success status. For example,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// a preemption plugin may choose to return nominatedNodeName, so that framework can reuse that to update the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// preemptor pod&#39;s .spec.status.nominatedNodeName field.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PostFilter</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod, filteredNodeStatusMap NodeToStatusMap) (<span style=color:#ff79c6>*</span>PostFilterResult, <span style=color:#ff79c6>*</span>Status)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>按 plugin 顺序依次执行，任何一个插件将 node 标记为Schedulable就算成功，不再执行剩下的 PostFilter plugins。典型的 PostFilter 实现是抢占，试图通过抢占其他 Pod 的资源使该 Pod 可以调度。</p><p>Score 类型的扩展点就是为上面 filter 扩展点筛选出来的所有 Node 进行打分，挑选出一个得分最高（最合适的），这个 Node 就是 Pod 要被调度上去的节点。这个类型的扩展有 preScore 和 score 两个，前者是为后者打分做前置准备的，preScore 的各个插件会计算一些信息供 score 使用，这个和 prefilter 比较类似。</p><h3 id=prescore>PreScore</h3><p>这些插件用于执行前置评分（pre-scoring）工作，即生成一个可共享状态供 Score 插件使用，如果 PreScore 插件返回错误，则调度周期将终止。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PreScorePlugin is an interface for &#34;PreScore&#34; plugin. PreScore is an
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// informational extension point. Plugins will be called with a list of nodes
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// that passed the filtering phase. A plugin may use this data to update internal
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// state or to generate logs/metrics.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PreScorePlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// PreScore is called by the scheduling framework after a list of nodes
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// passed the filtering phase. All prescore plugins must return success or
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the pod will be rejected
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PreScore</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod, nodes []<span style=color:#ff79c6>*</span>v1.Node) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=score>Score</h3><p>这些插件用于对通过过滤阶段的节点进行排序。针对每个 node 依次调用 scoring plugin，得到一个分数（将有一个定义明确的整数范围，代表最小和最大分数）。在 normalize scoring 阶段，调度器将会把每个 scoring 扩展对具体某个节点的评分结果和该扩展的权重合并起来，作为最终评分结果。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// ScorePlugin is an interface that must be implemented by &#34;Score&#34; plugins to rank
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// nodes that passed the filtering phase.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> ScorePlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Score is called on each filtered node. It must return success and an integer
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// indicating the rank of the node. All scoring plugins must return success or
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the pod will be rejected.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Score</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>) (<span style=color:#8be9fd>int64</span>, <span style=color:#ff79c6>*</span>Status)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ScoreExtensions returns a ScoreExtensions interface if it implements one, or nil if does not.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>ScoreExtensions</span>() ScoreExtensions
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=normalizescore>NormalizeScore</h3><p>在调度器对节点进行最终排序之前修改每个节点的评分结果，注册到该扩展点的扩展在被调用时，将使用同一个插件中的 score 扩展的评分结果作为参数，每个插件在每个调度周期调用一次。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// ScoreExtensions is an interface for Score extended functionality.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> ScoreExtensions <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// NormalizeScore is called for all node scores produced by the same plugin&#39;s &#34;Score&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// method. A successful run of NormalizeScore will update the scores list and return
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// a success status.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>NormalizeScore</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, scores NodeScoreList) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=reserve>Reserve</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// ReservePlugin is an interface for plugins with Reserve and Unreserve// methods. These are meant to update the state of the plugin. This concept
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// used to be called &#39;assume&#39; in the original scheduler. These plugins should
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// return only Success or Error in Status.code. However, the scheduler accepts
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// other valid codes as well. Anything other than Success will lead to
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// rejection of the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> ReservePlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Reserve is called by the scheduling framework when the scheduler cache is
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// updated. If this method returns a failed Status, the scheduler will call
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// the Unreserve method for all enabled ReservePlugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Reserve</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Unreserve is called by the scheduling framework when a reserved pod was
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// rejected, an error occurred during reservation of subsequent plugins, or
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// in a later phase. The Unreserve method implementation must be idempotent
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// and may be called by the scheduler even if the corresponding Reserve
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// method for the same plugin was not called.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Unreserve</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Reserve是在调度程序实际将 Pod 绑定到 Node 之前发生的，它的存在是为了防止在调度程序等待绑定成功时发生资源竞争。如果一个 Reserve 方法调用失败，后面的插件就不会被执行，Reserve 阶段被认为失败。 如果所有插件的 Reserve 方法都成功了，Reserve 阶段就被认为是成功的， 剩下的调度周期和绑定周期就会被执行。</p><p>如果 Reserve 阶段或后续阶段失败了，则触发 Unreserve 阶段。 发生这种情况时，所有 Reserve 插件的 Unreserve 方法将按照 Reserve 方法调用的相反顺序执行。 这个阶段的存在是为了清理与保留的 Pod 相关的状态。</p><h3 id=permit>Permit</h3><p>这是 scheduling cycle 的最后一个扩展点了，可以阻止或延迟将一个 pod binding 到 node。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PermitPlugin is an interface that must be implemented by &#34;Permit&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins are called before a pod is bound to a node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PermitPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Permit is called before binding a pod (and before prebind plugins). Permit
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// plugins are used to prevent or delay the binding of a Pod. A permit plugin
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// must return success or wait with timeout duration, or the pod will be rejected.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// The pod will also be rejected if the wait timeout or the pod is rejected while
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// waiting. Note that if the plugin returns &#34;wait&#34;, the framework will wait only
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// after running the remaining plugins given that no other plugin rejects the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Permit</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>) (<span style=color:#ff79c6>*</span>Status, time.Duration)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>三种结果：</p><ol><li>approve：所有 Permit plugins 都 appove 之后，这个 pod 就进入下面的 binding 阶段；</li><li>deny：任何一个 Permit plugin 拒绝后，就无法进入 binding 阶段，这会触发 Reserve plugins 的 Unreserve() 方法；</li><li>wait (with a timeout)：如果一个 Permit 插件返回 “wait”，则 Pod 将保持在一个内部的 “waiting” 的 Pod 列表，同时该 Pod 的绑定周期启动时即直接阻塞直到得到批准。如果超时发生，等待变成拒绝，并且 Pod 将返回调度队列，触发 Reserve plugins 的 Unreserve() 方法。</li></ol><h2 id=绑定阶段binding-cycle>绑定阶段（binding cycle）</h2><p>该类型扩展点有三个扩展点：preBind、bind 和 postBind。</p><p>preBind 扩展点有一个内置插件 VolumeBinding，这个插件会调用 pv controller 完成绑定操作，在前面的 reserve 也有同名插件，这个插件只是更新了本地缓存中的信息，没有实际做绑定。</p><p>bind 扩展点也只有一个默认的内置插件：DefaultBinder 将 Pod.Spec.nodeName 更新为选出来的那个 node，kubelet 监听到了 nodeName=Kubelet所在nodename，然后开始创建Pod（容器）。</p><h3 id=prebind>PreBind</h3><p>在将 pod 调度到一个 node 之前，先给这个 pod 在那台 node 上挂载一个 network volume。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PreBindPlugin is an interface that must be implemented by &#34;PreBind&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins are called before a pod being scheduled.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PreBindPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// PreBind is called before binding a pod. All prebind plugins must return
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// success or the pod will be rejected and won&#39;t be sent for binding.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PreBind</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>任何一个 PreBind plugin 失败，都会导致 pod 被拒绝，进入到 reserve plugins 的 Unreserve() 方法；</li></ul><h3 id=bind>Bind</h3><p>所有 PreBind 完成之后才会进入 Bind。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Bind plugins are used to bind a pod to a Node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> BindPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Bind plugins will not be called until all pre-bind plugins have completed. Each
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// bind plugin is called in the configured order. A bind plugin may choose whether
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// or not to handle the given Pod. If a bind plugin chooses to handle a Pod, the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// remaining bind plugins are skipped. When a bind plugin does not handle a pod,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// it must return Skip in its Status code. If a bind plugin returns an Error, the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// pod is rejected and will not be bound.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>Bind</span>(ctx , state <span style=color:#ff79c6>*</span>CycleState, p <span style=color:#ff79c6>*</span>v1.Pod, nodeName <span style=color:#8be9fd>string</span>) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>所有 plugin 按配置顺序依次执行；</li><li>每个 plugin 可以选择是否要处理一个给定的 pod；如果选择处理，后面剩下的 plugins 会跳过，也就是最多只有一个 bind plugin 会执行；</li></ul><h3 id=postbind>PostBind</h3><p>这是一个无法影响调度决策（没有返回值）。</p><ul><li>bind 成功的 pod 才会进入这个阶段；</li><li>作为 binding cycle 的最后一个阶段，一般是用来清理一些相关资源，如自身调度的中间态数据如缓存、状态等；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PostBindPlugin is an interface that must be implemented by &#34;PostBind&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins are called after a pod is successfully bound to a node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PostBindPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// PostBind is called after a pod is successfully bound. These plugins are informational.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// A common application of this extension point is for cleaning
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// up. If a plugin needs to clean-up its state after a pod is scheduled and
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// bound, PostBind is the extension point that it should register.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#50fa7b>PostBind</span>(ctx , state <span style=color:#ff79c6>*</span>Cycle
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><ul class=pager><li class=previous><a href=/post/2023-12-09-ebpf-share/ data-toggle=tooltip data-placement=top title="eBPF 探索 Linux 可观测性、网络、安全、性能">&larr;
Previous Post</a></li><li class=next><a href=/post/2024-04-07-scheduler-framework-02/ data-toggle=tooltip data-placement=top title="深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2024</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>