<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="Caretta 利用 eBPF 实现 Kubernetes 应用网络拓扑图"><meta property="og:title" content="Caretta 利用 eBPF 实现 Kubernetes 应用网络拓扑图"><meta property="twitter:title" content="Caretta 利用 eBPF 实现 Kubernetes 应用网络拓扑图"><meta name=description content="Caretta 是一种轻量级的独立工具，快速展示集群中运行的服务可视化网络图。"><meta property="og:description" content="Caretta 是一种轻量级的独立工具，快速展示集群中运行的服务可视化网络图。"><meta property="twitter:description" content="Caretta 是一种轻量级的独立工具，快速展示集群中运行的服务可视化网络图。"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>Caretta 利用 eBPF 实现 Kubernetes 应用网络拓扑图 | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2023-06-25-caretta-ebpf/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/ebpf title=eBPF>eBPF</a>
<a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a></div><h1>Caretta 利用 eBPF 实现 Kubernetes 应用网络拓扑图</h1><h2 class=subheading>eBPF 探测 Kubernetes 网络的世界</h2><span class=meta>Posted by
陈谭军
on
Sunday, June 25, 2023
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2023-06-25-caretta-ebpf/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 2641 字</span>，阅读约 <span class=more-meta>6 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=前言>前言</h1><p>为啥 eBPF 卸载之后，使用 bpftool 还能看到相关 map、prog 等？具体可以参考<a href=https://arthurchiao.art/blog/lifetime-of-bpf-objects-zh>文章</a>。</p><h1 id=介绍>介绍</h1><p>Caretta 是一种轻量级的独立工具，快速展示集群中运行的服务可视化网络图。
Caretta 利用 eBPF 有效地展示 K8s 集群中的服务网络交互图，并利用 Grafana 查询和可视化收集的数据。
科学家们早就知道，海龟和许多动物一样，通过感应磁场中看不见的线在海上航行，类似于水手使用纬度和经度的方式。
<img src=/images/2023-06-25-caretta-ebpf/1.png alt></p><h1 id=说明>说明</h1><p>内核允许使用 eBPF 的开发人员将他们的程序附加到各种类型的探测器 - 放置在内核或应用程序的代码中，当到达时，将在执行其原始代码之前或之后运行附加到它们的程序。Caretta 利用 eBPF 获取网络数据，通过 Prometheus 汇聚数据，并且通过 grafana 大盘展示。Caretta 是基于 tcplife 的启发，它是一个使用 eBPF 计算 TCP 生命周期统计数据和信息的好工具。</p><pre tabindex=0><code>&#34;tcplife&#34; 插件可以用于监视和分析 TCP 连接的各个阶段和事件，比如连接建立、数据传输、连接关闭等。
它可以捕获和记录关于 TCP 连接的相关信息，如连接持续时间、数据包统计、延迟等，并提供一些有用的指标和分析结果。
这对于网络故障排除、性能优化以及网络安全分析等方面都很有用。关键词：tcp_set_state、tcp_data_queue 等。
</code></pre><p>为什么使用 tcp_data_queue 函数？
探测 tcp_data_queue 以观察网络套接字在其已建立状态下更新其统计信息，并探测 tcp_set_state 以跟踪其生命周期。使用此函数的优点是 tcp_set_state 和大多数内核 TCP 函数一样，它的第一个参数是一个 struct sock 对象。<strong>具有轻量级、高效性、简单化、可视化等显著特点</strong>。</p><h1 id=原理>原理</h1><p>有一个 Grafana 实例查询 VictoriaMetrics (caretta-vm) 代理（并在其 Web UI 上显示此地图）；Victoria agent 从 caretta daemonset 中抓取指标；Victoria 代理和 Caretta 都使用了 Kubernetes 服务公开的 kubernetes API；
<img src=/images/2023-06-25-caretta-ebpf/9.png alt></p><p>下面是 Caretta Agent 发布的时间序列指标示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>caretta_links_observed<span style=color:#ff79c6>{</span><span style=color:#8be9fd;font-style:italic>client_id</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;1074587981&#34;</span>,client_kind<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;Deployment&#34;</span>,client_name<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;checkoutservice&#34;</span>,client_namespace<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;demo-ng&#34;</span>,link_id<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;198768460&#34;</span>,role<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;1&#34;</span>,server_id<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;1112713827&#34;</span>,server_kind<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;Service&#34;</span>,server_name<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;productcatalogservice&#34;</span>,server_namespace<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;demo-ng&#34;</span>,server_port<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;3550&#34;</span><span style=color:#ff79c6>}</span> <span style=color:#bd93f9>2537</span>
</span></span></code></pre></div><p>在此连接中，我们可以看到 checkoutservice 向名为 productcatalogservice 的服务发送 2537 个字节。请注意，某些标签的生成全符合 Grafana 期望显示节点图的格式。</p><h1 id=案例>案例</h1><h2 id=前提条件>前提条件</h2><ol><li>Linux 内核版本 >= 4.16</li><li>支持 CO-RE。可见 CORE，(Compile Once – Run Everywhere)</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Couldn&#39;t load probes - error loading BPF objects from go-side. field HandleSockSetState: program handle_sock_set_state: apply CO-RE relocations: load kernel spec: no BTF found <span style=color:#ff79c6>for</span> kernel version 3.10.0-1160.83.1.el7.x86_64: not supported
</span></span></code></pre></div><h2 id=部署应用>部署应用</h2><p><img src=/images/2023-06-25-caretta-ebpf/11.png alt></p><p>部署 Caretta 组件
<img src=/images/2023-06-25-caretta-ebpf/2.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm repo add groundcover https://helm.groundcover.com/
</span></span><span style=display:flex><span>helm repo update
</span></span><span style=display:flex><span>helm install caretta --namespace caretta --create-namespace groundcover/caretta
</span></span></code></pre></div><h2 id=caretta-常见指标>Caretta 常见指标</h2><p>Caretta 的 helm chart 使用 Caretta 自带的数据发布了一个带有预定义仪表板的 Grafana 实例。此仪表板包含一些示例来演示 Caretta 指标的用法，使用提供的 Grafana 实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl port-forward --namespace caretta &lt;grafana-pod-name&gt; 3000:3000
</span></span></code></pre></div><p>Caretta 的主要指标是 caretta_links_observed (Gauge)。 它使用以下标签来表示通过集群的特定连接（网络套接字）：</p><ul><li>client_name - kubernetes 实体的名称（如果已解析）、外部域（如果已解析）或 IP 地址。</li><li>client_namespace - kubernetes 实体的命名空间，或“节点”，或“外部”。</li><li>client_kind - kubernetes 实体的种类，或“节点”，或“外部”。</li><li>server_name - kubernetes 实体的名称（如果已解析）、外部域（如果已解析）或 IP 地址。</li><li>server_namespace - kubernetes 实体的命名空间，或“节点”，或“外部”。</li><li>server_kind - kubernetes 实体的种类，或“节点”，或“外部”。</li><li>server_port - 服务器使用的端口。</li><li>role - 1（客户端）或 2（服务器）。</li></ul><p>k8s 应用网络拓扑图如下所示：
<img src=/images/2023-06-25-caretta-ebpf/5.png alt>
<img src=/images/2023-06-25-caretta-ebpf/6.png alt>
<img src=/images/2023-06-25-caretta-ebpf/7.png alt>
<img src=/images/2023-06-25-caretta-ebpf/8.png alt></p><p>除了以上标签，Caretta 还为 Grafana 的节点图面板使用了其他标签，将输出在过去 15 分钟内在某些客户端和某些服务器之间观察到的吞吐量，按端口聚合。</p><pre tabindex=0><code>((sum (server_port) (caretta_links_observed{client_name=&#34;some-client&#34;, server_name=&#34;some-server}))[15m])
</code></pre><p>按 (server_name) (rate(caretta_links_observed{client_name=&ldquo;some-client&rdquo;})) 求和将输出从某些客户端到与之通信的服务器的流量速率，按服务器名称汇总。</p><pre tabindex=0><code>sort_desc(增加(((sum by (client_name)(caretta_links_observed{server_namespace=&#34;external&#34;}))[5m]))
</code></pre><p>将按客户端名称向外部服务器输出通信，降序排列。</p><h2 id=删除-caretta-组件>删除 Caretta 组件</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm delete caretta --namespace caretta
</span></span></code></pre></div><h1 id=源码>源码</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>➜  caretta git:<span style=color:#ff79c6>(</span>main<span style=color:#ff79c6>)</span> ✗ tree -L <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>├── CODE_OF_CONDUCT.md
</span></span><span style=display:flex><span>├── Dockerfile
</span></span><span style=display:flex><span>├── LICENSE
</span></span><span style=display:flex><span>├── Makefile
</span></span><span style=display:flex><span>├── README.md
</span></span><span style=display:flex><span>├── chart
</span></span><span style=display:flex><span>├── cmd
</span></span><span style=display:flex><span>├── go.mod
</span></span><span style=display:flex><span>├── go.sum
</span></span><span style=display:flex><span>├── images
</span></span><span style=display:flex><span>├── pkg
</span></span><span style=display:flex><span>└── scripts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>caretta git:<span style=color:#ff79c6>(</span>main<span style=color:#ff79c6>)</span> ✗ tree -L <span style=color:#bd93f9>2</span> pkg
</span></span><span style=display:flex><span>pkg
</span></span><span style=display:flex><span>├── caretta
</span></span><span style=display:flex><span>│   ├── caretta.go
</span></span><span style=display:flex><span>│   ├── config.go
</span></span><span style=display:flex><span>│   ├── ebpf_map.go
</span></span><span style=display:flex><span>│   ├── links_tracer.go
</span></span><span style=display:flex><span>│   ├── links_tracer_test.go
</span></span><span style=display:flex><span>│   └── types.go
</span></span><span style=display:flex><span>├── k8s
</span></span><span style=display:flex><span>│   ├── ipresolver.go
</span></span><span style=display:flex><span>│   └── ipresolver_test.go
</span></span><span style=display:flex><span>├── metrics
</span></span><span style=display:flex><span>│   └── prometheus.go
</span></span><span style=display:flex><span>└── tracing
</span></span><span style=display:flex><span>    ├── ebpf
</span></span><span style=display:flex><span>    └── probes.go
</span></span></code></pre></div><p>整体逻辑如下所示：
<img src=/images/2023-06-25-caretta-ebpf/10.png alt></p><p>C 语言核心代码逻辑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;core_structures.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;arm_support.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf_core_read.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf_helpers.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf_tracing.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;ebpf_utils.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;epbf_shared_types.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;ebpf_internel_types.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>char</span> __license[] SEC(<span style=color:#f1fa8c>&#34;license&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Dual MIT/GPL&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// internal kernel-only map to hold state for each sock observed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span> bpf_map_def <span style=color:#50fa7b>SEC</span>(<span style=color:#f1fa8c>&#34;maps&#34;</span>) sock_infos <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    .type <span style=color:#ff79c6>=</span> BPF_MAP_TYPE_HASH,
</span></span><span style=display:flex><span>    .key_size <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>),
</span></span><span style=display:flex><span>    .value_size <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sock_info),
</span></span><span style=display:flex><span>    .max_entries <span style=color:#ff79c6>=</span> MAX_CONNECTIONS,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// the main product of the tracing - map containing all connections observed,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// with metadata and throughput stats.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// key is a whole identifier struct and not a single id to split the constant
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// and dynamic values and to resemble as closely as possible the end result in
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// the userspace code.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span> bpf_map_def <span style=color:#50fa7b>SEC</span>(<span style=color:#f1fa8c>&#34;maps&#34;</span>) connections <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    .type <span style=color:#ff79c6>=</span> BPF_MAP_TYPE_HASH,
</span></span><span style=display:flex><span>    .key_size <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> connection_identifier),
</span></span><span style=display:flex><span>    .value_size <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> connection_throughput_stats),
</span></span><span style=display:flex><span>    .max_entries <span style=color:#ff79c6>=</span> MAX_CONNECTIONS,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// helper to convert short int from BE to LE
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> u16 <span style=color:#50fa7b>be_to_le</span>(__be16 be) { <span style=color:#ff79c6>return</span> (be <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>8</span>) <span style=color:#ff79c6>|</span> (be <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#bd93f9>8</span>); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> u32 <span style=color:#50fa7b>get_unique_id</span>() {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> bpf_ktime_get_ns() <span style=color:#ff79c6>%</span> __UINT32_MAX__; <span style=color:#6272a4>// no reason to use 64 bit for this
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// function for parsing the struct sock
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>parse_sock_data</span>(<span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>sock, <span style=color:#ff79c6>struct</span> connection_tuple <span style=color:#ff79c6>*</span>out_tuple,
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>struct</span> connection_throughput_stats <span style=color:#ff79c6>*</span>out_throughput) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (sock <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// struct sock wraps struct tcp_sock and struct inet_sock as its first member
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>struct</span> tcp_sock <span style=color:#ff79c6>*</span>tcp <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> tcp_sock <span style=color:#ff79c6>*</span>)sock;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> inet_sock <span style=color:#ff79c6>*</span>inet <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> inet_sock <span style=color:#ff79c6>*</span>)sock;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// initialize variables. IP addresses and ports are read originally
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// big-endian, and we will convert the ports to little-endian.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  __be16 src_port_be <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>  __be16 dst_port_be <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// read connection tuple
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>out_tuple<span style=color:#ff79c6>-&gt;</span>src_ip, <span style=color:#ff79c6>sizeof</span>(out_tuple<span style=color:#ff79c6>-&gt;</span>src_ip),
</span></span><span style=display:flex><span>                      <span style=color:#ff79c6>&amp;</span>inet<span style=color:#ff79c6>-&gt;</span>inet_saddr)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>out_tuple<span style=color:#ff79c6>-&gt;</span>dst_ip, <span style=color:#ff79c6>sizeof</span>(out_tuple<span style=color:#ff79c6>-&gt;</span>dst_ip),
</span></span><span style=display:flex><span>                      <span style=color:#ff79c6>&amp;</span>inet<span style=color:#ff79c6>-&gt;</span>inet_daddr)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>src_port_be, <span style=color:#ff79c6>sizeof</span>(src_port_be), <span style=color:#ff79c6>&amp;</span>inet<span style=color:#ff79c6>-&gt;</span>inet_sport)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  out_tuple<span style=color:#ff79c6>-&gt;</span>src_port <span style=color:#ff79c6>=</span> be_to_le(src_port_be);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>dst_port_be, <span style=color:#ff79c6>sizeof</span>(dst_port_be), <span style=color:#ff79c6>&amp;</span>inet<span style=color:#ff79c6>-&gt;</span>inet_dport)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  out_tuple<span style=color:#ff79c6>-&gt;</span>dst_port <span style=color:#ff79c6>=</span> be_to_le(dst_port_be);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// read throughput data
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>out_throughput<span style=color:#ff79c6>-&gt;</span>bytes_received,
</span></span><span style=display:flex><span>                      <span style=color:#ff79c6>sizeof</span>(out_throughput<span style=color:#ff79c6>-&gt;</span>bytes_received),
</span></span><span style=display:flex><span>                      <span style=color:#ff79c6>&amp;</span>tcp<span style=color:#ff79c6>-&gt;</span>bytes_received)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>out_throughput<span style=color:#ff79c6>-&gt;</span>bytes_sent,
</span></span><span style=display:flex><span>                      <span style=color:#ff79c6>sizeof</span>(out_throughput<span style=color:#ff79c6>-&gt;</span>bytes_sent), <span style=color:#ff79c6>&amp;</span>tcp<span style=color:#ff79c6>-&gt;</span>bytes_sent)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>enum</span> connection_role <span style=color:#50fa7b>get_sock_role</span>(<span style=color:#ff79c6>struct</span> sock<span style=color:#ff79c6>*</span> sock) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// the max_ack_backlog holds the limit for the accept queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// if it is a server, it will not be 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd>int</span> max_ack_backlog <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#bd93f9>0</span> <span style=color:#ff79c6>!=</span> bpf_core_read(<span style=color:#ff79c6>&amp;</span>max_ack_backlog, <span style=color:#ff79c6>sizeof</span>(max_ack_backlog),
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>&amp;</span>sock<span style=color:#ff79c6>-&gt;</span>sk_max_ack_backlog)) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> CONNECTION_ROLE_UNKNOWN;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> max_ack_backlog <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>CONNECTION_ROLE_CLIENT</span> : CONNECTION_ROLE_SERVER;      
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// probing the tcp_data_queue kernel function, and adding the connection
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// observed to the map.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>SEC(<span style=color:#f1fa8c>&#34;kprobe/tcp_data_queue&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> handle_tcp_data_queue(<span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>ctx) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// first argument to tcp_data_queue is a struct sock*
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>sock <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>)PT_REGS_PARM1(ctx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> connection_identifier conn_id <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> connection_throughput_stats throughput <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (parse_sock_data(sock, <span style=color:#ff79c6>&amp;</span>conn_id.tuple, <span style=color:#ff79c6>&amp;</span>throughput) <span style=color:#ff79c6>==</span> BPF_ERROR) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// skip unconnected sockets
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> (conn_id.tuple.dst_port <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> conn_id.tuple.dst_ip <span style=color:#ff79c6>==</span> BPF_SUCCESS) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// fill the conn_id extra details from sock_info map entry, or create one
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>struct</span> sock_info <span style=color:#ff79c6>*</span>sock_info <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock);
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (sock_info <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// first time we encounter this sock
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// check if server or client and insert to the maps
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>enum</span> connection_role role <span style=color:#ff79c6>=</span> get_sock_role(sock);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> sock_info info <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        .pid <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>, <span style=color:#6272a4>// can&#39;t associate to pid anyway
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        .role <span style=color:#ff79c6>=</span> role,
</span></span><span style=display:flex><span>        .is_active <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>,
</span></span><span style=display:flex><span>        .id <span style=color:#ff79c6>=</span> get_unique_id(),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock, <span style=color:#ff79c6>&amp;</span>info, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    conn_id.pid <span style=color:#ff79c6>=</span> info.pid;
</span></span><span style=display:flex><span>    conn_id.id <span style=color:#ff79c6>=</span> info.id;
</span></span><span style=display:flex><span>    conn_id.role <span style=color:#ff79c6>=</span> info.role;
</span></span><span style=display:flex><span>    throughput.is_active <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>connections, <span style=color:#ff79c6>&amp;</span>conn_id, <span style=color:#ff79c6>&amp;</span>throughput, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>  } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  conn_id.pid <span style=color:#ff79c6>=</span> sock_info<span style=color:#ff79c6>-&gt;</span>pid;
</span></span><span style=display:flex><span>  conn_id.id <span style=color:#ff79c6>=</span> sock_info<span style=color:#ff79c6>-&gt;</span>id;
</span></span><span style=display:flex><span>  conn_id.role <span style=color:#ff79c6>=</span> sock_info<span style=color:#ff79c6>-&gt;</span>role;
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>sock_info<span style=color:#ff79c6>-&gt;</span>is_active) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  throughput.is_active <span style=color:#ff79c6>=</span> sock_info<span style=color:#ff79c6>-&gt;</span>is_active; 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>connections, <span style=color:#ff79c6>&amp;</span>conn_id, <span style=color:#ff79c6>&amp;</span>throughput, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>handle_set_tcp_syn_sent</span>(<span style=color:#ff79c6>struct</span> sock<span style=color:#ff79c6>*</span> sock) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// start of a client session
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  u32 pid <span style=color:#ff79c6>=</span> bpf_get_current_pid_tgid() <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> sock_info info <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>      .pid <span style=color:#ff79c6>=</span> pid,
</span></span><span style=display:flex><span>      .role <span style=color:#ff79c6>=</span> CONNECTION_ROLE_CLIENT,
</span></span><span style=display:flex><span>      .is_active <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>,
</span></span><span style=display:flex><span>      .id <span style=color:#ff79c6>=</span> get_unique_id(),
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock, <span style=color:#ff79c6>&amp;</span>info, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>handle_set_tcp_syn_recv</span>(<span style=color:#ff79c6>struct</span> sock<span style=color:#ff79c6>*</span> sock) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// this is a server getting syn after listen
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>struct</span> connection_identifier conn_id <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> connection_throughput_stats throughput <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (parse_sock_data(sock, <span style=color:#ff79c6>&amp;</span>conn_id.tuple, <span style=color:#ff79c6>&amp;</span>throughput) <span style=color:#ff79c6>==</span> BPF_ERROR) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> sock_info info <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        .pid <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>, <span style=color:#6272a4>// can&#39;t associate to process
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        .role <span style=color:#ff79c6>=</span> CONNECTION_ROLE_SERVER,
</span></span><span style=display:flex><span>        .is_active <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>,
</span></span><span style=display:flex><span>        .id <span style=color:#ff79c6>=</span> get_unique_id(),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock, <span style=color:#ff79c6>&amp;</span>info, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// probably the dst ip will still be unitialized
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (conn_id.tuple.dst_ip <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    conn_id.pid <span style=color:#ff79c6>=</span> info.pid;
</span></span><span style=display:flex><span>    conn_id.id <span style=color:#ff79c6>=</span> info.id;
</span></span><span style=display:flex><span>    conn_id.role <span style=color:#ff79c6>=</span> info.role;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>connections, <span style=color:#ff79c6>&amp;</span>conn_id, <span style=color:#ff79c6>&amp;</span>throughput, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#ff79c6>inline</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>handle_set_tcp_close</span>(<span style=color:#ff79c6>struct</span> sock<span style=color:#ff79c6>*</span> sock) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// mark as inactive
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>struct</span> connection_identifier conn_id <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> connection_throughput_stats throughput <span style=color:#ff79c6>=</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (parse_sock_data(sock, <span style=color:#ff79c6>&amp;</span>conn_id.tuple, <span style=color:#ff79c6>&amp;</span>throughput) <span style=color:#ff79c6>==</span> BPF_ERROR) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> BPF_ERROR;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> sock_info <span style=color:#ff79c6>*</span>info <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock);
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (info <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    conn_id.id <span style=color:#ff79c6>=</span> get_unique_id();
</span></span><span style=display:flex><span>    conn_id.pid <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; <span style=color:#6272a4>// cannot associate to PID in this state
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    conn_id.role <span style=color:#ff79c6>=</span> get_sock_role(sock);
</span></span><span style=display:flex><span>  } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    conn_id.id <span style=color:#ff79c6>=</span> info<span style=color:#ff79c6>-&gt;</span>id;
</span></span><span style=display:flex><span>    conn_id.pid <span style=color:#ff79c6>=</span> info<span style=color:#ff79c6>-&gt;</span>pid;
</span></span><span style=display:flex><span>    conn_id.role <span style=color:#ff79c6>=</span> info<span style=color:#ff79c6>-&gt;</span>role;
</span></span><span style=display:flex><span>    bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>sock_infos, <span style=color:#ff79c6>&amp;</span>sock);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  throughput.is_active <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>false</span>;
</span></span><span style=display:flex><span>  bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>connections, <span style=color:#ff79c6>&amp;</span>conn_id, <span style=color:#ff79c6>&amp;</span>throughput, BPF_ANY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;tracepoint/sock/inet_sock_set_state&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> handle_sock_set_state(<span style=color:#ff79c6>struct</span> set_state_args <span style=color:#ff79c6>*</span>args) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>sock <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> sock <span style=color:#ff79c6>*</span>)args<span style=color:#ff79c6>-&gt;</span>skaddr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>switch</span>(args<span style=color:#ff79c6>-&gt;</span>newstate) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>TCP_SYN_RECV</span>: {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> handle_set_tcp_syn_recv(sock) <span style=color:#ff79c6>==</span> BPF_ERROR;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>TCP_SYN_SENT</span>: {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> handle_set_tcp_syn_sent(sock) <span style=color:#ff79c6>==</span> BPF_ERROR;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>TCP_CLOSE</span>:  {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> handle_set_tcp_close(sock);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> BPF_SUCCESS;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 Go 加载 ebpf 代码步骤：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>LoadProbes</span>() (Probes, <span style=color:#ff79c6>*</span>ebpf.Map, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> rlimit.<span style=color:#50fa7b>RemoveMemlock</span>(); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> Probes{}, <span style=color:#ff79c6>nil</span>, fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;error removing memory lock - %v&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	objs <span style=color:#ff79c6>:=</span> bpfObjects{}
</span></span><span style=display:flex><span>	err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>loadBpfObjects</span>(<span style=color:#ff79c6>&amp;</span>objs, <span style=color:#ff79c6>&amp;</span>ebpf.CollectionOptions{})
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>var</span> ve <span style=color:#ff79c6>*</span>ebpf.VerifierError
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> errors.<span style=color:#50fa7b>As</span>(err, <span style=color:#ff79c6>&amp;</span>ve) {
</span></span><span style=display:flex><span>			fmt.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;Verifier Error: %+v\n&#34;</span>, ve)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> Probes{}, <span style=color:#ff79c6>nil</span>, fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;error loading BPF objects from go-side. %v&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	log.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;BPF objects loaded&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// attach a kprobe and tracepoint
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	kp, err <span style=color:#ff79c6>:=</span> link.<span style=color:#50fa7b>Kprobe</span>(<span style=color:#f1fa8c>&#34;tcp_data_queue&#34;</span>, objs.bpfPrograms.HandleTcpDataQueue, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> Probes{}, <span style=color:#ff79c6>nil</span>, fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;error attaching kprobe: %v&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	log.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;Kprobe attached successfully&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	tp, err <span style=color:#ff79c6>:=</span> link.<span style=color:#50fa7b>Tracepoint</span>(<span style=color:#f1fa8c>&#34;sock&#34;</span>, <span style=color:#f1fa8c>&#34;inet_sock_set_state&#34;</span>, objs.bpfPrograms.HandleSockSetState, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> Probes{}, <span style=color:#ff79c6>nil</span>, fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;error attaching tracepoint: %v&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	log.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;Tracepoint attached successfully&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// We are done with loading kprobes - clear the btf cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	btf.<span style=color:#50fa7b>FlushKernelSpec</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> Probes{
</span></span><span style=display:flex><span>		Kprobe:     kp,
</span></span><span style=display:flex><span>		Tracepoint: tp,
</span></span><span style=display:flex><span>		BpfObjs:    objs,
</span></span><span style=display:flex><span>	}, objs.Connections, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解析工作负载 trace 链路拓扑图：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#6272a4>// a single polling from the eBPF maps
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// iterating the traces from the kernel-space, summing each network link
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (tracer <span style=color:#ff79c6>*</span>LinksTracer) <span style=color:#50fa7b>TracesPollingIteration</span>(pastLinks <span style=color:#8be9fd;font-style:italic>map</span>[NetworkLink]<span style=color:#8be9fd>uint64</span>) (<span style=color:#8be9fd;font-style:italic>map</span>[NetworkLink]<span style=color:#8be9fd>uint64</span>, <span style=color:#8be9fd;font-style:italic>map</span>[NetworkLink]<span style=color:#8be9fd>uint64</span>) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// outline of an iteration -
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// filter unwanted connections, sum all connections as links, add past links, and return the new map
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	pollsMade.<span style=color:#50fa7b>Inc</span>()
</span></span><span style=display:flex><span>	unroledCounter <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>	loopbackCounter <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	currentLinks <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>map</span>[NetworkLink]<span style=color:#8be9fd>uint64</span>)
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> connectionsToDelete []ConnectionIdentifier
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> conn ConnectionIdentifier
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> throughput ConnectionThroughputStats
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	entries <span style=color:#ff79c6>:=</span> tracer.connections.<span style=color:#50fa7b>Iterate</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// iterate the map from the eBPF program
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	itemsCounter <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> entries.<span style=color:#50fa7b>Next</span>(<span style=color:#ff79c6>&amp;</span>conn, <span style=color:#ff79c6>&amp;</span>throughput) {
</span></span><span style=display:flex><span>		itemsCounter <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// filter unnecessary connection
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> throughput.IsActive <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			connectionsToDelete = <span style=color:#8be9fd;font-style:italic>append</span>(connectionsToDelete, conn)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// skip loopback connections
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> conn.Tuple.SrcIp <span style=color:#ff79c6>==</span> conn.Tuple.DstIp <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>isAddressLoopback</span>(conn.Tuple.DstIp) {
</span></span><span style=display:flex><span>			loopbackCounter<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// filter unroled connections (probably indicates a bug)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		link, err <span style=color:#ff79c6>:=</span> tracer.<span style=color:#50fa7b>reduceConnectionToLink</span>(conn)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> conn.Role <span style=color:#ff79c6>==</span> UnknownConnectionRole <span style=color:#ff79c6>||</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			unroledCounter<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		currentLinks[link] <span style=color:#ff79c6>+=</span> throughput.BytesSent
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	mapSize.<span style=color:#50fa7b>Set</span>(<span style=color:#8be9fd;font-style:italic>float64</span>(itemsCounter))
</span></span><span style=display:flex><span>	unRoledConnections.<span style=color:#50fa7b>Set</span>(<span style=color:#8be9fd;font-style:italic>float64</span>(unroledCounter))
</span></span><span style=display:flex><span>	filteredLoopbackConnections.<span style=color:#50fa7b>Set</span>(<span style=color:#8be9fd;font-style:italic>float64</span>(loopbackCounter))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// add past links
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> pastLink, pastThroughput <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> pastLinks {
</span></span><span style=display:flex><span>		currentLinks[pastLink] <span style=color:#ff79c6>+=</span> pastThroughput
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// delete connections marked to delete
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> _, conn <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> connectionsToDelete {
</span></span><span style=display:flex><span>		tracer.<span style=color:#50fa7b>deleteAndStoreConnection</span>(<span style=color:#ff79c6>&amp;</span>conn, pastLinks)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> pastLinks, currentLinks
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=参考>参考</h1><ol><li><a href=https://www.groundcover.com/blog/caretta>https://www.groundcover.com/blog/caretta</a></li><li><a href=https://github.com/groundcover-com/caretta>https://github.com/groundcover-com/caretta</a></li></ol><hr><ul class=pager><li class=previous><a href=/post/2023-05-01-cilium-learn/ data-toggle=tooltip data-placement=top title="深入理解 Cilium 核心原理">&larr;
Previous Post</a></li><li class=next><a href=/post/2023-08-12-cilium-mesh-example-copy/ data-toggle=tooltip data-placement=top title="Cilium Mesh 常见场景与示例">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2023</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>