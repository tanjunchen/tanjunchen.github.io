<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="监测 Linux 内核内存 OOM 事件"><meta property="og:title" content="监测 Linux 内核内存 OOM 事件"><meta property="twitter:title" content="监测 Linux 内核内存 OOM 事件"><meta name=description content="监测 Linux 内核内存 OOM 事件"><meta property="og:description" content="监测 Linux 内核内存 OOM 事件"><meta property="twitter:description" content="监测 Linux 内核内存 OOM 事件"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>监测 Linux 内核内存 OOM 事件 | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2024-05-01-linux-oom/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a>
<a class=tag href=/tags/ebpf title=eBPF>eBPF</a></div><h1>监测 Linux 内核内存 OOM 事件</h1><h2 class=subheading>监测 Linux 内核内存 OOM 事件</h2><span class=meta>Posted by
陈谭军
on
Wednesday, May 1, 2024
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2024-05-01-linux-oom/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 4383 字</span>，阅读约 <span class=more-meta>9 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=内存-oom>内存 OOM</h1><p>Linux内核有个机制叫OOMkiller（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。典型的情况是：某天一台机器突然ssh远程登录不了，但能ping通，说明不是网络的故障，原因是sshd进程被OOM killer杀掉了（多次遇到这样的假死状况）。重启机器后查看系统日志 /var/log/messages 会发现 Out of Memory: Kill process 1865（sshd）类似的错误信息。</p><p>Linux 内核根据应用程序的要求分配内存，通常来说应用程序分配了内存但是并没有实际全部使用，为了提高性能，这部分没用的内存可以留作它用，这部分内存是属于每个进程的，内核直接回收利用的话比较麻烦，所以内核采用一种过度分配内存（over-commit memory）的办法来间接利用这部分 “空闲” 的内存，提高整体内存的使用效率。一般来说这样做没有问题，但当大多数应用程序都消耗完自己的内存的时候麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。</p><p>我们可以通过一些内核参数来调整 OOM killer 的行为，避免系统在那里不停的杀进程。</p><ul><li>Linux下每个进程都有个OOM权重，在/proc//oom_adj里面，取值是-17到+15，取值越高，越容易被干掉；</li><li>linux内核会通过特定的算法给每个进程计算一个分数来决定杀哪个进程，每个进程的oom分数可以/proc/PID/oom_score中找到（分数越高，越容易被干掉）；</li><li>我们可以通过调控每个进程的/proc//oom_adj来影响到每个进程的/proc/PID/oom_score；（正比例关系，oom_adj越大，oom_score分数越高，越容易被干掉）；</li></ul><h1 id=何时触发-oom-killer-机制>何时触发 OOM killer 机制</h1><p>Linux下允许程序申请比系统可用内存更多的内存，这个特性叫Overcommit。这样做是出于优化系统考虑，因为不是所有的程序申请了内存就立刻使用的，当你使用的时候说不定系统已经回收了一些资源。
不幸的是，当你用到这个 Overcommit 给你的内存的时候，系统还没有资源的话，OOM killer就跳出来了。参数 /proc/sys/vm/overcommit_memory 可以控制进程对内存过量使用的应对策略。</p><ul><li>当overcommit_memory=0 允许进程轻微过量使用内存，但对于大量过载请求则不允许，也就是当内存消耗过大就是触发OOM killer。</li><li>当overcommit_memory=1 永远允许进程overcommit，不会触发OOM killer。</li><li>当overcommit_memory=2 永远禁止overcommit，不会触发OOM killer。</li></ul><p>内核在触发OOM机制时会调用到out_of_memory()函数，此函数的调用顺序以下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>_alloc_pages  //内存分配时调用
</span></span><span style=display:flex><span>    |--&gt;__alloc_pages_nodemask
</span></span><span style=display:flex><span>       |--&gt; __alloc_pages_slowpath
</span></span><span style=display:flex><span>           |--&gt; __alloc_pages_may_oom
</span></span><span style=display:flex><span>              | --&gt; out_of_memory   //触发
</span></span></code></pre></div><p>OOM Killer选择进程过程如下所示：</p><p>当系统内存分配失败时就会调用out_of_memory()函数，该函数中调用了select_bad_process()函数，select_bad_process()通过badness()函数获取目标进程对应的分数，而最终分数最高的进程会被OOM Killer清理，badness()函数内部有一套规则来选择目标进程：</p><ul><li>内核为自己保留运行所需最小内存并尝试回收大量的存；</li><li>优先剔除内存占用高的进程，尝试杀死最少数量的进程；</li><li>一些算法可以调整进程被终止的优先级；</li></ul><h1 id=oom-系统参数>OOM 系统参数</h1><ul><li>参数 /proc/sys/vm/overcommit_memory 可以控制进程对内存过量使用的应对策略。<ul><li>当overcommit_memory=0 允许进程轻微过量使用内存，但对于大量过载请求则不允许，也就是当内存消耗过大就是触发OOM killer。</li><li>当overcommit_memory=1 永远允许进程overcommit，不会触发OOM killer。</li><li>当overcommit_memory=2 永远禁止overcommit，不会触发OOM killer。</li></ul></li><li>参数 /proc/sys/vm/panic_on_oom 用来控制当内存不足时该如何做。<ul><li>值为0：内存不足时，启动 OOM killer。</li><li>值为1：内存不足时，有可能会触发 kernel panic（系统重启），也有可能启动 OOM killer。</li><li>值为2：内存不足时，表示强制触发 kernel panic，内核崩溃GG（系统重启）。</li></ul></li><li>参数 /proc/sys/vm/oom_kill_allocating_task 用来决定触发OOM时先杀掉哪种进程<ul><li>值为0：会 kill 掉得分最高的进程。</li><li>值为非0：会kill 掉当前申请内存而触发OOM的进程。</li><li>当然，一些系统进程（如init）或者被用户设置了oom_score_adj的进程等可不是说杀就杀的。</li></ul></li><li>参数 /proc/sys/vm/oom_dump_tasks 用来记录触发OOM时记录哪些日志。oom_dump_tasks参数可以记录进程标识信息、该进程使用的虚拟内存总量、物理内存、进程的页表信息等。值为0：关闭打印上述日志。在大型系统中，可能存在上千进程，逐一打印使用内存信息可能会造成性能问题。值为非0：有三种情况会打印进程内存使用情况。<ul><li>由 OOM 导致 kernel panic 时。</li><li>没有找到符合条件的进程 kill 时。</li><li>找到符合条件的进程并 kill 时。</li></ul></li><li>参数 oom_adj、oom_score_adj 和 oom_score 用来控制进程打分（分数越高，就先杀谁）。这三个参数的关联性比较紧密，都和具体的进程相关，位置都是在 /proc/进程PID/ 目录下。内核会对进程打分（oom_score），主要包括两部分，系统打分和用户打分。系统打分就是根据进程的物理内存消耗量（进程自身的空间、swap空间、页缓存空间）；用户打分就是 oom_score_adj 的值。如果用户指定 oom_score_adj 的值为 -1000，也就是表示禁止 OOM killer 杀死该进程。</li></ul><h1 id=内存-oom-原因>内存 OOM 原因</h1><p>内存溢出（OOM）通常是由以下几个原因引起的：</p><ul><li>内存使用超过了物理硬件限制：如果程序或系统尝试使用超过其物理内存的内存，就会发生内存溢出。</li><li>内存泄漏：内存泄漏是指程序中已经结束生命周期的对象却不能被垃圾回收机制回收的情况，从而导致这部分内存无法再次使用。随着时间的推移，内存泄漏可能会消耗掉所有可用的内存，从而导致OOM。</li><li>不适当的内存分配：有时，程序可能会错误地请求过多的内存，导致系统无法满足这种需求。例如，程序可能会尝试一次性分配超过系统可用内存的数组。</li><li>资源竞争：在集群环境中，如果多个进程或节点竞争同一内存资源，可能会导致内存不足。</li><li>缺乏有效的内存管理：在一些情况下，操作系统或应用程序的内存管理策略可能不够有效，导致内存的使用不够高效，从而引发OOM。</li></ul><h1 id=内存-oom-排查>内存 OOM 排查</h1><p>定位内存溢出（OOM）问题通常需要以下步骤：</p><ul><li>查看系统日志：系统日志通常是查找OOM问题的第一步。在Linux系统中，可以查看/var/log/messages(如果配置了syslog，日志可能在/var/log/syslog)或者使用dmesg命令来查看内核日志，这些日志中通常会记录OOM发生的时间和被杀死的进程。</li><li>分析进程的内存使用情况：可以使用top，ps，free等命令来实时查看进程的内存使用情况。特别是，top命令可以按内存使用量对进程排序，帮助我们找到消耗内存最多的进程。</li><li>使用调试工具：有一些工具可以帮助我们更详细地分析内存使用情况。例如，valgrind可以帮助我们检测内存泄漏，gdb可以让我们在运行时检查进程的内存使用情况。</li><li>审查代码：如果确定是某个进程导致的OOM，那么需要审查这个进程的代码，查找可能导致内存使用过多的部分。这可能包括查找内存泄漏，或者查找不必要的大内存分配。</li><li>使用性能分析工具：一些性能分析工具，如perf，gprof，JProfiler等，可以提供关于程序运行时内存使用情况的详细信息，帮助我们找到内存使用过多的代码部分。</li></ul><h1 id=ebpf-排查-oom>eBPF 排查 OOM</h1><p>oom的触发就是在内存无法分配的时候，选择一个最“差”的进程发送kill信号。oom_kill_process这个函数是主要入口，定义是static void oom_kill_process(struct oom_control *oc, const char *message)，其中oc->victim是要被杀掉的进程，如果有cgroup会把相同内存cgroup的进程都杀掉。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/*
</span></span><span style=display:flex><span> * setup_per_zone_lowmem_reserve - called whenever
</span></span><span style=display:flex><span> *	sysctl_lowmem_reserve_ratio changes.  Ensures that each zone
</span></span><span style=display:flex><span> *	has a correct pages reserved value, so an adequate number of
</span></span><span style=display:flex><span> *	pages are left in the zone after a successful __alloc_pages<span style=color:#ff79c6>()</span>.
</span></span><span style=display:flex><span> */
</span></span></code></pre></div><p>static void setup_per_zone_lowmem_reserve(void) 我们使用 eBPF 程序(跟踪 oom_kill_process 内核函数)来统计内存 OOM 的情况。内核源码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>static void oom_kill_process<span style=color:#ff79c6>(</span>struct oom_control *oc, const char *message<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>/*
</span></span><span style=display:flex><span> * Kill provided task unless it<span style=color:#f1fa8c>&#39;s secured by setting
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c> * oom_score_adj to OOM_SCORE_ADJ_MIN.
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c> */
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>static int oom_kill_memcg_member(struct task_struct *task, void *message)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>{
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	if (task-&gt;signal-&gt;oom_score_adj != OOM_SCORE_ADJ_MIN &amp;&amp;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	    !is_global_init(task)) {
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>		get_task_struct(task);
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>		__oom_kill_process(task, message);
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	}
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	return 0;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>}
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>static void oom_kill_process(struct oom_control *oc, const char *message)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>{
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	struct task_struct *victim = oc-&gt;chosen;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	struct mem_cgroup *oom_group;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	static DEFINE_RATELIMIT_STATE(oom_rs, DEFAULT_RATELIMIT_INTERVAL,
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>					      DEFAULT_RATELIMIT_BURST);
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	/*
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>	 * If the task is already exiting, don&#39;</span>t alarm the sysadmin or <span style=color:#8be9fd;font-style:italic>kill</span>
</span></span><span style=display:flex><span>	 * its children or threads, just give it access to memory reserves
</span></span><span style=display:flex><span>	 * so it can die quickly
</span></span><span style=display:flex><span>	 */
</span></span><span style=display:flex><span>	task_lock<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>task_will_free_mem<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		mark_oom_victim<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		wake_oom_reaper<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		task_unlock<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		put_task_struct<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>	task_unlock<span style=color:#ff79c6>(</span>victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>__ratelimit<span style=color:#ff79c6>(</span>&amp;oom_rs<span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span>		dump_header<span style=color:#ff79c6>(</span>oc, victim<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	/*
</span></span><span style=display:flex><span>	 * Do we need to <span style=color:#8be9fd;font-style:italic>kill</span> the entire memory cgroup?
</span></span><span style=display:flex><span>	 * Or even one of the ancestor memory cgroups?
</span></span><span style=display:flex><span>	 * Check this out before killing the victim task.
</span></span><span style=display:flex><span>	 */
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>oom_group</span> <span style=color:#ff79c6>=</span> mem_cgroup_get_oom_group<span style=color:#ff79c6>(</span>victim, oc-&gt;memcg<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	__oom_kill_process<span style=color:#ff79c6>(</span>victim, message<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	/*
</span></span><span style=display:flex><span>	 * If necessary, <span style=color:#8be9fd;font-style:italic>kill</span> all tasks in the selected memory cgroup.
</span></span><span style=display:flex><span>	 */
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>oom_group<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		mem_cgroup_print_oom_group<span style=color:#ff79c6>(</span>oom_group<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		mem_cgroup_scan_tasks<span style=color:#ff79c6>(</span>oom_group, oom_kill_memcg_member,
</span></span><span style=display:flex><span>				      <span style=color:#ff79c6>(</span>void*<span style=color:#ff79c6>)</span>message<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		mem_cgroup_put<span style=color:#ff79c6>(</span>oom_group<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>我们可以使用 bpftrace 程序来跟踪 oom_kill_process 内核函数，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>bpftrace -e <span style=color:#f1fa8c>&#39;kprobe:oom_kill_process { printf(&#34;%s called oom_kill_process\n&#34;, comm); }&#39;</span>
</span></span></code></pre></div><h1 id=手动触发-oom>手动触发 OOM</h1><h2 id=方式一>方式一</h2><p>/proc/sysrq-trigger 是一个特殊的接口，通过这个接口，可以直接发送信号给内核，触发一些特殊的操作。这个接口通常用于系统调试或者紧急恢复。/proc/sysrq-trigger 就是其中的一个接口，通过向这个文件写入特定的字符，可以触发内核执行一些特定的动作。</p><p>这个功能主要用于系统的调试或者救援，比如在系统死锁时强制重启系统，或者在内存耗尽时手动触发OOM Killer。执行 echo f > /proc/sysrq-trigger 时，向内核发送了一个f信号，这个信号的含义是“调用OOM Killer”。也就是说，这个操作会直接触发内核去执行OOM Killer，不需要等到内存真正不足。</p><p>最简单的测试触发OOM的方法，可以把某个进程的oom_adj设置到15（最大值），最容易触发。然后执行以下命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4># echo f &gt; /proc/sysrq-trigger   // &#39;f&#39; - Will call oom_kill to kill a memory hog process.</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# pidof nginx
</span></span><span style=display:flex><span><span style=color:#bd93f9>624728</span> <span style=color:#bd93f9>624727</span> <span style=color:#bd93f9>624726</span> <span style=color:#bd93f9>624725</span> <span style=color:#bd93f9>624724</span> <span style=color:#bd93f9>624723</span> <span style=color:#bd93f9>624722</span> <span style=color:#bd93f9>624721</span> <span style=color:#bd93f9>624719</span>
</span></span><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#bd93f9>15</span> &gt; /proc/624728/oom_score_adj
</span></span><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# <span style=color:#8be9fd;font-style:italic>echo</span> f &gt; /proc/sysrq-trigger
</span></span></code></pre></div><h2 id=方式二>方式二</h2><p>用 C 写一个叫 bigmem 程序，分配大内存，主动触发 OOM。代码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#6272a4>#include &lt;stdio.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;stdlib.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;string.h&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#define PAGE_SZ (1&lt;&lt;12)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>int main<span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    int i;
</span></span><span style=display:flex><span>    int <span style=color:#8be9fd;font-style:italic>gb</span> <span style=color:#ff79c6>=</span> 36; //以GB为单位分配内存大小
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>i</span> <span style=color:#ff79c6>=</span> 0; i &lt; <span style=color:#ff79c6>((</span>unsigned long<span style=color:#ff79c6>)</span>gb&lt;&lt;30<span style=color:#ff79c6>)</span>/PAGE_SZ ; ++i<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        void *m <span style=color:#ff79c6>=</span> malloc<span style=color:#ff79c6>(</span>PAGE_SZ<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>!m<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>            break;
</span></span><span style=display:flex><span>        memset<span style=color:#ff79c6>(</span>m, 0, 1<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    printf<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;allocated %lu MB\n&#34;</span>, <span style=color:#ff79c6>((</span>unsigned long<span style=color:#ff79c6>)</span>i*PAGE_SZ<span style=color:#ff79c6>)</span>&gt;&gt;20<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>    getchar<span style=color:#ff79c6>()</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> 0;
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>使用如下方式进行编译与运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -o bigmem bigmem.c
</span></span><span style=display:flex><span>./bigmem
</span></span></code></pre></div><h1 id=代码示例>代码示例</h1><p>通过上述方式主动触发 OOM，示例如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# ./run.sh 
</span></span><span style=display:flex><span>libbpf: loading object <span style=color:#f1fa8c>&#39;oom_bpf&#39;</span> from buffer
</span></span><span style=display:flex><span>libbpf: elf: section<span style=color:#ff79c6>(</span>3<span style=color:#ff79c6>)</span> kprobe/oom_kill_process, size 264, link 0, flags 6, <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>libbpf: sec <span style=color:#f1fa8c>&#39;kprobe/oom_kill_process&#39;</span>: found program <span style=color:#f1fa8c>&#39;kprobe_oom_kill_process&#39;</span> at insn offset <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>(</span><span style=color:#bd93f9>0</span> bytes<span style=color:#ff79c6>)</span>, code size <span style=color:#bd93f9>33</span> insns <span style=color:#ff79c6>(</span><span style=color:#bd93f9>264</span> bytes<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>libbpf: elf: section<span style=color:#ff79c6>(</span>4<span style=color:#ff79c6>)</span> .relkprobe/oom_kill_process, size 16, link 27, flags 40, <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>9</span>
</span></span><span style=display:flex><span>libbpf: elf: section<span style=color:#ff79c6>(</span>5<span style=color:#ff79c6>)</span> license, size 13, link 0, flags 3, <span style=color:#8be9fd;font-style:italic>type</span><span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pid: 624728, comm: nginx
</span></span><span style=display:flex><span>pid: 625669, comm: hosteye
</span></span><span style=display:flex><span>pid: 625697, comm: hosteye
</span></span><span style=display:flex><span>pid: 625774, comm: bigmem
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# <span style=color:#8be9fd;font-style:italic>echo</span> f &gt; /proc/sysrq-trigger 
</span></span><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# <span style=color:#8be9fd;font-style:italic>echo</span> f &gt; /proc/sysrq-trigger 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# ./bigmem 
</span></span><span style=display:flex><span>Killed
</span></span></code></pre></div><p>系统自身查看 OOMEvent 事件，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# tail -f /var/log/syslog
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638843<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625306<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625306</span>     <span style=color:#bd93f9>4291</span>     <span style=color:#bd93f9>1348</span>    <span style=color:#bd93f9>69632</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> sshd
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638844<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625366<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625366</span>     <span style=color:#bd93f9>3075</span>     <span style=color:#bd93f9>1100</span>    <span style=color:#bd93f9>57344</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> bash
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638846<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625724<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625724</span>    <span style=color:#bd93f9>47501</span>     <span style=color:#bd93f9>9206</span>   <span style=color:#bd93f9>430080</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> hosteye
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638847<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625747<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625747</span>     <span style=color:#bd93f9>2507</span>      <span style=color:#bd93f9>628</span>    <span style=color:#bd93f9>53248</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> cron
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638848<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625774<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625774</span>  <span style=color:#bd93f9>8026776</span>  <span style=color:#bd93f9>8026366</span> <span style=color:#bd93f9>64376832</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> bigmem
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638850<span style=color:#ff79c6>]</span> oom-kill:constraint<span style=color:#ff79c6>=</span>CONSTRAINT_NONE,nodemask<span style=color:#ff79c6>=(</span>null<span style=color:#ff79c6>)</span>,cpuset<span style=color:#ff79c6>=</span>containerd.service,mems_allowed<span style=color:#ff79c6>=</span>0,global_oom,task_memcg<span style=color:#ff79c6>=</span>/user.slice/user-0.slice/session-3104.scope,task<span style=color:#ff79c6>=</span>bigmem,pid<span style=color:#ff79c6>=</span>625774,uid<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638861<span style=color:#ff79c6>]</span> Out of memory: Killed process <span style=color:#bd93f9>625774</span> <span style=color:#ff79c6>(</span>bigmem<span style=color:#ff79c6>)</span> total-vm:32107104kB, anon-rss:32104292kB, file-rss:1172kB, shmem-rss:0kB, UID:0 pgtables:62868kB oom_score_adj:0
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve systemd<span style=color:#ff79c6>[</span>1<span style=color:#ff79c6>]</span>: session-3104.scope: A process of this unit has been killed by the OOM killer.
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:10:01 instance-kncj9zve CRON<span style=color:#ff79c6>[</span>625839<span style=color:#ff79c6>]</span>: <span style=color:#ff79c6>(</span>root<span style=color:#ff79c6>)</span> CMD <span style=color:#ff79c6>(</span>/opt/hosteye/bin/upgrade --upgrade_mode<span style=color:#ff79c6>=</span>8&gt;/dev/null 2&gt;&amp;1<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:15:01 instance-kncj9zve CRON<span style=color:#ff79c6>[</span>625981<span style=color:#ff79c6>]</span>: <span style=color:#ff79c6>(</span>root<span style=color:#ff79c6>)</span> CMD <span style=color:#ff79c6>(</span>/opt/hosteye/bin/upgrade --upgrade_mode<span style=color:#ff79c6>=</span>8&gt;/dev/null 2&gt;&amp;1<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>root@instance-kncj9zve:~/tanjunchen/tracer/function/oom# tail -f /var/log/kern.log
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638839<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625290<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625290</span>     <span style=color:#bd93f9>2659</span>      <span style=color:#bd93f9>601</span>    <span style=color:#bd93f9>53248</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> run.sh
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638840<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625304<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625304</span>     <span style=color:#bd93f9>9205</span>      <span style=color:#bd93f9>502</span>   <span style=color:#bd93f9>110592</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> oom
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638842<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625305<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625305</span>     <span style=color:#bd93f9>2233</span>      <span style=color:#bd93f9>184</span>    <span style=color:#bd93f9>45056</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> sleep
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638843<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625306<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625306</span>     <span style=color:#bd93f9>4291</span>     <span style=color:#bd93f9>1348</span>    <span style=color:#bd93f9>69632</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> sshd
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638844<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625366<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625366</span>     <span style=color:#bd93f9>3075</span>     <span style=color:#bd93f9>1100</span>    <span style=color:#bd93f9>57344</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> bash
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638846<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625724<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625724</span>    <span style=color:#bd93f9>47501</span>     <span style=color:#bd93f9>9206</span>   <span style=color:#bd93f9>430080</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> hosteye
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638847<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625747<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625747</span>     <span style=color:#bd93f9>2507</span>      <span style=color:#bd93f9>628</span>    <span style=color:#bd93f9>53248</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> cron
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638848<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span> 625774<span style=color:#ff79c6>]</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>625774</span>  <span style=color:#bd93f9>8026776</span>  <span style=color:#bd93f9>8026366</span> <span style=color:#bd93f9>64376832</span>        <span style=color:#bd93f9>0</span>             <span style=color:#bd93f9>0</span> bigmem
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638850<span style=color:#ff79c6>]</span> oom-kill:constraint<span style=color:#ff79c6>=</span>CONSTRAINT_NONE,nodemask<span style=color:#ff79c6>=(</span>null<span style=color:#ff79c6>)</span>,cpuset<span style=color:#ff79c6>=</span>containerd.service,mems_allowed<span style=color:#ff79c6>=</span>0,global_oom,task_memcg<span style=color:#ff79c6>=</span>/user.slice/user-0.slice/session-3104.scope,task<span style=color:#ff79c6>=</span>bigmem,pid<span style=color:#ff79c6>=</span>625774,uid<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>Jan <span style=color:#bd93f9>18</span> 20:08:17 instance-kncj9zve kernel: <span style=color:#ff79c6>[</span>789677.638861<span style=color:#ff79c6>]</span> Out of memory: Killed process <span style=color:#bd93f9>625774</span> <span style=color:#ff79c6>(</span>bigmem<span style=color:#ff79c6>)</span> total-vm:32107104kB, anon-rss:32104292kB, file-rss:1172kB, shmem-rss:0kB, UID:0 pgtables:62868kB oom_score_adj:0
</span></span></code></pre></div><h1 id=参考>参考</h1><ol><li><a href=https://blog.51cto.com/laoxu/1267097>https://blog.51cto.com/laoxu/1267097</a></li><li><a href=https://www.cnblogs.com/MrLiuZF/p/15229868.html>https://www.cnblogs.com/MrLiuZF/p/15229868.html</a></li></ol><hr><ul class=pager><li class=previous><a href=/post/2024-04-09-scheduler-framework-04/ data-toggle=tooltip data-placement=top title="深入理解 Kubernetes Scheduler Framework 调度框架（Part 4）">&larr;
Previous Post</a></li><li class=next><a href=/post/2024-05-02-linux-page-fault/ data-toggle=tooltip data-placement=top title="监测 Linux 内存缺页中断事件">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>