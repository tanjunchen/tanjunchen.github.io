<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="eBPF 探索 Linux 可观测性、网络、安全、性能"><meta property="og:title" content="eBPF 探索 Linux 可观测性、网络、安全、性能"><meta property="twitter:title" content="eBPF 探索 Linux 可观测性、网络、安全、性能"><meta name=description content="eBPF 在 Linux 操作系统中，可以用于安全、网络和性能监控。AWS、Azure 和 Google Cloud 等云厂商 eBPF 相关云产品相继被推出，国内云厂商也有很多的落地与实践，如阿里云、华为云、字节火山引擎、百度智能云等。"><meta property="og:description" content="eBPF 在 Linux 操作系统中，可以用于安全、网络和性能监控。AWS、Azure 和 Google Cloud 等云厂商 eBPF 相关云产品相继被推出，国内云厂商也有很多的落地与实践，如阿里云、华为云、字节火山引擎、百度智能云等。"><meta property="twitter:description" content="eBPF 在 Linux 操作系统中，可以用于安全、网络和性能监控。AWS、Azure 和 Google Cloud 等云厂商 eBPF 相关云产品相继被推出，国内云厂商也有很多的落地与实践，如阿里云、华为云、字节火山引擎、百度智能云等。"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>eBPF 探索 Linux 可观测性、网络、安全、性能 | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2023-12-09-ebpf-share/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a>
<a class=tag href=/tags/ebpf title=eBPF>eBPF</a></div><h1>eBPF 探索 Linux 可观测性、网络、安全、性能</h1><h2 class=subheading>eBPF 在云厂商可观测性落地与实践，实现高效定位与诊断棘手问题，本文主要介 eBPF 基础知识、pwru 示例、eBPF 实现原理、eBPF 核心实现流程与常见问题、云厂商 eBPF 产品落地实践等。</h2><span class=meta>Posted by
陈谭军
on
Saturday, December 9, 2023
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2023-12-09-ebpf-share/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 12524 字</span>，阅读约 <span class=more-meta>25 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=小试牛刀>小试牛刀</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# ./helloworld 
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen/bpf-developer-tutorial/src/24-hide# ps aux | grep helloworld
</span></span><span style=display:flex><span>root     <span style=color:#bd93f9>3312792</span>  0.0  0.0   <span style=color:#bd93f9>2776</span>   <span style=color:#bd93f9>964</span> pts/0    S+   20:22   0:00 ./helloworld
</span></span><span style=display:flex><span>root     <span style=color:#bd93f9>3313669</span>  0.0  0.0   <span style=color:#bd93f9>9748</span>  <span style=color:#bd93f9>2316</span> pts/1    S+   20:22   0:00 grep --color<span style=color:#ff79c6>=</span>auto helloworld
</span></span></code></pre></div><p>问题：如果我不想让别人看到我正在运行的进程，可以如何实现？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ps命令的实现原理是通过读取/proc目录下的进程信息文件来获取系统中的进程信息。在Linux系统中，每个进程都有一个唯一的进程标识符（PID），ps命令通过读取/proc目录下的每个进程的子目录来获取进程的详细信息。具体来说，ps命令会遍历/proc目录下的所有子目录，每个子目录对应一个进程，进程的子目录的名称即为进程的PID。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>在 Linux 中，getdents64 系统调用可以读取目录下的文件信息，我们可以通过挂接这个系统调用，修改它返回的结果，从而达到隐藏文件的目的。
</span></span></code></pre></div><p>getdents64 是一个 Linux 系统调用，用于从打开的文件描述符 fd 读取目录项，这个系统调用主要用于读取文件系统的目录内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#50fa7b>__attribute__</span>((unused)) <span style=color:#8be9fd>int</span> getdents64(<span style=color:#8be9fd>int</span> fd, <span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>dirp, <span style=color:#8be9fd>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> ret <span style=color:#ff79c6>=</span> sys_getdents64(fd, dirp, count);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>		SET_ERRNO(<span style=color:#ff79c6>-</span>ret);
</span></span><span style=display:flex><span>		ret <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> linux_dirent64 {
</span></span><span style=display:flex><span>    u64        d_ino;    <span style=color:#6272a4>// 文件的 inode（索引节点）号，是一个64位的无符号整数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    u64        d_off;    <span style=color:#6272a4>// 64位的偏移量，指向下一个linux_dirent64结构在目录项中的位置
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>short</span> d_reclen; <span style=color:#6272a4>// 当前目录项的大小
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>char</span>  d_type;   <span style=color:#6272a4>// 文件类型字段
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>char</span>           d_name[]; <span style=color:#6272a4>// Filename (null-terminated) 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>};
</span></span></code></pre></div><p>运行结果如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-frllxehj:/sys/kernel/debug/tracing# ls
</span></span><span style=display:flex><span>available_events            dynamic_events            hwlat_detector   printk_formats         set_event_pid           snapshot            trace_clock       tracing_max_latency
</span></span><span style=display:flex><span>available_filter_functions  dyn_ftrace_total_info     instances        README                 set_ftrace_filter       stack_max_size      trace_marker      tracing_on
</span></span><span style=display:flex><span>available_tracers           enabled_functions         kprobe_events    saved_cmdlines         set_ftrace_notrace      stack_trace         trace_marker_raw  tracing_thresh
</span></span><span style=display:flex><span>buffer_percent              error_log                 kprobe_profile   saved_cmdlines_size    set_ftrace_notrace_pid  stack_trace_filter  trace_options     uprobe_events
</span></span><span style=display:flex><span>buffer_size_kb              events                    max_graph_depth  saved_tgids            set_ftrace_pid          synthetic_events    trace_pipe        uprobe_profile
</span></span><span style=display:flex><span>buffer_total_size_kb        free_buffer               options          set_event              set_graph_function      timestamp_mode      trace_stat
</span></span><span style=display:flex><span>current_tracer              function_profile_enabled  per_cpu          set_event_notrace_pid  set_graph_notrace       trace               tracing_cpumask
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# cat /sys/kernel/debug/tracing/trace_pipe
</span></span><span style=display:flex><span>kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407065: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename next one 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407217: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename previous hugetlb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407219: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename next one 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407368: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename previous hugetlb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407369: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename next one 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407512: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename previous hugetlb
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         kubelet-911401  <span style=color:#ff79c6>[</span>000<span style=color:#ff79c6>]</span> d...1 2356319.407514: bpf_trace_printk: <span style=color:#ff79c6>[</span>PID_HIDE<span style=color:#ff79c6>]</span> filename next one 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# ./helloworld 
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>Hello World
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen/bpf-developer-tutorial/src/24-hide# ps aux | grep helloworld
</span></span><span style=display:flex><span>root     <span style=color:#bd93f9>3360375</span>  0.0  0.0   <span style=color:#bd93f9>2776</span>   <span style=color:#bd93f9>940</span> pts/2    S+   21:03   0:00 ./helloworld
</span></span><span style=display:flex><span>root     <span style=color:#bd93f9>3360462</span>  0.0  0.0   <span style=color:#bd93f9>9748</span>  <span style=color:#bd93f9>2144</span> pts/1    S+   21:03   0:00 grep --color<span style=color:#ff79c6>=</span>auto helloworld
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen/bpf-developer-tutorial/src/24-hide# ./pidhide -p <span style=color:#bd93f9>3360375</span>
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen/bpf-developer-tutorial/src/24-hide# ps aux | grep helloworld
</span></span><span style=display:flex><span>root     <span style=color:#bd93f9>3361471</span>  0.0  0.0   <span style=color:#bd93f9>9748</span>  <span style=color:#bd93f9>2136</span> pts/1    S+   21:04   0:00 grep --color<span style=color:#ff79c6>=</span>auto helloworld
</span></span></code></pre></div><p>pidhide 源码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>// SPDX-License-Identifier: BSD-3-Clause
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;vmlinux.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_helpers.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_tracing.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/bpf_core_read.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;pidhide.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;vmlinux.h&#34; 是一个包含了完整的内核数据结构的头文件，是从 vmlinux 内核二进制中提取的。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;bpf_helpers.h&#34; 头文件中定义了一系列的宏，这些宏是 eBPF 程序使用的 BPF 助手（helper）函数的封装。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;bpf_tracing.h&#34; 是用于跟踪事件的头文件，它包含了许多宏和函数。
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;bpf_core_read.h&#34; 头文件提供了一组用于从内核读取数据的宏和函数。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>char</span> LICENSE[] SEC(<span style=color:#f1fa8c>&#34;license&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Dual BSD/GPL&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Ringbuffer Map to pass messages from kernel to user
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;rb&#34; 是一个 Ringbuffer 类型的 map，它用于从内核向用户态传递消息
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    __uint(type, BPF_MAP_TYPE_RINGBUF);
</span></span><span style=display:flex><span>    __uint(max_entries, <span style=color:#bd93f9>256</span> <span style=color:#ff79c6>*</span> <span style=color:#bd93f9>1024</span>);
</span></span><span style=display:flex><span>} rb SEC(<span style=color:#f1fa8c>&#34;.maps&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Map to fold the dents buffer addresses
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;map_buffs&#34; 是一个 Hash 类型的 map，它用于存储目录项（dentry）的缓冲区地址。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    __uint(type, BPF_MAP_TYPE_HASH);
</span></span><span style=display:flex><span>    __uint(max_entries, <span style=color:#bd93f9>8192</span>);
</span></span><span style=display:flex><span>    __type(key, size_t);
</span></span><span style=display:flex><span>    __type(value, <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span>);
</span></span><span style=display:flex><span>} map_buffs SEC(<span style=color:#f1fa8c>&#34;.maps&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Map used to enable searching through the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// data in a loop
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;map_bytes_read&#34; 是一个 Hash 类型的 map，它用于在数据循环中启用搜索。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    __uint(type, BPF_MAP_TYPE_HASH);
</span></span><span style=display:flex><span>    __uint(max_entries, <span style=color:#bd93f9>8192</span>);
</span></span><span style=display:flex><span>    __type(key, size_t);
</span></span><span style=display:flex><span>    __type(value, <span style=color:#8be9fd>int</span>);
</span></span><span style=display:flex><span>} map_bytes_read SEC(<span style=color:#f1fa8c>&#34;.maps&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Map with address of actual
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;map_to_patch&#34; 是一个 Hash 类型的 map，存储了需要被修改的目录项（dentry）的地址。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    __uint(type, BPF_MAP_TYPE_HASH);
</span></span><span style=display:flex><span>    __uint(max_entries, <span style=color:#bd93f9>8192</span>);
</span></span><span style=display:flex><span>    __type(key, size_t);
</span></span><span style=display:flex><span>    __type(value, <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span>);
</span></span><span style=display:flex><span>} map_to_patch SEC(<span style=color:#f1fa8c>&#34;.maps&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Map to hold program tail calls
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// &#34;map_prog_array&#34; 是一个 Prog Array 类型的 map，它用于保存程序的尾部调用。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    __uint(type, BPF_MAP_TYPE_PROG_ARRAY);
</span></span><span style=display:flex><span>    __uint(max_entries, <span style=color:#bd93f9>5</span>);
</span></span><span style=display:flex><span>    __type(key, __u32);
</span></span><span style=display:flex><span>    __type(value, __u32);
</span></span><span style=display:flex><span>} map_prog_array SEC(<span style=color:#f1fa8c>&#34;.maps&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Optional Target Parent PID
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 目标父进程的 PID
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>const</span> <span style=color:#ff79c6>volatile</span> <span style=color:#8be9fd>int</span> target_ppid <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// These store the string represenation
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// of the PID to hide. This becomes the name
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// of the folder in /proc/
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 需要隐藏的 PID 的长度
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>const</span> <span style=color:#ff79c6>volatile</span> <span style=color:#8be9fd>int</span> pid_to_hide_len <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span><span style=color:#6272a4>// 需要隐藏的 PID
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>const</span> <span style=color:#ff79c6>volatile</span> <span style=color:#8be9fd>char</span> pid_to_hide[MAX_PID_LEN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;tp/syscalls/sys_enter_getdents64&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> handle_getdents_enter(<span style=color:#ff79c6>struct</span> trace_event_raw_sys_enter <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 主要功能是获取当前进程的进程组ID（TGID）和进程ID（PID）
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// PID位于低32位，而TGID位于高32位。对于多线程程序，所有线程共享相同的TGID，而PID则用于区分不同的线程。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    size_t pid_tgid <span style=color:#ff79c6>=</span> bpf_get_current_pid_tgid();
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Check if we&#39;re a process thread of interest
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// if target_ppid is 0 then we target all pids
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (target_ppid <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>struct</span> task_struct <span style=color:#ff79c6>*</span>task <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> task_struct <span style=color:#ff79c6>*</span>)bpf_get_current_task();
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> ppid <span style=color:#ff79c6>=</span> BPF_CORE_READ(task, real_parent, tgid);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (ppid <span style=color:#ff79c6>!=</span> target_ppid)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> pid <span style=color:#ff79c6>=</span> pid_tgid <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>32</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> fd <span style=color:#ff79c6>=</span> ctx<span style=color:#ff79c6>-&gt;</span>args[<span style=color:#bd93f9>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> buff_count <span style=color:#ff79c6>=</span> ctx<span style=color:#ff79c6>-&gt;</span>args[<span style=color:#bd93f9>2</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Store params in map for exit function
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>dirp <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>)ctx<span style=color:#ff79c6>-&gt;</span>args[<span style=color:#bd93f9>1</span>];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// getdents64 系统调用的第二个参数，它是一个指向 linux_dirent64 结构体的指针，代表了系统调用要读取的目录的内容。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 我们将这个指针以及当前的 PID 和线程组 ID 作为键值对保存到 map_buffs 这个 map 中。 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>map_buffs, <span style=color:#ff79c6>&amp;</span>pid_tgid, <span style=color:#ff79c6>&amp;</span>dirp, BPF_ANY);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;tp/syscalls/sys_exit_getdents64&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> handle_getdents_exit(<span style=color:#ff79c6>struct</span> trace_event_raw_sys_exit <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    size_t pid_tgid <span style=color:#ff79c6>=</span> bpf_get_current_pid_tgid();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> total_bytes_read <span style=color:#ff79c6>=</span> ctx<span style=color:#ff79c6>-&gt;</span>ret;
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果没有读取到内容，我们就直接返回
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (total_bytes_read <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 从 map_buffs 这个 map 中获取 getdents64 系统调用入口处保存的目录内容的地址
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Check we stored the address of the buffer from the syscall entry
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>pbuff_addr <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>map_buffs, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (pbuff_addr <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// All of this is quite complex, but basically boils down to
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// Calling &#39;handle_getdents_exit&#39; in a loop to iterate over the file listing
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// in chunks of 200, and seeing if a folder with the name of our pid is in there.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// If we find it, use &#39;bpf_tail_call&#39; to jump to handle_getdents_patch to do the actual
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// patching
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> buff_addr <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>pbuff_addr;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>dirp <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> pid <span style=color:#ff79c6>=</span> pid_tgid <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>32</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>short</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> d_reclen <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>char</span> filename[MAX_PID_LEN];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> bpos <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>pBPOS <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>map_bytes_read, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (pBPOS <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        bpos <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>pBPOS;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>200</span>; i<span style=color:#ff79c6>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (bpos <span style=color:#ff79c6>&gt;=</span> total_bytes_read)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        dirp <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>)(buff_addr <span style=color:#ff79c6>+</span> bpos);
</span></span><span style=display:flex><span>        bpf_probe_read_user(<span style=color:#ff79c6>&amp;</span>d_reclen, <span style=color:#ff79c6>sizeof</span>(d_reclen), <span style=color:#ff79c6>&amp;</span>dirp<span style=color:#ff79c6>-&gt;</span>d_reclen);
</span></span><span style=display:flex><span>        bpf_probe_read_user_str(<span style=color:#ff79c6>&amp;</span>filename, pid_to_hide_len, dirp<span style=color:#ff79c6>-&gt;</span>d_name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd>int</span> j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> (j <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; j <span style=color:#ff79c6>&lt;</span> pid_to_hide_len; j<span style=color:#ff79c6>++</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (filename[j] <span style=color:#ff79c6>!=</span> pid_to_hide[j])
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (j <span style=color:#ff79c6>==</span> pid_to_hide_len)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// ***********
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// We&#39;ve found the folder!!!
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// Jump to handle_getdents_patch so we can remove it!
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#6272a4>// ***********
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>map_bytes_read, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>            bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>map_buffs, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 用 bpf_tail_call 函数跳转到 handle_getdents_patch 函数，进行实际的隐藏操作
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            bpf_tail_call(ctx, <span style=color:#ff79c6>&amp;</span>map_prog_array, PROG_02);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>map_to_patch, <span style=color:#ff79c6>&amp;</span>pid_tgid, <span style=color:#ff79c6>&amp;</span>dirp, BPF_ANY);
</span></span><span style=display:flex><span>        bpos <span style=color:#ff79c6>+=</span> d_reclen;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// If we didn&#39;t find it, but there&#39;s still more to read,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// jump back the start of this function and keep looking
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 如果没有找到，则尾调用到原来的地方继续执行操作
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (bpos <span style=color:#ff79c6>&lt;</span> total_bytes_read)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>map_bytes_read, <span style=color:#ff79c6>&amp;</span>pid_tgid, <span style=color:#ff79c6>&amp;</span>bpos, BPF_ANY);
</span></span><span style=display:flex><span>        bpf_tail_call(ctx, <span style=color:#ff79c6>&amp;</span>map_prog_array, PROG_01);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>map_bytes_read, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>    bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>map_buffs, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;tp/syscalls/sys_exit_getdents64&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> handle_getdents_patch(<span style=color:#ff79c6>struct</span> trace_event_raw_sys_exit <span style=color:#ff79c6>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Only patch if we&#39;ve already checked and found our pid&#39;s folder to hide
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    size_t pid_tgid <span style=color:#ff79c6>=</span> bpf_get_current_pid_tgid();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>pbuff_addr <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>map_to_patch, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (pbuff_addr <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Unlink target, by reading in previous linux_dirent64 struct,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// and setting it&#39;s d_reclen to cover itself and our target.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// This will make the program skip over our folder.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>long</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> buff_addr <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>*</span>pbuff_addr;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>dirp_previous <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>)buff_addr;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>short</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> d_reclen_previous <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    bpf_probe_read_user(<span style=color:#ff79c6>&amp;</span>d_reclen_previous, <span style=color:#ff79c6>sizeof</span>(d_reclen_previous), <span style=color:#ff79c6>&amp;</span>dirp_previous<span style=color:#ff79c6>-&gt;</span>d_reclen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>dirp <span style=color:#ff79c6>=</span> (<span style=color:#ff79c6>struct</span> linux_dirent64 <span style=color:#ff79c6>*</span>)(buff_addr <span style=color:#ff79c6>+</span> d_reclen_previous);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>short</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> d_reclen <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    bpf_probe_read_user(<span style=color:#ff79c6>&amp;</span>d_reclen, <span style=color:#ff79c6>sizeof</span>(d_reclen), <span style=color:#ff79c6>&amp;</span>dirp<span style=color:#ff79c6>-&gt;</span>d_reclen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Debug print
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>char</span> filename[MAX_PID_LEN];
</span></span><span style=display:flex><span>    bpf_probe_read_user_str(<span style=color:#ff79c6>&amp;</span>filename, pid_to_hide_len, dirp_previous<span style=color:#ff79c6>-&gt;</span>d_name);
</span></span><span style=display:flex><span>    filename[pid_to_hide_len <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0x00</span>;
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;[PID_HIDE] filename previous %s</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, filename);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    bpf_probe_read_user_str(<span style=color:#ff79c6>&amp;</span>filename, pid_to_hide_len, dirp<span style=color:#ff79c6>-&gt;</span>d_name);
</span></span><span style=display:flex><span>    filename[pid_to_hide_len <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0x00</span>;
</span></span><span style=display:flex><span>    bpf_printk(<span style=color:#f1fa8c>&#34;[PID_HIDE] filename next one %s</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, filename);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Attempt to overwrite
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 核心操作，进行覆盖操作
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 类似从某个链表中删除某个元素
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#8be9fd>short</span> <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> d_reclen_new <span style=color:#ff79c6>=</span> d_reclen_previous <span style=color:#ff79c6>+</span> d_reclen;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>long</span> ret <span style=color:#ff79c6>=</span> bpf_probe_write_user(<span style=color:#ff79c6>&amp;</span>dirp_previous<span style=color:#ff79c6>-&gt;</span>d_reclen, <span style=color:#ff79c6>&amp;</span>d_reclen_new, <span style=color:#ff79c6>sizeof</span>(d_reclen_new));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Send an event
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>struct</span> event <span style=color:#ff79c6>*</span>e;
</span></span><span style=display:flex><span>    e <span style=color:#ff79c6>=</span> bpf_ringbuf_reserve(<span style=color:#ff79c6>&amp;</span>rb, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>e), <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (e)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        e<span style=color:#ff79c6>-&gt;</span>success <span style=color:#ff79c6>=</span> (ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>        e<span style=color:#ff79c6>-&gt;</span>pid <span style=color:#ff79c6>=</span> (pid_tgid <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>32</span>);
</span></span><span style=display:flex><span>        bpf_get_current_comm(<span style=color:#ff79c6>&amp;</span>e<span style=color:#ff79c6>-&gt;</span>comm, <span style=color:#ff79c6>sizeof</span>(e<span style=color:#ff79c6>-&gt;</span>comm));
</span></span><span style=display:flex><span>        bpf_ringbuf_submit(e, <span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bpf_map_delete_elem(<span style=color:#ff79c6>&amp;</span>map_to_patch, <span style=color:#ff79c6>&amp;</span>pid_tgid);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=ebpf-简介>eBPF 简介</h1><h2 id=什么是-ebpf>什么是 eBPF？</h2><p>eBPF 是一项革命性的技术，起源于 Linux 内核，可以在操作系统内核等特权上下文中运行沙盒程序。它用于安全有效地扩展内核的功能，而无需更改内核源代码或加载内核模块。从历史进程上看，操作系统一直是实现可观察性、安全性和网络功能的理想场所。推荐一个很好的学习网站 <a href=https://ebpf.io/>https://ebpf.io/</a>。</p><p><img src=/images/2023-12-09-ebpf-share/1.png alt></p><h2 id=ebpf-整体架构>eBPF 整体架构</h2><p>eBPF 整体架构图如下所示：</p><p><img src=/images/2023-12-09-ebpf-share/2.png alt></p><h2 id=ebpf-可以做什么>eBPF 可以做什么？</h2><p><img src=/images/2023-12-09-ebpf-share/3.png alt></p><p>我们常见的 eBPF 应用（https://ebpf.io/applications/）如下所示：bcc（CPU、内存、文件系统、磁盘IO、网络、安全、编程语言、应用程序、内核等）。</p><p><img src=/images/2023-12-09-ebpf-share/4.png alt></p><p><img src=/images/2023-12-09-ebpf-share/5.png alt></p><p><img src=/images/2023-12-09-ebpf-share/6.png alt></p><h2 id=ebpf-hook-分类>eBPF Hook 分类</h2><p>&ldquo;Hook"点是指内核中的特定位置，用户可以在这些位置插入自定义的eBPF程序以改变或增强内核的默认行为。通过eBPF可以对多种类型的事件进行跟踪，如 kprobe,kretprobe,tracepoint,uprobe,uretprobe,socket filter,tc filter,perf events，USDT，fenrty/fexit，XDP,tp 等。</p><p><img src=/images/2023-12-09-ebpf-share/7.png alt></p><p><img src=/images/2023-12-09-ebpf-share/8.png alt></p><h2 id=ebpf-常见写法>eBPF 常见写法</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kprobe/vfs_open&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> vfs_open_entry(<span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>ctx){
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> get_filename_from_file((<span style=color:#ff79c6>struct</span> file<span style=color:#ff79c6>*</span>)PT_REGS_PARM2(ctx));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kretprobe/vfs_open&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> vfs_open_exit(<span style=color:#ff79c6>struct</span> pt_regs <span style=color:#ff79c6>*</span>ctx){
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> ret <span style=color:#ff79c6>=</span> PT_REGS_RC(ctx);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>probe_exit</span>(VFS_OPEN, ret);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;fexit/vfs_open&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> BPF_PROG(vfs_open_exit, <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>struct</span> path <span style=color:#ff79c6>*</span>path, <span style=color:#ff79c6>struct</span> file <span style=color:#ff79c6>*</span>file, <span style=color:#8be9fd>int</span> ret)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> get_info_from_exit(file, <span style=color:#bd93f9>15</span>, ret);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kprobe/ext4_file_open&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> BPF_KPROBE(kprobe_ext4_file_open, <span style=color:#ff79c6>struct</span> inode <span style=color:#ff79c6>*</span>inode, <span style=color:#ff79c6>struct</span> file <span style=color:#ff79c6>*</span>file)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> store_info(file);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kretprobe/ext4_file_open&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> BPF_KRETPROBE(kretprobe_ext4_file_open, <span style=color:#8be9fd>int</span> ret)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> probe_exit(EXT4_FILE_OPEN, ret);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ebpf-发展历史>eBPF 发展历史</h2><p><img src=/images/2023-12-09-ebpf-share/9.jpg alt></p><h2 id=ebpf-帮助文档>eBPF 帮助文档</h2><p>Linux 内核版本中的 BPF 特性，具体可参见 <a href=https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md>https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md</a> 。</p><p><img src=/images/2023-12-09-ebpf-share/10.png alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-frllxehj:~# ls /sys/fs/bpf
</span></span><span style=display:flex><span>root@instance-frllxehj:~# lsmod | grep bpf
</span></span><span style=display:flex><span>bpfilter               <span style=color:#bd93f9>16384</span>  <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>root@instance-frllxehj:~# tplist-bpfcc  --help
</span></span><span style=display:flex><span>usage: tplist-bpfcc <span style=color:#ff79c6>[</span>-h<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>-p PID<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>-l LIB<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>-v<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>filter<span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Display kernel tracepoints or USDT probes and their formats.
</span></span><span style=display:flex><span>root@instance-frllxehj:~# tplist-bpfcc | head -n <span style=color:#bd93f9>20</span>
</span></span><span style=display:flex><span>ib_umad:ib_umad_write
</span></span><span style=display:flex><span>ib_umad:ib_umad_read_recv
</span></span><span style=display:flex><span>ib_umad:ib_umad_read_send
</span></span><span style=display:flex><span>rdma_cma:cm_send_rtu
</span></span><span style=display:flex><span>rdma_cma:cm_send_rej
</span></span><span style=display:flex><span>.....
</span></span></code></pre></div><h2 id=ebpf-限制>eBPF 限制</h2><p>eBPF 并不是万能的，它也有很多的局限性。下面是一些最常见的 eBPF 限制：</p><ul><li>eBPF 程序必须被验证器校验通过后才能执行，且不能包含无法到达的指令；</li><li>eBPF 程序不能随意调用内核函数，只能调用在 API 中定义的辅助函数；</li><li>eBPF 程序栈空间最多只有 512 字节，想要更大的存储，就必须要借助映射存储；</li><li>在内核 5.2 之前，eBPF 字节码最多只支持 4096 条指令，而 5.2 内核把这个限制提高到了 100 万条；</li><li>由于内核的快速变化，在不同版本内核中运行时，需要访问内核数据结构的 eBPF 程序很可能需要调整源码，并重新编译。
此外，虽然 Linux 内核很早就已经支持了 eBPF，但很多新特性都是在 4.x 版本中逐步增加的，想要稳定运行 eBPF 程序，内核版本至少需要 4.9 或者更新。</li></ul><h1 id=pwru-示例>pwru 示例</h1><p>cilium 提供的基于eBPF的Linux内核网络调试器， pwru (packet, where are you?) <a href=https://github.com/cilium/pwru>https://github.com/cilium/pwru</a> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# ./pwru --help
</span></span><span style=display:flex><span>Usage: ./pwru <span style=color:#ff79c6>[</span>options<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>pcap-filter<span style=color:#ff79c6>]</span>
</span></span><span style=display:flex><span>    Available pcap-filter: see <span style=color:#f1fa8c>&#34;man 7 pcap-filter&#34;</span>
</span></span><span style=display:flex><span>    Available options:
</span></span><span style=display:flex><span>      --all-kmods                 attach to all available kernel modules
</span></span><span style=display:flex><span>      --backend string            Tracing backend<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#39;kprobe&#39;</span>, <span style=color:#f1fa8c>&#39;kprobe-multi&#39;</span><span style=color:#ff79c6>)</span>. Will auto-detect <span style=color:#ff79c6>if</span> not specified.
</span></span><span style=display:flex><span>      --filter-func string        filter kernel functions to be probed by name <span style=color:#ff79c6>(</span>exact match, supports RE2 regular expression<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      --filter-ifname string      filter skb ifname in --filter-netns <span style=color:#ff79c6>(</span><span style=color:#ff79c6>if</span> not specified, use current netns<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      --filter-mark uint32        filter skb mark
</span></span><span style=display:flex><span>      --filter-netns string       filter netns <span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;/proc/&lt;pid&gt;/ns/net&#34;</span>, <span style=color:#f1fa8c>&#34;inode:&lt;inode&gt;&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      --filter-trace-tc           trace TC bpf progs
</span></span><span style=display:flex><span>      --filter-track-skb          trace a packet even <span style=color:#ff79c6>if</span> it does not match given filters <span style=color:#ff79c6>(</span>e.g., after NAT or tunnel decapsulation<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>  -h, --help                      display this message and <span style=color:#8be9fd;font-style:italic>exit</span>
</span></span><span style=display:flex><span>      --kernel-btf string         specify kernel BTF file
</span></span><span style=display:flex><span>      --kmods strings             list of kernel modules names to attach to
</span></span><span style=display:flex><span>      --output-file string        write traces to file
</span></span><span style=display:flex><span>      --output-limit-lines uint   <span style=color:#8be9fd;font-style:italic>exit</span> the program after the number of events has been received/printed
</span></span><span style=display:flex><span>      --output-meta               print skb metadata
</span></span><span style=display:flex><span>      --output-skb                print skb
</span></span><span style=display:flex><span>      --output-stack              print stack
</span></span><span style=display:flex><span>      --output-tuple              print L4 tuple
</span></span><span style=display:flex><span>      --timestamp string          print timestamp per skb <span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;current&#34;</span>, <span style=color:#f1fa8c>&#34;relative&#34;</span>, <span style=color:#f1fa8c>&#34;absolute&#34;</span>, <span style=color:#f1fa8c>&#34;none&#34;</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>(</span>default <span style=color:#f1fa8c>&#34;none&#34;</span><span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>      --version                   show pwru version and <span style=color:#8be9fd;font-style:italic>exit</span>
</span></span></code></pre></div><p>以下示例演示了 pwru 展现出快速定位出数据包被 iptables 规则 drop 掉的原因，在不设置 iptables 规则之前，输出如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# ./pwru <span style=color:#f1fa8c>&#39;dst host 1.1.1.1 and tcp and dst port 80&#39;</span>
</span></span><span style=display:flex><span>2024/03/18 11:19:07 Attaching kprobes <span style=color:#ff79c6>(</span>via kprobe<span style=color:#ff79c6>)</span>...
</span></span><span style=display:flex><span><span style=color:#bd93f9>1477</span> / <span style=color:#bd93f9>1477</span> <span style=color:#ff79c6>[</span>---------------------------------------------------------------------------------------------------<span style=color:#ff79c6>]</span> 100.00% <span style=color:#bd93f9>80</span> p/s
</span></span><span style=display:flex><span>2024/03/18 11:19:26 Attached <span style=color:#ff79c6>(</span>ignored 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>2024/03/18 11:19:26 Listening <span style=color:#ff79c6>for</span> events..
</span></span><span style=display:flex><span>               SKB    CPU          PROCESS                     FUNC
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>             ip_local_out
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>           __ip_local_out
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>                ip_output
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>  apparmor_ipv4_postroute
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>         ip_finish_output
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span> __cgroup_bpf_run_filter_skb
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>       __ip_finish_output
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>        ip_finish_output2
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>           dev_queue_xmit
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>         __dev_queue_xmit
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>       qdisc_pkt_len_init
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>      netdev_core_pick_tx
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>           netdev_pick_tx
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>      __get_xps_queue_idx
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>          sch_direct_xmit
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>   validate_xmit_skb_list
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>        validate_xmit_skb
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>       netif_skb_features
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>  passthru_features_check
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>     skb_network_protocol
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>       validate_xmit_vlan
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>  skb_csum_hwoffload_help
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>       validate_xmit_xfrm
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>      dev_hard_start_xmit
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>   skb_clone_tx_timestamp
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>             skb_to_sgvec
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>2</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3378123<span style=color:#ff79c6>)]</span>           __skb_to_sgvec
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         napi_consume_skb
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   skb_release_head_state
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>                tcp_wfree
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         skb_release_data
</span></span><span style=display:flex><span>0xff18015deb5c36e0      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             kfree_skbmem
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             ip_local_out
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           __ip_local_out
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>                ip_output
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>  apparmor_ipv4_postroute
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         ip_finish_output
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span> __cgroup_bpf_run_filter_skb
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>       __ip_finish_output
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>        ip_finish_output2
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           dev_queue_xmit
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         __dev_queue_xmit
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>       qdisc_pkt_len_init
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>      netdev_core_pick_tx
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           netdev_pick_tx
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>      __get_xps_queue_idx
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>          sch_direct_xmit
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   validate_xmit_skb_list
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>        validate_xmit_skb
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>       netif_skb_features
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>  passthru_features_check
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>     skb_network_protocol
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>       validate_xmit_vlan
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>  skb_csum_hwoffload_help
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>       validate_xmit_xfrm
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>      dev_hard_start_xmit
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   skb_clone_tx_timestamp
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             skb_to_sgvec
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>4</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           __skb_to_sgvec
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>1</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         napi_consume_skb
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>1</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   skb_release_head_state
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>1</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             __sock_wfree
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>1</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         skb_release_data
</span></span><span style=display:flex><span>0xff18015e9c940100      <span style=color:#bd93f9>1</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>            skb_free_head
</span></span><span style=display:flex><span>^C2024/03/18 11:19:36 Received signal, exiting program..
</span></span></code></pre></div><p>在设置 iptables 规则之后，输出如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# iptables -t filter -I OUTPUT <span style=color:#bd93f9>1</span> -m tcp --proto tcp --dst 1.1.1.1/32 -j DROP
</span></span><span style=display:flex><span>root@instance-820epr0w:~/tanjunchen# ./pwru <span style=color:#f1fa8c>&#39;dst host 1.1.1.1 and tcp and dst port 80&#39;</span>
</span></span><span style=display:flex><span>2024/03/18 11:22:13 Attaching kprobes <span style=color:#ff79c6>(</span>via kprobe<span style=color:#ff79c6>)</span>...
</span></span><span style=display:flex><span><span style=color:#bd93f9>1477</span> / <span style=color:#bd93f9>1477</span> <span style=color:#ff79c6>[</span>---------------------------------------------------------------------------------------------------<span style=color:#ff79c6>]</span> 100.00% <span style=color:#bd93f9>80</span> p/s
</span></span><span style=display:flex><span>2024/03/18 11:22:31 Attached <span style=color:#ff79c6>(</span>ignored 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>2024/03/18 11:22:31 Listening <span style=color:#ff79c6>for</span> events..
</span></span><span style=display:flex><span>               SKB    CPU          PROCESS                     FUNC
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>             ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>           __ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span> kfree_skb_reason<span style=color:#ff79c6>(</span>SKB_DROP_REASON_NETFILTER_DROP<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>   skb_release_head_state
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>                tcp_wfree
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>         skb_release_data
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>  <span style=color:#ff79c6>[</span>curl<span style=color:#ff79c6>(</span>3381789<span style=color:#ff79c6>)]</span>             kfree_skbmem
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>              __skb_clone
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>        __copy_skb_header
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           __ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span> kfree_skb_reason<span style=color:#ff79c6>(</span>SKB_DROP_REASON_NETFILTER_DROP<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   skb_release_head_state
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>                tcp_wfree
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         skb_release_data
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             kfree_skbmem
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>              __skb_clone
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>        __copy_skb_header
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>           __ip_local_out
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             nf_hook_slow
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span> kfree_skb_reason<span style=color:#ff79c6>(</span>SKB_DROP_REASON_NETFILTER_DROP<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>   skb_release_head_state
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>                tcp_wfree
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>         skb_release_data
</span></span><span style=display:flex><span>0xff180162daa02ae0      <span style=color:#bd93f9>0</span>     <span style=color:#ff79c6>[</span>&lt;empty&gt;<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)]</span>             kfree_skbmem
</span></span><span style=display:flex><span>^C2024/03/18 11:22:43 Received signal, exiting program..
</span></span><span style=display:flex><span>2024/03/18 11:22:43 Detaching kprobes...
</span></span></code></pre></div><p>在 nf_hook_slow 处 kfree_skb_reason(SKB_DROP_REASON_NETFILTER_DROP) 函数被调用，出现了丢包。部分函数的功能如下所示：</p><ol><li><p>ip_local_out和__ip_local_out：这两个函数主要用于处理本地生成的IP数据包，它们将数据包传递给路由子系统以确定数据包的目标，然后将数据包加入到输出队列等待传输。</p></li><li><p>nf_hook_slow：这是netfilter框架中的一个函数，它用于调用在网络钩子上注册的所有函数，以便将数据包传递给它们进行处理。这是实现防火墙功能的关键部分。</p></li><li><p>ip_output：这个函数用于处理需要通过网络接口发送的IP数据包。</p></li><li><p>apparmor_ipv4_postroute：这是AppArmor安全模块的一部分，用于处理路由后的IPv4数据包。</p></li><li><p>ip_finish_output：这个函数负责将路由后的数据包发送到网络接口。</p></li><li><p>__cgroup_bpf_run_filter_skb：这个函数用于运行eBPF程序，处理sk_buff结构的网络数据包。</p></li><li><p>dev_queue_xmit和__dev_queue_xmit：这两个函数负责将数据包加入到设备的发送队列。</p></li><li><p>qdisc_pkt_len_init：这个函数用于初始化数据包的队列规则。</p></li><li><p>netdev_core_pick_tx和netdev_pick_tx：这两个函数用于在多队列网络设备中选择适合发送数据包的队列。</p></li><li><p>__get_xps_queue_idx：此函数用于获取XPS队列索引。</p></li><li><p>sch_direct_xmit：此函数用于直接发送数据包。</p></li><li><p>validate_xmit_skb_list和validate_xmit_skb：这些函数用于验证要发送的数据包的各种特性和条件。</p></li><li><p>netif_skb_features：这个函数用于获取网络设备支持的数据包特性。</p></li><li><p>skb_network_protocol：此函数用于获取数据包的网络协议。</p></li><li><p>dev_hard_start_xmit：此函数用于开始对数据包的硬件传输。</p></li><li><p>skb_clone_tx_timestamp：此函数用于复制数据包的发送时间戳。</p></li><li><p>skb_to_sgvec和__skb_to_sgvec：这两个函数用于将数据包从sk_buff结构转换为scatter/gather向量，用于DMA数据传输。</p></li><li><p>napi_consume_skb：此函数用于在数据包处理完成后释放sk_buff结构。</p></li><li><p>skb_release_head_state和skb_release_data：这两个函数用于释放sk_buff结构的头部和数据部分。</p></li><li><p>tcp_wfree：此函数用于在TCP数据包发送后释放其内存。</p></li><li><p>kfree_skbmem：此函数用于释放sk_buff结构占用的内存。</p></li><li><p>kfree_skb_reason(SKB_DROP_REASON_NETFILTER_DROP)：这个函数用于释放由于被Netfilter（Linux内核网络过滤模块）丢弃的网络数据包所占用的内存资源。SKB_DROP_REASON_NETFILTER_DROP是一个常量，它指示网络数据包是由于Netfilter而被丢弃的。</p></li><li><p>skb_release_head_state：这个函数用于释放网络数据包的头部状态。在网络数据包被处理后，协议栈会调用这个函数来释放数据包头部状态所占用的资源。</p></li><li><p>tcp_wfree：这个函数用于在TCP数据包被发送后释放其内存。在TCP数据包被成功发送后，协议栈会调用这个函数来释放数据包所占用的内存资源。</p></li><li><p>skb_release_data：这个函数用于释放网络数据包的数据部分。在数据包被处理后，协议栈会调用这个函数来释放数据部分所占用的资源。</p></li></ol><p>Kernel 5.15 内核 nf_hook_slow 的源码如下所示：（kfree_skb_reason 是在 5.10 版本的内核中被引入的）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>/* Returns 1 if okfn() needs to be executed by the caller,
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * -EPERM for NF_DROP, 0 otherwise.  Caller must hold rcu_read_lock. */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>nf_hook_slow</span>(<span style=color:#ff79c6>struct</span> sk_buff <span style=color:#ff79c6>*</span>skb, <span style=color:#ff79c6>struct</span> nf_hook_state <span style=color:#ff79c6>*</span>state,
</span></span><span style=display:flex><span>		 <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>struct</span> nf_hook_entries <span style=color:#ff79c6>*</span>e, <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> verdict;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (; s <span style=color:#ff79c6>&lt;</span> e<span style=color:#ff79c6>-&gt;</span>num_hook_entries; s<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>		verdict <span style=color:#ff79c6>=</span> nf_hook_entry_hookfn(<span style=color:#ff79c6>&amp;</span>e<span style=color:#ff79c6>-&gt;</span>hooks[s], skb, state);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>switch</span> (verdict <span style=color:#ff79c6>&amp;</span> NF_VERDICT_MASK) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_ACCEPT</span>:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_DROP</span>:
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 内存 kfree_skb_reason 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			kfree_skb_reason(skb,
</span></span><span style=display:flex><span>					 SKB_DROP_REASON_NETFILTER_DROP);
</span></span><span style=display:flex><span>			ret <span style=color:#ff79c6>=</span> NF_DROP_GETERR(verdict);
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>				ret <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>EPERM;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_QUEUE</span>:
</span></span><span style=display:flex><span>			ret <span style=color:#ff79c6>=</span> nf_queue(skb, state, s, verdict);
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>default</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>			<span style=color:#6272a4>/* Implicit handling for NF_STOLEN, as well as any other
</span></span></span><span style=display:flex><span><span style=color:#6272a4>			 * non conventional verdicts.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>			 */</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kernel 5.10 内核 nf_hook_slow 的源码如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>/* Returns 1 if okfn() needs to be executed by the caller,
</span></span></span><span style=display:flex><span><span style=color:#6272a4> * -EPERM for NF_DROP, 0 otherwise.  Caller must hold rcu_read_lock. */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>nf_hook_slow</span>(<span style=color:#ff79c6>struct</span> sk_buff <span style=color:#ff79c6>*</span>skb, <span style=color:#ff79c6>struct</span> nf_hook_state <span style=color:#ff79c6>*</span>state,
</span></span><span style=display:flex><span>		 <span style=color:#ff79c6>const</span> <span style=color:#ff79c6>struct</span> nf_hook_entries <span style=color:#ff79c6>*</span>e, <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> s)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> verdict;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (; s <span style=color:#ff79c6>&lt;</span> e<span style=color:#ff79c6>-&gt;</span>num_hook_entries; s<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>		verdict <span style=color:#ff79c6>=</span> nf_hook_entry_hookfn(<span style=color:#ff79c6>&amp;</span>e<span style=color:#ff79c6>-&gt;</span>hooks[s], skb, state);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>switch</span> (verdict <span style=color:#ff79c6>&amp;</span> NF_VERDICT_MASK) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_ACCEPT</span>:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_DROP</span>:
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// 内存 kfree_skb  
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>			kfree_skb(skb);
</span></span><span style=display:flex><span>			ret <span style=color:#ff79c6>=</span> NF_DROP_GETERR(verdict);
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>				ret <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>EPERM;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> <span style=color:#8be9fd;font-style:italic>NF_QUEUE</span>:
</span></span><span style=display:flex><span>			ret <span style=color:#ff79c6>=</span> nf_queue(skb, state, s, verdict);
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> (ret <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>continue</span>;
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ret;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>default</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>			<span style=color:#6272a4>/* Implicit handling for NF_STOLEN, as well as any other
</span></span></span><span style=display:flex><span><span style=color:#6272a4>			 * non conventional verdicts.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>			 */</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=实现原理>实现原理</h1><h2 id=执行步骤>执行步骤</h2><p>eBPF 的工作原理主要分为三个步骤：加载、编译和执行。eBPF 需要在内核中运行。这通常是由用户态的应用程序完成的，它会通过系统调用来加载 eBPF 程序。在加载过程中，内核会将 eBPF 程序的代码复制到内核空间。</p><p>eBPF 程序需要经过编译和执行。这通常是由Clang/LLVM的编译器完成，然后形成字节码后，将用户态的字节码装载进内核，Verifier会对要注入内核的程序进行一些内核安全机制的检查,这是为了确保 eBPF 程序不会破坏内核的稳定性和安全性。在检查过程中，内核会对 eBPF 程序的代码进行分析，以确保它不会进行恶意操作，如系统调用、内存访问等。如果 eBPF 程序通过了内核安全机制的检查，它就可以在内核中正常运行了，其会通过一个JIT编译步骤将程序的通用字节码转换为机器特定指令集，以优化程序的执行速度。</p><p><img src=/images/2023-12-09-ebpf-share/11.png alt></p><h2 id=事件与-hook>事件与 hook</h2><p>eBPF 程序是在内核中被事件触发的。在一些特定的指令被执行时时，这些事件会在钩子处被捕获。钩子被触发就会执行 eBPF 程序，对数据进行捕获和操作，钩子定位的多样性正是 eBPF 的闪光点之一。</p><ul><li>系统调用——当用户空间函数将执行转移到内核时插入</li><li>函数进入和退出——拦截对预先存在的函数的调用</li><li>网络事件 – 在收到数据包时执行</li><li>Kprobes 和 uprobes – 附加到内核或用户函数的探测器</li></ul><h2 id=辅助函数>辅助函数</h2><p>eBPF 程序被触发时，会调用辅助函数。这些特别的函数让 eBPF 能够有访问内存的丰富功能。Helper 能够执行一系列的任务：</p><ul><li>在数据表中对键值对进行搜索、更新以及删除。</li><li>搜集和标记隧道元数据。</li><li>把 eBPF 程序连接起来，这个功能被称为 tail call。</li><li>执行 Socket 相关任务，例如绑定、获取 Cookie、数据包重定向等。</li></ul><h2 id=通信媒介---map>通信媒介 - Map</h2><p>要在 eBPF 程序和内核以及用户空间之间存储和共享数据，eBPF 需要使用 Map。正如其名，Map 是一种键值对。eBPF 程序能够通过辅助函数在 Map 中发送和接收数据。它们是通过带有BPF_MAP_CREATE参数的bpf_cmd系统调用来创建的，和Linux世界中的其他东西一样，它们是通过文件描述符来寻址。</p><h2 id=ebpf-虚拟机>eBPF 虚拟机</h2><p>eBPF 是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如 kvm）中的虚拟机弄混。其实，虽然都被称为“虚拟机”，系统虚拟化和 eBPF 虚拟机还是有着本质不同的。</p><p>系统虚拟化基于 x86 或 arm64 等通用指令集，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF 只提供了非常有限的指令集。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF 指令还有意采用了 C 调用约定，其提供的辅助函数可以在 C 语言中直接调用，极大地方便了 eBPF 程序的开发。</p><p><img src=/images/2023-12-09-ebpf-share/12.png alt></p><ul><li>第一个模块是 eBPF 辅助函数。它提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。</li><li>第二个模块是 eBPF 验证器。它用于确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li><li>第三个模块是由 11 个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块。这个模块用于控制 eBPF 程序的执行。其中，R0 寄存器用于存储函数调用和 eBPF 程序的返回值，这意味着函数调用最多只能有一个返回值；R1-R5 寄存器用于函数调用的参数，因此函数调用的参数最多不能超过 5 个；而 R10 则是一个只读寄存器，用于从栈中读取数据。</li><li>第四个模块是即时编译器，它将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。</li><li>第五个模块是 BPF 映射（map），它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。</li></ul><h1 id=核心流程>核心流程</h1><p>如下图所示，通常我们借助 LLVM 把编写的 eBPF 程序转换为 BPF 字节码，然后再通过 bpf 系统调用提交给内核执行。内核在接受 BPF 字节码之前，会首先通过验证器对字节码进行校验，只有校验通过的 BPF 字节码才会提交到即时编译器执行。</p><p><img src=/images/2023-12-09-ebpf-share/13.png alt></p><p><img src=/images/2023-12-09-ebpf-share/14.png alt></p><p>如果 BPF 字节码中包含了不安全的操作，验证器会直接拒绝 BPF 程序的执行。比如，下面就是一些典型的验证过程：</p><ul><li>只有特权进程才可以执行 bpf 系统调用；</li><li>BPF 程序不能包含无限循环；</li><li>BPF 程序不能导致内核崩溃；</li><li>BPF 程序必须在有限时间内完成。</li></ul><p>BPF 程序可以利用 BPF 映射（map）进行存储，而用户程序通常也需要通过 BPF 映射同运行在内核中的 BPF 程序进行交互。如图所示，在性能观测中，BPF 程序收集内核运行状态存储在映射中，用户程序再从映射中读出这些状态。可以看到，eBPF 程序的运行需要历经编译、加载、验证和内核态执行等过程，而用户态程序则需要借助 BPF 映射来获取内核态 eBPF 程序的运行状态。</p><h1 id=工具链>工具链</h1><h2 id=bcc>BCC</h2><p>BCC 用于基于 BPF 的 Linux IO 分析、网络、监控等的工具，项目源代码见 <a href=https://github.com/iovisor/bcc>https://github.com/iovisor/bcc</a>。不过，BCC 也不是完美的，它依赖于 LLVM 和内核头文件才可以动态编译和加载 eBPF 程序。</p><p><img src=/images/2023-12-09-ebpf-share/15.png alt></p><p>以下示例用于解析 HTTP 数据包并提取（并在屏幕上打印）GET/POST 请求中包含的 URL。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;uapi/linux/ptrace.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;net/sock.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bcc/proto.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#define IP_TCP 	6
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#define ETH_HLEN 14
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> Key {
</span></span><span style=display:flex><span>	u32 src_ip;               <span style=color:#6272a4>//source ip
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	u32 dst_ip;               <span style=color:#6272a4>//destination ip
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>short</span> src_port;  <span style=color:#6272a4>//source port
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>short</span> dst_port;  <span style=color:#6272a4>//destination port
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> Leaf {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> timestamp;            <span style=color:#6272a4>//timestamp in ns
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//BPF_TABLE(map_type, key_type, leaf_type, table_name, num_entry)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//map &lt;Key, Leaf&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//tracing sessions having same Key(dst_ip, src_ip, dst_port,src_port)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>BPF_HASH(sessions, <span style=color:#ff79c6>struct</span> Key, <span style=color:#ff79c6>struct</span> Leaf, <span style=color:#bd93f9>1024</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/*eBPF program.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  Filter IP and TCP packets, having payload not empty
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  and containing &#34;HTTP&#34;, &#34;GET&#34;, &#34;POST&#34;  as first bytes of payload.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  AND ALL the other packets having same (src_ip,dst_ip,src_port,dst_port)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  this means belonging to the same &#34;session&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  this additional check avoids url truncation, if url is too long
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  userspace script, if necessary, reassembles urls split in 2 or more packets.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  if the program is loaded as PROG_TYPE_SOCKET_FILTER
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  and attached to a socket
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  return  0 -&gt; DROP the packet
</span></span></span><span style=display:flex><span><span style=color:#6272a4>  return -1 -&gt; KEEP the packet and return it to user space (userspace can read it from the socket_fd )
</span></span></span><span style=display:flex><span><span style=color:#6272a4>*/</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>http_filter</span>(<span style=color:#ff79c6>struct</span> __sk_buff <span style=color:#ff79c6>*</span>skb) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	u8 <span style=color:#ff79c6>*</span>cursor <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> ethernet_t <span style=color:#ff79c6>*</span>ethernet <span style=color:#ff79c6>=</span> cursor_advance(cursor, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>ethernet));
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//filter IP packets (ethernet type = 0x0800)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>(ethernet<span style=color:#ff79c6>-&gt;</span>type <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0x0800</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> DROP;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> ip_t <span style=color:#ff79c6>*</span>ip <span style=color:#ff79c6>=</span> cursor_advance(cursor, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>ip));
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//filter TCP packets (ip next protocol = 0x06)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> (ip<span style=color:#ff79c6>-&gt;</span>nextp <span style=color:#ff79c6>!=</span> IP_TCP) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> DROP;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	u32  tcp_header_length <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	u32  ip_header_length <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	u32  payload_offset <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	u32  payload_length <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Key 	key;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> Leaf zero <span style=color:#ff79c6>=</span> {<span style=color:#bd93f9>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//calculate ip header length
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//value to multiply * 4
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>//e.g. ip-&gt;hlen = 5 ; IP Header Length = 5 x 4 byte = 20 byte
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        ip_header_length <span style=color:#ff79c6>=</span> ip<span style=color:#ff79c6>-&gt;</span>hlen <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#bd93f9>2</span>;    <span style=color:#6272a4>//SHL 2 -&gt; *4 multiply
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//check ip header length against minimum
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>if</span> (ip_header_length <span style=color:#ff79c6>&lt;</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>ip)) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>goto</span> DROP;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>//shift cursor forward for dynamic ip header size
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>_ <span style=color:#ff79c6>=</span> cursor_advance(cursor, (ip_header_length<span style=color:#ff79c6>-</span><span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>ip)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> tcp_t <span style=color:#ff79c6>*</span>tcp <span style=color:#ff79c6>=</span> cursor_advance(cursor, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>*</span>tcp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//retrieve ip src/dest and port src/dest of current packet
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//and save it into struct Key
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	key.dst_ip <span style=color:#ff79c6>=</span> ip<span style=color:#ff79c6>-&gt;</span>dst;
</span></span><span style=display:flex><span>	key.src_ip <span style=color:#ff79c6>=</span> ip<span style=color:#ff79c6>-&gt;</span>src;
</span></span><span style=display:flex><span>	key.dst_port <span style=color:#ff79c6>=</span> tcp<span style=color:#ff79c6>-&gt;</span>dst_port;
</span></span><span style=display:flex><span>	key.src_port <span style=color:#ff79c6>=</span> tcp<span style=color:#ff79c6>-&gt;</span>src_port;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//calculate tcp header length
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//value to multiply *4
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//e.g. tcp-&gt;offset = 5 ; TCP Header Length = 5 x 4 byte = 20 byte
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	tcp_header_length <span style=color:#ff79c6>=</span> tcp<span style=color:#ff79c6>-&gt;</span>offset <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#bd93f9>2</span>; <span style=color:#6272a4>//SHL 2 -&gt; *4 multiply
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//calculate payload offset and length
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	payload_offset <span style=color:#ff79c6>=</span> ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> tcp_header_length;
</span></span><span style=display:flex><span>	payload_length <span style=color:#ff79c6>=</span> ip<span style=color:#ff79c6>-&gt;</span>tlen <span style=color:#ff79c6>-</span> ip_header_length <span style=color:#ff79c6>-</span> tcp_header_length;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//http://stackoverflow.com/questions/25047905/http-request-minimum-size-in-bytes
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//minimum length of http request is always geater than 7 bytes
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//avoid invalid access memory
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//include empty payload
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span>(payload_length <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>7</span>) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> DROP;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//load first 7 byte of payload into p (payload_array)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//direct access to skb not allowed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> p[<span style=color:#bd93f9>7</span>];
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>7</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>		p[i] <span style=color:#ff79c6>=</span> load_byte(skb, payload_offset <span style=color:#ff79c6>+</span> i);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//find a match with an HTTP message
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//HTTP
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;H&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;P&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//GET
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;G&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;E&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//POST
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;P&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;O&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;S&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//PUT
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;P&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;U&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//DELETE
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;D&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;E&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;L&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;E&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>4</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;T&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>5</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;E&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//HEAD
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> ((p[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;H&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>1</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;E&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>2</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;A&#39;</span>) <span style=color:#ff79c6>&amp;&amp;</span> (p[<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;D&#39;</span>)) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> HTTP_MATCH;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//no HTTP match
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//check if packet belong to an HTTP session
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>struct</span> Leaf <span style=color:#ff79c6>*</span> lookup_leaf <span style=color:#ff79c6>=</span> sessions.lookup(<span style=color:#ff79c6>&amp;</span>key);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span>(lookup_leaf) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>//send packet to userspace
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>goto</span> KEEP;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>goto</span> DROP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//keep the packet and send it to userspace returning -1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>HTTP_MATCH</span>:
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//if not already present, insert into map &lt;Key, Leaf&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	sessions.lookup_or_try_init(<span style=color:#ff79c6>&amp;</span>key,<span style=color:#ff79c6>&amp;</span>zero);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//send packet to userspace returning -1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>KEEP</span>:
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>//drop the packet returning 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#8be9fd;font-style:italic>DROP</span>:
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4>#!/usr/bin/python</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Bertrone Matteo - Polytechnic of Turin</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># November 2015</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># eBPF application that parses HTTP packets</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># and extracts (and prints on screen) the URL</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># contained in the GET/POST request.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># eBPF program http_filter is used as SOCKET_FILTER attached to eth0 interface.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Only packets of type ip and tcp containing HTTP GET/POST are</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># returned to userspace, others dropped</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Python script uses bcc BPF Compiler Collection by</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># iovisor (https://github.com/iovisor/bcc) and prints on stdout the first</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># line of the HTTP GET/POST request containing the url</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> __future__ <span style=color:#ff79c6>import</span> print_function
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> bcc <span style=color:#ff79c6>import</span> BPF
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> sys <span style=color:#ff79c6>import</span> argv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> socket
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> os
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> binascii
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CLEANUP_N_PACKETS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>50</span>     <span style=color:#6272a4># cleanup every CLEANUP_N_PACKETS packets received</span>
</span></span><span style=display:flex><span>MAX_URL_STRING_LEN <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>8192</span>  <span style=color:#6272a4># max url string len (usually 8K)</span>
</span></span><span style=display:flex><span>MAX_AGE_SECONDS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>30</span>       <span style=color:#6272a4># max age entry in bpf_sessions map</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># print str until CR+LF</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>printUntilCRLF</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(s<span style=color:#ff79c6>.</span>split(<span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>\r\n</span><span style=color:#f1fa8c>&#39;</span>)[<span style=color:#bd93f9>0</span>]<span style=color:#ff79c6>.</span>decode())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># cleanup function</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>cleanup</span>():
</span></span><span style=display:flex><span>    <span style=color:#6272a4># get current time in seconds</span>
</span></span><span style=display:flex><span>    current_time <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>int</span>(time<span style=color:#ff79c6>.</span>time())
</span></span><span style=display:flex><span>    <span style=color:#6272a4># looking for leaf having:</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># timestap  == 0        --&gt; update with current timestamp</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># AGE &gt; MAX_AGE_SECONDS --&gt; delete item</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> key, leaf <span style=color:#ff79c6>in</span> bpf_sessions<span style=color:#ff79c6>.</span>items():
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>            current_leaf <span style=color:#ff79c6>=</span> bpf_sessions[key]
</span></span><span style=display:flex><span>            <span style=color:#6272a4># set timestamp if timestamp == 0</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (current_leaf<span style=color:#ff79c6>.</span>timestamp <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>):
</span></span><span style=display:flex><span>                bpf_sessions[key] <span style=color:#ff79c6>=</span> bpf_sessions<span style=color:#ff79c6>.</span>Leaf(current_time)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># delete older entries</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (current_time <span style=color:#ff79c6>-</span> current_leaf<span style=color:#ff79c6>.</span>timestamp <span style=color:#ff79c6>&gt;</span> MAX_AGE_SECONDS):
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>del</span> bpf_sessions[key]
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;cleanup exception.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># args</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>usage</span>():
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;USAGE: </span><span style=color:#f1fa8c>%s</span><span style=color:#f1fa8c> [-i &lt;if_name&gt;]&#34;</span> <span style=color:#ff79c6>%</span> argv[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;Try &#39;</span><span style=color:#f1fa8c>%s</span><span style=color:#f1fa8c> -h&#39; for more options.&#34;</span> <span style=color:#ff79c6>%</span> argv[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>    exit()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># help</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>help</span>():
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;USAGE: </span><span style=color:#f1fa8c>%s</span><span style=color:#f1fa8c> [-i &lt;if_name&gt;]&#34;</span> <span style=color:#ff79c6>%</span> argv[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;optional arguments:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;   -h                       print this help&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;   -i if_name               select interface if_name. Default is eth0&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;examples:&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;    http-parse              # bind socket to eth0&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;    http-parse -i wlan0     # bind socket to wlan0&#34;</span>)
</span></span><span style=display:flex><span>    exit()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># arguments</span>
</span></span><span style=display:flex><span>interface <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;eth0&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(argv) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>2</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>str</span>(argv[<span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;-h&#39;</span>:
</span></span><span style=display:flex><span>        help()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        usage()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(argv) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>3</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>str</span>(argv[<span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#39;-i&#39;</span>:
</span></span><span style=display:flex><span>        interface <span style=color:#ff79c6>=</span> argv[<span style=color:#bd93f9>2</span>]
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        usage()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(argv) <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>3</span>:
</span></span><span style=display:flex><span>    usage()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;binding socket to &#39;</span><span style=color:#f1fa8c>%s</span><span style=color:#f1fa8c>&#39;&#34;</span> <span style=color:#ff79c6>%</span> interface)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># initialize BPF - load source code from http-parse-complete.c</span>
</span></span><span style=display:flex><span>bpf <span style=color:#ff79c6>=</span> BPF(src_file<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;http-parse-complete.c&#34;</span>, debug<span style=color:#ff79c6>=</span><span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># load eBPF program http_filter of type SOCKET_FILTER into the kernel eBPF vm</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># more info about eBPF program types</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># http://man7.org/linux/man-pages/man2/bpf.2.html</span>
</span></span><span style=display:flex><span>function_http_filter <span style=color:#ff79c6>=</span> bpf<span style=color:#ff79c6>.</span>load_func(<span style=color:#f1fa8c>&#34;http_filter&#34;</span>, BPF<span style=color:#ff79c6>.</span>SOCKET_FILTER)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># create raw socket, bind it to interface</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># attach bpf program to socket created</span>
</span></span><span style=display:flex><span>BPF<span style=color:#ff79c6>.</span>attach_raw_socket(function_http_filter, interface)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># get file descriptor of the socket previously</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># created inside BPF.attach_raw_socket</span>
</span></span><span style=display:flex><span>socket_fd <span style=color:#ff79c6>=</span> function_http_filter<span style=color:#ff79c6>.</span>sock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># create python socket object, from the file descriptor</span>
</span></span><span style=display:flex><span>sock <span style=color:#ff79c6>=</span> socket<span style=color:#ff79c6>.</span>fromfd(socket_fd, socket<span style=color:#ff79c6>.</span>PF_PACKET,
</span></span><span style=display:flex><span>                     socket<span style=color:#ff79c6>.</span>SOCK_RAW, socket<span style=color:#ff79c6>.</span>IPPROTO_IP)
</span></span><span style=display:flex><span><span style=color:#6272a4># set it as blocking socket</span>
</span></span><span style=display:flex><span>sock<span style=color:#ff79c6>.</span>setblocking(<span style=color:#ff79c6>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># get pointer to bpf map of type hash</span>
</span></span><span style=display:flex><span>bpf_sessions <span style=color:#ff79c6>=</span> bpf<span style=color:#ff79c6>.</span>get_table(<span style=color:#f1fa8c>&#34;sessions&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># packets counter</span>
</span></span><span style=display:flex><span>packet_count <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># dictionary containing association</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># &lt;key(ipsrc,ipdst,portsrc,portdst),payload_string&gt;.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># if url is not entirely contained in only one packet,</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># save the firt part of it in this local dict</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># when I find \r\n in a next pkt, append and print the whole url</span>
</span></span><span style=display:flex><span>local_dictionary <span style=color:#ff79c6>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span> <span style=color:#bd93f9>1</span>:
</span></span><span style=display:flex><span>    <span style=color:#6272a4># retrieve raw packet from socket</span>
</span></span><span style=display:flex><span>    packet_str <span style=color:#ff79c6>=</span> os<span style=color:#ff79c6>.</span>read(socket_fd, <span style=color:#bd93f9>4096</span>)  <span style=color:#6272a4># set packet length to max packet length on the interface</span>
</span></span><span style=display:flex><span>    packet_count <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># DEBUG - print raw packet in hex format</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># packet_hex = binascii.hexlify(packet_str)</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># print (&#34;%s&#34; % packet_hex)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># convert packet into bytearray</span>
</span></span><span style=display:flex><span>    packet_bytearray <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>bytearray</span>(packet_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># ethernet header length</span>
</span></span><span style=display:flex><span>    ETH_HLEN <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>14</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># IP HEADER</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># https://tools.ietf.org/html/rfc791</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># |Version|  IHL  |Type of Service|          Total Length         |</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># IHL : Internet Header Length is the length of the internet header</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># value to multiply * 4 byte</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># e.g. IHL = 5 ; IP Header Length = 5 * 4 byte = 20 byte</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># Total length: This 16-bit field defines the entire packet size,</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># including header and data, in bytes.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate packet total length</span>
</span></span><span style=display:flex><span>    total_length <span style=color:#ff79c6>=</span> packet_bytearray[ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>2</span>]                 <span style=color:#6272a4># load MSB</span>
</span></span><span style=display:flex><span>    total_length <span style=color:#ff79c6>=</span> total_length <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#bd93f9>8</span>                              <span style=color:#6272a4># shift MSB</span>
</span></span><span style=display:flex><span>    total_length <span style=color:#ff79c6>=</span> total_length <span style=color:#ff79c6>+</span> packet_bytearray[ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span>]  <span style=color:#6272a4># add LSB</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate ip header length</span>
</span></span><span style=display:flex><span>    ip_header_length <span style=color:#ff79c6>=</span> packet_bytearray[ETH_HLEN]     <span style=color:#6272a4># load Byte</span>
</span></span><span style=display:flex><span>    ip_header_length <span style=color:#ff79c6>=</span> ip_header_length <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>0x0F</span>        <span style=color:#6272a4># mask bits 0..3</span>
</span></span><span style=display:flex><span>    ip_header_length <span style=color:#ff79c6>=</span> ip_header_length <span style=color:#ff79c6>&lt;&lt;</span> <span style=color:#bd93f9>2</span>          <span style=color:#6272a4># shift to obtain length</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># retrieve ip source/dest</span>
</span></span><span style=display:flex><span>    ip_src_str <span style=color:#ff79c6>=</span> packet_str[ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>12</span>: ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>16</span>]  <span style=color:#6272a4># ip source offset 12..15</span>
</span></span><span style=display:flex><span>    ip_dst_str <span style=color:#ff79c6>=</span> packet_str[ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>16</span>:ETH_HLEN <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>20</span>]   <span style=color:#6272a4># ip dest   offset 16..19</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ip_src <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>int</span>(binascii<span style=color:#ff79c6>.</span>hexlify(ip_src_str), <span style=color:#bd93f9>16</span>)
</span></span><span style=display:flex><span>    ip_dst <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>int</span>(binascii<span style=color:#ff79c6>.</span>hexlify(ip_dst_str), <span style=color:#bd93f9>16</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># TCP HEADER</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># https://www.rfc-editor.org/rfc/rfc793.txt</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#  12              13              14              15</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># |  Data |           |U|A|P|R|S|F|                               |</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># | Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># |       |           |G|K|H|T|N|N|                               |</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>#</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># Data Offset: This indicates where the data begins.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># The TCP header is an integral number of 32 bits long.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># value to multiply * 4 byte</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># e.g. DataOffset = 5 ; TCP Header Length = 5 * 4 byte = 20 byte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate tcp header length</span>
</span></span><span style=display:flex><span>    tcp_header_length <span style=color:#ff79c6>=</span> packet_bytearray[ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>12</span>]  <span style=color:#6272a4># load Byte</span>
</span></span><span style=display:flex><span>    tcp_header_length <span style=color:#ff79c6>=</span> tcp_header_length <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>0xF0</span>    <span style=color:#6272a4># mask bit 4..7</span>
</span></span><span style=display:flex><span>    tcp_header_length <span style=color:#ff79c6>=</span> tcp_header_length <span style=color:#ff79c6>&gt;&gt;</span> <span style=color:#bd93f9>2</span>      <span style=color:#6272a4># SHR 4 ; SHL 2 -&gt; SHR 2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># retrieve port source/dest</span>
</span></span><span style=display:flex><span>    port_src_str <span style=color:#ff79c6>=</span> packet_str[ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length:ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>2</span>]
</span></span><span style=display:flex><span>    port_dst_str <span style=color:#ff79c6>=</span> packet_str[ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>2</span>:ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>4</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    port_src <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>int</span>(binascii<span style=color:#ff79c6>.</span>hexlify(port_src_str), <span style=color:#bd93f9>16</span>)
</span></span><span style=display:flex><span>    port_dst <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>int</span>(binascii<span style=color:#ff79c6>.</span>hexlify(port_dst_str), <span style=color:#bd93f9>16</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># calculate payload offset</span>
</span></span><span style=display:flex><span>    payload_offset <span style=color:#ff79c6>=</span> ETH_HLEN <span style=color:#ff79c6>+</span> ip_header_length <span style=color:#ff79c6>+</span> tcp_header_length
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># payload_string contains only packet payload</span>
</span></span><span style=display:flex><span>    payload_string <span style=color:#ff79c6>=</span> packet_str[(payload_offset):(<span style=color:#8be9fd;font-style:italic>len</span>(packet_bytearray))]
</span></span><span style=display:flex><span>    <span style=color:#6272a4># CR + LF (substring to find)</span>
</span></span><span style=display:flex><span>    crlf <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;</span><span style=color:#f1fa8c>\r\n</span><span style=color:#f1fa8c>&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># current_Key contains ip source/dest and port source/map</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># useful for direct bpf_sessions map access</span>
</span></span><span style=display:flex><span>    current_Key <span style=color:#ff79c6>=</span> bpf_sessions<span style=color:#ff79c6>.</span>Key(ip_src, ip_dst, port_src, port_dst)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># looking for HTTP GET/POST request</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> ((payload_string[:<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;GET&#39;</span>) <span style=color:#ff79c6>or</span> (payload_string[:<span style=color:#bd93f9>4</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;POST&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>or</span> (payload_string[:<span style=color:#bd93f9>4</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;HTTP&#39;</span>) <span style=color:#ff79c6>or</span> (payload_string[:<span style=color:#bd93f9>3</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;PUT&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>or</span> (payload_string[:<span style=color:#bd93f9>6</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;DELETE&#39;</span>) <span style=color:#ff79c6>or</span> (payload_string[:<span style=color:#bd93f9>4</span>] <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>b</span><span style=color:#f1fa8c>&#39;HEAD&#39;</span>)):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># match: HTTP GET/POST packet found</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (crlf <span style=color:#ff79c6>in</span> payload_string):
</span></span><span style=display:flex><span>            <span style=color:#6272a4># url entirely contained in first packet -&gt; print it all</span>
</span></span><span style=display:flex><span>            printUntilCRLF(payload_string)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># delete current_Key from bpf_sessions, url already printed.</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># current session not useful anymore</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>del</span> bpf_sessions[current_Key]
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;error during delete from bpf map &#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#6272a4># url NOT entirely contained in first packet</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># not found \r\n in payload.</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># save current part of the payload_string in dictionary</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># &lt;key(ips,ipd,ports,portd),payload_string&gt;</span>
</span></span><span style=display:flex><span>            local_dictionary[binascii<span style=color:#ff79c6>.</span>hexlify(current_Key)] <span style=color:#ff79c6>=</span> payload_string
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#6272a4># NO match: HTTP GET/POST  NOT found</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># check if the packet belong to a session saved in bpf_sessions</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (current_Key <span style=color:#ff79c6>in</span> bpf_sessions):
</span></span><span style=display:flex><span>            <span style=color:#6272a4># check id the packet belong to a session saved in local_dictionary</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># (local_dictionary maintains HTTP GET/POST url not</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4># printed yet because split in N packets)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> (binascii<span style=color:#ff79c6>.</span>hexlify(current_Key) <span style=color:#ff79c6>in</span> local_dictionary):
</span></span><span style=display:flex><span>                <span style=color:#6272a4># first part of the HTTP GET/POST url is already present in</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4># local dictionary (prev_payload_string)</span>
</span></span><span style=display:flex><span>                prev_payload_string <span style=color:#ff79c6>=</span> local_dictionary[binascii<span style=color:#ff79c6>.</span>hexlify(current_Key)]
</span></span><span style=display:flex><span>                <span style=color:#6272a4># looking for CR+LF in current packet.</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (crlf <span style=color:#ff79c6>in</span> payload_string):
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># last packet. containing last part of HTTP GET/POST</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># url split in N packets. Append current payload</span>
</span></span><span style=display:flex><span>                    prev_payload_string <span style=color:#ff79c6>+=</span> payload_string
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># print HTTP GET/POST url</span>
</span></span><span style=display:flex><span>                    printUntilCRLF(prev_payload_string)
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># clean bpf_sessions &amp; local_dictionary</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>del</span> bpf_sessions[current_Key]
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>del</span> local_dictionary[binascii<span style=color:#ff79c6>.</span>hexlify(current_Key)]
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>                        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;error deleting from map or dictionary&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># NOT last packet. Containing part of HTTP GET/POST url</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># split in N packets.</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># Append current payload</span>
</span></span><span style=display:flex><span>                    prev_payload_string <span style=color:#ff79c6>+=</span> payload_string
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># check if not size exceeding</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># (usually HTTP GET/POST url &lt; 8K )</span>
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> (<span style=color:#8be9fd;font-style:italic>len</span>(prev_payload_string) <span style=color:#ff79c6>&gt;</span> MAX_URL_STRING_LEN):
</span></span><span style=display:flex><span>                        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;url too long&#34;</span>)
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>                            <span style=color:#ff79c6>del</span> bpf_sessions[current_Key]
</span></span><span style=display:flex><span>                            <span style=color:#ff79c6>del</span> local_dictionary[binascii<span style=color:#ff79c6>.</span>hexlify(current_Key)]
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>                            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;error deleting from map or dict&#34;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#6272a4># update dictionary</span>
</span></span><span style=display:flex><span>                    local_dictionary[binascii<span style=color:#ff79c6>.</span>hexlify(current_Key)] <span style=color:#ff79c6>=</span> prev_payload_string
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#6272a4># first part of the HTTP GET/POST url is</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4># NOT present in local dictionary</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4># bpf_sessions contains invalid entry -&gt; delete it</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>try</span>:
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>del</span> bpf_sessions[current_Key]
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>except</span>:
</span></span><span style=display:flex><span>                    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;error del bpf_session&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># check if dirty entry are present in bpf_sessions</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (((packet_count) <span style=color:#ff79c6>%</span> CLEANUP_N_PACKETS) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>):
</span></span><span style=display:flex><span>        cleanup()
</span></span></code></pre></div><h2 id=bpftrace>bpftrace</h2><p>用于 Linux eBPF 的高级跟踪语言（基于 BCC 与 libbpf），项目源代码见 <a href=https://github.com/iovisor/bpftrace>https://github.com/iovisor/bpftrace</a>。</p><p>bpftrace 是一种用于 Linux eBPF 的高级跟踪语言，在新的 Linux内核（4.x）中可用。bpftrace 使用 LLVM 作为后端，将脚本编译为 eBPF 字节码，并利用 BCC 与 Linux eBPF 子系统交互，以及现有的 Linux 跟踪功能如内核动态跟踪（kprobes）、用户级动态跟踪（uprobes）和跟踪点（tracepoints）。</p><p>bpftrace 通常用在快速排查和定位系统上，它支持用单行脚本的方式来快速开发并执行一个 eBPF 程序。</p><p><img src=/images/2023-12-09-ebpf-share/16.png alt></p><p>以下示例使用 bpftrace 跟踪 TCP 生命周期。TCP 常见的连接状态 CLOSE、SYN_SENT、ESTABLISHED、FIN_WAIT1、FIN_WAIT2。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff79c6>#!/usr/bin/env bpftrace
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>/*
</span></span><span style=display:flex><span> * tcplife - Trace TCP session lifespans with connection details.
</span></span><span style=display:flex><span> *
</span></span><span style=display:flex><span> * See BPF Performance Tools, Chapter 10, <span style=color:#ff79c6>for</span> an explanation of this tool.
</span></span><span style=display:flex><span> *
</span></span><span style=display:flex><span> * Copyright <span style=color:#ff79c6>(</span>c<span style=color:#ff79c6>)</span> <span style=color:#bd93f9>2019</span> Brendan Gregg.
</span></span><span style=display:flex><span> * Licensed under the Apache License, Version 2.0 <span style=color:#ff79c6>(</span>the <span style=color:#f1fa8c>&#34;License&#34;</span><span style=color:#ff79c6>)</span>.
</span></span><span style=display:flex><span> * This was originally created <span style=color:#ff79c6>for</span> the BPF Performance Tools book
</span></span><span style=display:flex><span> * published by Addison Wesley. ISBN-13: <span style=color:#bd93f9>9780136554820</span>
</span></span><span style=display:flex><span> * When copying or porting, include this comment.
</span></span><span style=display:flex><span> *
</span></span><span style=display:flex><span> * 17-Apr-2019  Brendan Gregg   Created this.
</span></span><span style=display:flex><span> */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#ifndef BPFTRACE_HAVE_BTF</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;net/tcp_states.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;net/sock.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;linux/socket.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;linux/tcp.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#else</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#include &lt;sys/socket.h&gt;</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>#endif</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span><span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	printf<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;%-5s %-10s %-15s %-5s %-15s %-5s &#34;</span>, <span style=color:#f1fa8c>&#34;PID&#34;</span>, <span style=color:#f1fa8c>&#34;COMM&#34;</span>,
</span></span><span style=display:flex><span>	    <span style=color:#f1fa8c>&#34;LADDR&#34;</span>, <span style=color:#f1fa8c>&#34;LPORT&#34;</span>, <span style=color:#f1fa8c>&#34;RADDR&#34;</span>, <span style=color:#f1fa8c>&#34;RPORT&#34;</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>	printf<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;%5s %5s %s\n&#34;</span>, <span style=color:#f1fa8c>&#34;TX_KB&#34;</span>, <span style=color:#f1fa8c>&#34;RX_KB&#34;</span>, <span style=color:#f1fa8c>&#34;MS&#34;</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kprobe:tcp_set_state
</span></span><span style=display:flex><span><span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>$sk</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>struct sock *<span style=color:#ff79c6>)</span>arg0;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>$newstate</span> <span style=color:#ff79c6>=</span> arg1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	/*
</span></span><span style=display:flex><span>	 * This tool includes PID and comm context. From TCP this is best
</span></span><span style=display:flex><span>	 * effort, and may be wrong in some situations. It does this:
</span></span><span style=display:flex><span>	 * - record timestamp on any state &lt; TCP_FIN_WAIT1
</span></span><span style=display:flex><span>	 *	note some state transitions may not be present via this kprobe
</span></span><span style=display:flex><span>	 * - cache task context on:
</span></span><span style=display:flex><span>	 *	TCP_SYN_SENT: tracing from client
</span></span><span style=display:flex><span>	 *	TCP_LAST_ACK: client-closed from server
</span></span><span style=display:flex><span>	 * - <span style=color:#ff79c6>do</span> output on TCP_CLOSE:
</span></span><span style=display:flex><span>	 *	fetch task context <span style=color:#ff79c6>if</span> cached, or use current task
</span></span><span style=display:flex><span>	 */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// record first timestamp seen <span style=color:#ff79c6>for</span> this socket
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$newstate</span> &lt; TCP_FIN_WAIT1 <span style=color:#ff79c6>&amp;&amp;</span> @birth<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		@birth<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> nsecs;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// record PID &amp; comm on SYN_SENT
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$newstate</span> <span style=color:#ff79c6>==</span> TCP_SYN_SENT <span style=color:#ff79c6>||</span> <span style=color:#8be9fd;font-style:italic>$newstate</span> <span style=color:#ff79c6>==</span> TCP_LAST_ACK<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		@skpid<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> pid;
</span></span><span style=display:flex><span>		@skcomm<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span> <span style=color:#ff79c6>=</span> comm;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// session ended: calculate lifespan and print
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$newstate</span> <span style=color:#ff79c6>==</span> TCP_CLOSE <span style=color:#ff79c6>&amp;&amp;</span> @birth<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>])</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$delta_ms</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>nsecs - @birth<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>])</span> / 1e6;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$lport</span> <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_num;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$dport</span> <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_dport;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$dport</span> <span style=color:#ff79c6>=</span> bswap<span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$dport</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$tp</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>struct tcp_sock *<span style=color:#ff79c6>)</span><span style=color:#8be9fd;font-style:italic>$sk</span>;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$pid</span> <span style=color:#ff79c6>=</span> @skpid<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$comm</span> <span style=color:#ff79c6>=</span> @skcomm<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>]</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$comm</span> <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;&#34;</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>			// not cached, use current task
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$pid</span> <span style=color:#ff79c6>=</span> pid;
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$comm</span> <span style=color:#ff79c6>=</span> comm;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$family</span> <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_family;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$saddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>$daddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>0<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span><span style=color:#8be9fd;font-style:italic>$family</span> <span style=color:#ff79c6>==</span> AF_INET<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$saddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>AF_INET, <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_rcv_saddr<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$daddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>AF_INET, <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_daddr<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>}</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>			// AF_INET6
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$saddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>AF_INET6,
</span></span><span style=display:flex><span>			    <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>			<span style=color:#8be9fd;font-style:italic>$daddr</span> <span style=color:#ff79c6>=</span> ntop<span style=color:#ff79c6>(</span>AF_INET6,
</span></span><span style=display:flex><span>			    <span style=color:#8be9fd;font-style:italic>$sk</span>-&gt;__sk_common.skc_v6_daddr.in6_u.u6_addr8<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>		printf<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;%-5d %-10.10s %-15s %-5d %-15s %-6d &#34;</span>, <span style=color:#8be9fd;font-style:italic>$pid</span>,
</span></span><span style=display:flex><span>		    <span style=color:#8be9fd;font-style:italic>$comm</span>, <span style=color:#8be9fd;font-style:italic>$saddr</span>, <span style=color:#8be9fd;font-style:italic>$lport</span>, <span style=color:#8be9fd;font-style:italic>$daddr</span>, <span style=color:#8be9fd;font-style:italic>$dport</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>		printf<span style=color:#ff79c6>(</span><span style=color:#f1fa8c>&#34;%5d %5d %d\n&#34;</span>, <span style=color:#8be9fd;font-style:italic>$tp</span>-&gt;bytes_acked / 1024,
</span></span><span style=display:flex><span>		    <span style=color:#8be9fd;font-style:italic>$tp</span>-&gt;bytes_received / 1024, <span style=color:#8be9fd;font-style:italic>$delta_ms</span><span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		delete<span style=color:#ff79c6>(</span>@birth<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>])</span>;
</span></span><span style=display:flex><span>		delete<span style=color:#ff79c6>(</span>@skpid<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>])</span>;
</span></span><span style=display:flex><span>		delete<span style=color:#ff79c6>(</span>@skcomm<span style=color:#ff79c6>[</span><span style=color:#8be9fd;font-style:italic>$sk</span><span style=color:#ff79c6>])</span>;
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END
</span></span><span style=display:flex><span><span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>	clear<span style=color:#ff79c6>(</span>@birth<span style=color:#ff79c6>)</span>; clear<span style=color:#ff79c6>(</span>@skpid<span style=color:#ff79c6>)</span>; clear<span style=color:#ff79c6>(</span>@skcomm<span style=color:#ff79c6>)</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Demonstrations of tcplife, the Linux bpftrace/eBPF version.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>This tool shows the lifespan of TCP sessions, including througphut statistics,
</span></span><span style=display:flex><span>and <span style=color:#ff79c6>for</span> efficiency only instruments TCP state changes <span style=color:#ff79c6>(</span>rather than all packets<span style=color:#ff79c6>)</span>.
</span></span><span style=display:flex><span>For example:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># ./tcplife.bt</span>
</span></span><span style=display:flex><span>PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
</span></span><span style=display:flex><span><span style=color:#bd93f9>20976</span> ssh        127.0.0.1       <span style=color:#bd93f9>56766</span> 127.0.0.1       <span style=color:#bd93f9>22</span>         <span style=color:#bd93f9>6</span> <span style=color:#bd93f9>10584</span> <span style=color:#bd93f9>3059</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>20977</span> sshd       127.0.0.1       <span style=color:#bd93f9>22</span>    127.0.0.1       <span style=color:#bd93f9>56766</span>  <span style=color:#bd93f9>10584</span>     <span style=color:#bd93f9>6</span> <span style=color:#bd93f9>3059</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>14519</span> monitord   127.0.0.1       <span style=color:#bd93f9>44832</span> 127.0.0.1       <span style=color:#bd93f9>44444</span>      <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 7f00:6:5ea7::a00:0 <span style=color:#bd93f9>42846</span> 0:0:bb01::      <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>12441</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 7f00:6:5aa7::a00:0 <span style=color:#bd93f9>42842</span> 0:0:bb01::      <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>12436</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 7f00:6:62a7::a00:0 <span style=color:#bd93f9>42850</span> 0:0:bb01::      <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>12436</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 7f00:6:5ca7::a00:0 <span style=color:#bd93f9>42844</span> 0:0:bb01::      <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>12442</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 7f00:6:60a7::a00:0 <span style=color:#bd93f9>42848</span> 0:0:bb01::      <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>12436</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 10.0.0.65       <span style=color:#bd93f9>33342</span> 54.241.2.241    <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>10717</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 10.0.0.65       <span style=color:#bd93f9>33350</span> 54.241.2.241    <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>10711</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>4496</span>  Chrome_IOT 10.0.0.65       <span style=color:#bd93f9>33352</span> 54.241.2.241    <span style=color:#bd93f9>443</span>        <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>3</span> <span style=color:#bd93f9>10712</span>
</span></span><span style=display:flex><span><span style=color:#bd93f9>14519</span> monitord   127.0.0.1       <span style=color:#bd93f9>44832</span> 127.0.0.1       <span style=color:#bd93f9>44444</span>      <span style=color:#bd93f9>0</span>     <span style=color:#bd93f9>0</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The output begins with a localhost ssh connection, so both endpoints can be
</span></span><span style=display:flex><span>seen: the ssh process <span style=color:#ff79c6>(</span>PID 20976<span style=color:#ff79c6>)</span> which received <span style=color:#bd93f9>10584</span> Kbytes, and the sshd
</span></span><span style=display:flex><span>process <span style=color:#ff79c6>(</span>PID 20977<span style=color:#ff79c6>)</span> which transmitted <span style=color:#bd93f9>10584</span> Kbytes. This session lasted <span style=color:#bd93f9>3059</span>
</span></span><span style=display:flex><span>milliseconds. Other sessions can also be seen, including IPv6 connections.
</span></span></code></pre></div><h2 id=ebpf-go库>eBPF Go库</h2><p>eBPF Go 库提供了一个通用的 eBPF 库，它将获取 eBPF 字节码的过程与 eBPF 程序的加载和管理解耦。eBPF 程序通常是通过编写更高级别的语言创建的，然后使用 clang/LLVM 编译器编译为 eBPF字节码。ebpf go 是一个纯 go 库，用于读取、修改和加载 ebpf 程序，并将它们连接到 Linux 内核中的各种 hook 点。</p><p><img src=/images/2023-12-09-ebpf-share/17.png alt></p><p>以下是一个示例，使用 kprobe 监听 sys_execve 事件，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>//go:build ignore
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;common.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>char</span> __license[] SEC(<span style=color:#f1fa8c>&#34;license&#34;</span>) <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Dual MIT/GPL&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> bpf_map_def <span style=color:#50fa7b>SEC</span>(<span style=color:#f1fa8c>&#34;maps&#34;</span>) kprobe_map <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>	.type        <span style=color:#ff79c6>=</span> BPF_MAP_TYPE_PERCPU_ARRAY,
</span></span><span style=display:flex><span>	.key_size    <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(u32),
</span></span><span style=display:flex><span>	.value_size  <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(u64),
</span></span><span style=display:flex><span>	.max_entries <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>SEC(<span style=color:#f1fa8c>&#34;kprobe/sys_execve&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> kprobe_execve() {
</span></span><span style=display:flex><span>	u32 key     <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	u64 initval <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>, <span style=color:#ff79c6>*</span>valp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	valp <span style=color:#ff79c6>=</span> bpf_map_lookup_elem(<span style=color:#ff79c6>&amp;</span>kprobe_map, <span style=color:#ff79c6>&amp;</span>key);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>valp) {
</span></span><span style=display:flex><span>		bpf_map_update_elem(<span style=color:#ff79c6>&amp;</span>kprobe_map, <span style=color:#ff79c6>&amp;</span>key, <span style=color:#ff79c6>&amp;</span>initval, BPF_ANY);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	__sync_fetch_and_add(valp, <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// This program demonstrates attaching an eBPF program to a kernel symbol and
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// using percpu map to collect data. The eBPF program will be attached to the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// start of the sys_execve kernel function and prints out the number of called
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// times on each cpu every second.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#f1fa8c>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f1fa8c>&#34;time&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f1fa8c>&#34;github.com/cilium/ebpf/link&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#f1fa8c>&#34;github.com/cilium/ebpf/rlimit&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//go:generate go run github.com/cilium/ebpf/cmd/bpf2go bpf kprobe_percpu.c -- -I../headers
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>const</span> mapKey <span style=color:#8be9fd>uint32</span> = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Name of the kernel function to trace.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	fn <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>&#34;sys_execve&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Allow the current process to lock memory for eBPF resources.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> rlimit.<span style=color:#50fa7b>RemoveMemlock</span>(); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		log.<span style=color:#50fa7b>Fatal</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Load pre-compiled programs and maps into the kernel.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	objs <span style=color:#ff79c6>:=</span> bpfObjects{}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>loadBpfObjects</span>(<span style=color:#ff79c6>&amp;</span>objs, <span style=color:#ff79c6>nil</span>); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		log.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;loading objects: %v&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> objs.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Open a Kprobe at the entry point of the kernel function and attach the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// pre-compiled program. Each time the kernel function enters, the program
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// will increment the execution counter by 1. The read loop below polls this
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// map value once per second.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	kp, err <span style=color:#ff79c6>:=</span> link.<span style=color:#50fa7b>Kprobe</span>(fn, objs.KprobeExecve, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		log.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;opening kprobe: %s&#34;</span>, err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> kp.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Read loop reporting the total amount of times the kernel
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// function was entered, once per second.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	ticker <span style=color:#ff79c6>:=</span> time.<span style=color:#50fa7b>NewTicker</span>(<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>*</span> time.Second)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> ticker.<span style=color:#50fa7b>Stop</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	log.<span style=color:#50fa7b>Println</span>(<span style=color:#f1fa8c>&#34;Waiting for events..&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> <span style=color:#ff79c6>range</span> ticker.C {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>var</span> all_cpu_value []<span style=color:#8be9fd>uint64</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> objs.KprobeMap.<span style=color:#50fa7b>Lookup</span>(mapKey, <span style=color:#ff79c6>&amp;</span>all_cpu_value); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			log.<span style=color:#50fa7b>Fatalf</span>(<span style=color:#f1fa8c>&#34;reading map: %v&#34;</span>, err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>for</span> cpuid, cpuvalue <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> all_cpu_value {
</span></span><span style=display:flex><span>			log.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;%s called %d times on CPU%v\n&#34;</span>, fn, cpuvalue, cpuid)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		log.<span style=color:#50fa7b>Printf</span>(<span style=color:#f1fa8c>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=libbpf-cc-库>libbpf C/C++ 库</h2><p>libbpf 库是一个基于 C/C++ 的通用 eBPF 库，它有助于将 clang/LLVM 编译器生成的 eBPF 对象文件加载到内核中，并且通常通过为应用程序提供易于使用的库 API 来抽象与 BPF 系统调用的交互。libbpf 是从内核中抽离出来的标准库，用它开发的 eBPF 程序可以直接分发执行，这样就不需要每台机器都安装 LLVM 和内核头文件了。不过，它要求内核开启 BTF 特性，需要非常新的发行版才会默认开启（如 RHEL 8.2+ 和 Ubuntu 20.10+ 等）。</p><p>libbpf 支持构建启用 BPF CO-RE 的应用程序，与 BCC 相比，这些应用程序不需要将 Clang/LLVM 运行时部署到目标服务器，也不依赖于可用的内核开发头。不过，它确实依赖于使用 BTF 类型信息构建的内核，一些主要的 Linux 发行版已经内置了内核 BTF。代码源代码可参见 <a href=https://github.com/libbpf/libbpf>https://github.com/libbpf/libbpf</a>。</p><p><img src=/images/2023-12-09-ebpf-share/18.png alt></p><p>以下是一个参考示例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#6272a4>// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#6272a4>/* Copyright (c) 2020 Facebook */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;errno.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;unistd.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;sys/resource.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;bpf/libbpf.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&#34;uprobe.skel.h&#34;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>libbpf_print_fn</span>(<span style=color:#ff79c6>enum</span> libbpf_print_level level, <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>format, va_list args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> vfprintf(stderr, format, args);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* It&#39;s a global function to make sure compiler doesn&#39;t inline it. */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>uprobed_add</span>(<span style=color:#8be9fd>int</span> a, <span style=color:#8be9fd>int</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> a <span style=color:#ff79c6>+</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>uprobed_sub</span>(<span style=color:#8be9fd>int</span> a, <span style=color:#8be9fd>int</span> b)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> a <span style=color:#ff79c6>-</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>(<span style=color:#8be9fd>int</span> argc, <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>**</span>argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>struct</span> uprobe_bpf <span style=color:#ff79c6>*</span>skel;
</span></span><span style=display:flex><span>	<span style=color:#8be9fd>int</span> err, i;
</span></span><span style=display:flex><span>	LIBBPF_OPTS(bpf_uprobe_opts, uprobe_opts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Set up libbpf errors and debug info callback */</span>
</span></span><span style=display:flex><span>	libbpf_set_print(libbpf_print_fn);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Load and verify BPF application */</span>
</span></span><span style=display:flex><span>	skel <span style=color:#ff79c6>=</span> uprobe_bpf__open_and_load();
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>skel) {
</span></span><span style=display:flex><span>		fprintf(stderr, <span style=color:#f1fa8c>&#34;Failed to open and load BPF skeleton</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Attach tracepoint handler */</span>
</span></span><span style=display:flex><span>	uprobe_opts.func_name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;uprobed_add&#34;</span>;
</span></span><span style=display:flex><span>	uprobe_opts.retprobe <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>false</span>;
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* uprobe/uretprobe expects relative offset of the function to attach
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * to. libbpf will automatically find the offset for us if we provide the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * function name. If the function name is not specified, libbpf will try
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * to use the function offset instead.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	skel<span style=color:#ff79c6>-&gt;</span>links.uprobe_add <span style=color:#ff79c6>=</span> bpf_program__attach_uprobe_opts(skel<span style=color:#ff79c6>-&gt;</span>progs.uprobe_add,
</span></span><span style=display:flex><span>								 <span style=color:#bd93f9>0</span> <span style=color:#6272a4>/* self pid */</span>, <span style=color:#f1fa8c>&#34;/proc/self/exe&#34;</span>,
</span></span><span style=display:flex><span>								 <span style=color:#bd93f9>0</span> <span style=color:#6272a4>/* offset for function */</span>,
</span></span><span style=display:flex><span>								 <span style=color:#ff79c6>&amp;</span>uprobe_opts <span style=color:#6272a4>/* opts */</span>);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>skel<span style=color:#ff79c6>-&gt;</span>links.uprobe_add) {
</span></span><span style=display:flex><span>		err <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>errno;
</span></span><span style=display:flex><span>		fprintf(stderr, <span style=color:#f1fa8c>&#34;Failed to attach uprobe: %d</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, err);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> cleanup;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* we can also attach uprobe/uretprobe to any existing or future
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * processes that use the same binary executable; to do that we need
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * to specify -1 as PID, as we do here
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	uprobe_opts.func_name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;uprobed_add&#34;</span>;
</span></span><span style=display:flex><span>	uprobe_opts.retprobe <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>true</span>;
</span></span><span style=display:flex><span>	skel<span style=color:#ff79c6>-&gt;</span>links.uretprobe_add <span style=color:#ff79c6>=</span> bpf_program__attach_uprobe_opts(
</span></span><span style=display:flex><span>		skel<span style=color:#ff79c6>-&gt;</span>progs.uretprobe_add, <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span> <span style=color:#6272a4>/* self pid */</span>, <span style=color:#f1fa8c>&#34;/proc/self/exe&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#bd93f9>0</span> <span style=color:#6272a4>/* offset for function */</span>, <span style=color:#ff79c6>&amp;</span>uprobe_opts <span style=color:#6272a4>/* opts */</span>);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>skel<span style=color:#ff79c6>-&gt;</span>links.uretprobe_add) {
</span></span><span style=display:flex><span>		err <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span>errno;
</span></span><span style=display:flex><span>		fprintf(stderr, <span style=color:#f1fa8c>&#34;Failed to attach uprobe: %d</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, err);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> cleanup;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>/* Let libbpf perform auto-attach for uprobe_sub/uretprobe_sub
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 * NOTICE: we provide path and symbol info in SEC for BPF programs
</span></span></span><span style=display:flex><span><span style=color:#6272a4>	 */</span>
</span></span><span style=display:flex><span>	err <span style=color:#ff79c6>=</span> uprobe_bpf__attach(skel);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> (err) {
</span></span><span style=display:flex><span>		fprintf(stderr, <span style=color:#f1fa8c>&#34;Failed to auto-attach BPF skeleton: %d</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, err);
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>goto</span> cleanup;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	printf(<span style=color:#f1fa8c>&#34;Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` &#34;</span>
</span></span><span style=display:flex><span>	       <span style=color:#f1fa8c>&#34;to see output of the BPF programs.</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>/* trigger our BPF programs */</span>
</span></span><span style=display:flex><span>		fprintf(stderr, <span style=color:#f1fa8c>&#34;.&#34;</span>);
</span></span><span style=display:flex><span>		uprobed_add(i, i <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>		uprobed_sub(i <span style=color:#ff79c6>*</span> i, i);
</span></span><span style=display:flex><span>		sleep(<span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>cleanup</span>:
</span></span><span style=display:flex><span>	uprobe_bpf__destroy(skel);
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span>err;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=常见问题>常见问题</h1><h2 id=什么是-btf>什么是 BTF？</h2><p>BTF 是一种新的内核数据类型格式，它为内核提供了一种描述数据类型的方法，这对于BPF CO-RE 的运行至关重要。在编写eBPF 程序时， vmlinux.h 文件使得开发者可以在用户空间程序中直接使用内核的数据结构，而无需关心内核版本的差异。BTF的全称是BPF Type Format（BPF类型格式）。它的主要作用是解决在开发内核BPF程序（C语言编写）时需要引入内核数据结构的问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h
</span></span></code></pre></div><p><img src=/images/2023-12-09-ebpf-share/19.png alt></p><h2 id=如何兼容多个内核版本>如何兼容多个内核版本？</h2><p>问题：</p><ul><li>第一，新内核引入的 eBPF 新特性无法在旧内核中运行。</li><li>第二，新内核中的数据结构、函数签名以及跟踪点等有可能跟旧版本内核不同。</li><li>第三，即便是相同的内核版本，不同的编译选项也可能会导致内核数据结构的不同。</li></ul><p>解决方案：</p><ul><li>第一，在运行 eBPF 程序的时候使用当前系统安装的内核头文件进行就地编译，这样就可以确保 eBPF 程序中所引用的内核数据结构和函数签名等，跟运行中的内核是完全匹配的。</li><li>第二，在 eBPF 程序编译前事先探测内核支持的函数签名和数据结构，进而为 eBPF 程序生成适配当前内核的版本。</li></ul><p>Linux 内核维护者提供了一个更好的方案，那就是一次编译到处执行（Compile Once Run Everywhere，简称 CO-RE）。Linux 内核社区更推荐所有开发者使用 CO-RE 和 libbpf 来构建 eBPF 程序。</p><ul><li>第一，在 bpftool 工具中提供了从 BTF 生成头文件的工具，从而摆脱了对内核头文件的依赖。</li><li>第二，通过对 BPF 代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题。</li><li>第三，在 libbpf 中预定义不同内核版本中数据结构的修改，解决了不同内核中数据结构不兼容的问题。</li><li>第四，在 libbpf 中提供一系列的内核特性探测库函数，解决了 eBPF 程序在不同内核内版本中需要执行不同行为的问题。比如，你可以用 bpf_core_type_exists() 和bpf_core_field_exists() 分别检查内核数据类型和成员变量是否存在，也可以用类似 extern int LINUX_KERNEL_VERSION __kconfig 的方式查询内核的配置选项。</li></ul><p>注意：CO-RE 需要比较新的内核版本（大于等于 5.2）并且需要打开 CONFIG_DEBUG_INFO_BTF 内核配置选项。</p><h2 id=bpf辅助函数是什么>BPF辅助函数是什么？</h2><p>在编写BPF内核态程序时，内核态的程序代码如果要和内核代码进行交互比如获取内核中某个数据结构的变量值，需要经过BPF辅助函数。比如bpf_get_current_comm()辅助函数就是用来获取当前程序的命令。</p><h1 id=云厂商相关产品>云厂商相关产品</h1><p>在云厂商中，eBPF 已经逐渐成为一种基础设施，比如阿里云、华为云、字节火山引擎、百度智能云等。</p><p><a href=https://mp.weixin.qq.com/s/Wo4t2mPBmS0sZCq0SM652Q>阿里云 - 基于 eBPF 构建下一代智能可观测系统</a></p><p><img src=/images/2023-12-09-ebpf-share/20.png alt></p><p><img src=/images/2023-12-09-ebpf-share/21.png alt></p><p><a href=https://mp.weixin.qq.com/s/nqDVLcddd0_auX2LZJ8T7g>火山引擎 Kubernetes 观测：基于 eBPF 的云原生深度可观测性实践</a></p><p><img src=/images/2023-12-09-ebpf-share/22.png alt></p><p><img src=/images/2023-12-09-ebpf-share/23.png alt></p><p><a href=https://mp.weixin.qq.com/s/YwlGXShm2k6R59_KpYKNdw>​华为云CCE Turbo：基于eBPF的用户自定义多粒度网络监控能力</a></p><p><img src=/images/2023-12-09-ebpf-share/24.png alt></p><h1 id=参考>参考</h1><ol><li><a href=https://ebpf.io/>https://ebpf.io/</a></li><li><a href="https://mp.weixin.qq.com/s/ggt-aCHSvhmfwz8-fFHN6w?scene=25#wechat_redirect">深度解密｜基于 eBPF 的 Kubernetes 问题排查全景图发布</a></li></ol><h1 id=附录>附录</h1><ol><li>eBPF <a href=https://github.com/eunomia-bpf/bpf-developer-tutorial>学习入门示例</a></li><li>百页 PPT BPF 技术全览 - 深入浅出 BPF 技术 <a href=https://www.ebpf.top/post/head_first_bpf/>https://www.ebpf.top/post/head_first_bpf/</a></li><li>BPF 学习路径总结 <a href=https://www.ebpf.top/post/ebpf_learn_path/>https://www.ebpf.top/post/ebpf_learn_path/</a></li><li>eBPF 技术报告 <a href=https://www.ebpf.top/what-is-ebpf/>https://www.ebpf.top/what-is-ebpf/</a></li></ol><hr><ul class=pager><li class=previous><a href=/post/2023-11-11-ebpf-pwru/ data-toggle=tooltip data-placement=top title="pwru: 一款基于 eBPF 的细粒度网络数据包排查工具">&larr;
Previous Post</a></li><li class=next><a href=/post/2024-01-09-kubernetes-coredns/ data-toggle=tooltip data-placement=top title="Kubernetes CoreDNS 核心原理和源码解析">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2024</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>