<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="漫步远方，心荡神往"><meta property="og:type" content="article"><meta property="og:image" content="https://tanjunchen.github.io/img/home.webp"><meta property="twitter:image" content="https://tanjunchen.github.io/img/home.webp"><meta name=title content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）"><meta property="og:title" content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）"><meta property="twitter:title" content="深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）"><meta name=description content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="og:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:description" content="陈谭军，软件工程师, 开源爱好者, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><meta property="twitter:card" content="summary"><meta name=keyword content="陈谭军, 互联网, 云原生, 容器, 微服务, Web, PaaS, Istio, Kubernetes, Microservice"><link rel="shortcut icon" href=/img/favicon.ico><title>深入理解 Kubernetes Scheduler Framework 调度框架（Part 2） | 陈谭军的博客 | tanjunchen Blog</title><link rel=canonical href=/post/2024-04-07-scheduler-framework-02/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script>
<script src=/js/lazysizes.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>漫步远方，心荡神往</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/technology/>technology</a></li><li><a href=/categories/think/>think</a></li><li><a href=/learning/>LEARNING</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/kubernetes title=kubernetes>kubernetes</a>
<a class=tag href=/tags/scheduler-framework title="Scheduler Framework">Scheduler Framework</a></div><h1>深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）</h1><h2 class=subheading>Scheduler Framework 框架核心源码与 Pod 调度到 Node 流程</h2><span class=meta>Posted by
陈谭军
on
Sunday, April 7, 2024
<span id=busuanzi_container_page_pv>|<span id=busuanzi_value_page_pv></span><span>
<span id=/post/2024-04-07-scheduler-framework-02/ class="leancloud_visitors meta_data_item" data-flag-title><span class=post-meta-item-icon><span class="octicon octicon-eye"></span></span>
<i class="fa fa-eye"></i>
<span class=old-visitors-count style=display:none></span>
<span class=leancloud-visitors-count></span></span>
<script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script>
<script>AV.initialize("","")</script><script type=text/javascript>function showTime(e){var n=new AV.Query(e),t=[],s=$(".leancloud_visitors");s.each(function(){t.push($(this).attr("id").trim())}),n.containedIn("url",t),n.find().done(function(e){for(var s,o,i,a,r,c,l=".leancloud-visitors-count",d=".old-visitors-count",n=0;n<e.length;n++)a=e[n],i=a.get("url"),c=a.get("time"),s=document.getElementById(i),$(s).find(l).text(c);for(n=0;n<t.length;n++)i=t[n],s=document.getElementById(i),o=$(s).find(l),o.text()==""&&(r=$(s).find(d).text(),r!=""?o.text(0+parseInt(r)):o.text(0))}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var n=$(".leancloud_visitors"),t=n.attr("id").trim(),o=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",t),s.find({success:function(n){if(n.length>0){var s,i,r,c,l,a=n[0];a.fetchWhenSave(!0),a.increment("time"),a.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else s=new e,i=new AV.ACL,i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),s.setACL(i),s.set("title",o),s.set("url",t),c=".old-visitors-count",l=$(document.getElementById(t)),r=l.find(c).text(),r!=""?s.set("time",parseInt(r)+1):s.set("time",1),s.save(null,{success:function(e){var n=$(document.getElementById(t));n.find(".leancloud-visitors-count").text(e.get("time"))},error:function(){console.log("Failed to create")}})},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");$(".leancloud_visitors").length==1?addCount(e):showTime(e)})</script>阅读 </span></span>|<span class=post-date>共 12836 字</span>，阅读约 <span class=more-meta>26 分钟</span></span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>Scheduler 分两个 cycle：Scheduling Cycle 和 Binding Cycle。在 Scheduling Cycle 中为了提升效率的一个重要原则就是 Pod、 Node 等信息从本地缓存中获取，而具体的实现原理就是先使用 list 获取所有 Node、Pod 的信息，然后再 watch 他们的变化更新本地缓存。在 Bind Cycle 中，会有两次外部 api 调用：调用 pv controller 绑定 pv 和调用 kube-apiserver 绑定 Node，api 调用是耗时的，所以将 bind 扩展点拆分出来，另起一个 go 协程进行 bind。调度周期是串行，绑定周期是并行的。
本文主要介绍 Scheduler Framework 框架核心源码与 Pod 调度到 Node 流程。</p><p><a href=https://tanjunchen.github.io/post/2024-04-08-scheduler-framework-03/>深入理解 Kubernetes Scheduler Framework 调度框架（Part 3）</a><br><a href=https://tanjunchen.github.io/post/2024-04-07-scheduler-framework-02/>深入理解 Kubernetes Scheduler Framework 调度框架（Part 2）</a><br><a href=https://tanjunchen.github.io/post/2024-04-06-scheduler-framework-01/>深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）</a></p><h1 id=核心源码>核心源码</h1><p>依据 Kubernetes 1.29 源码 <a href=https://github.com/kubernetes/kubernetes/blob/v1.29.3/pkg/scheduler/internal/cache/cache.go>v1.29.3/pkg/scheduler/internal/cache/cache.go</a> 说说 scheduler 是怎么工作。我们来重点分析 SchedulerProfiles、SchedulerQueue、SchedulerCache、NextPod 和 SchedulePod、Informer 等核心组件是如何工作的。</p><h2 id=schedulerprofiles>SchedulerProfiles</h2><p>在上面的整体架构中，看到 Scheduler Framework 是按照如下顺利进行拓展的，在拓展点内按照插件注册的顺利执行插件，如下所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/5.svg alt></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Scheduler watches for new unscheduled pods. It attempts to find
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// nodes that they fit on and writes bindings back to the api server.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Scheduler <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// It is expected that changes made via Cache will be observed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// by NodeLister and Algorithm.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	Cache internalcache.Cache
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	Extenders []framework.Extender
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// NextPod should be a function that blocks until the next pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// is available. We don&#39;t use a channel for this, because scheduling
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// a pod may take some amount of time and we don&#39;t want pods to get
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// stale while they sit in a channel.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	NextPod <span style=color:#8be9fd;font-style:italic>func</span>(logger klog.Logger) (<span style=color:#ff79c6>*</span>framework.QueuedPodInfo, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// FailureHandler is called upon a scheduling failure.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	FailureHandler FailureHandlerFn
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// SchedulePod tries to schedule the given pod to one of the nodes in the node list.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// Return a struct of ScheduleResult with the name of suggested host on success,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// otherwise will return a FitError with reasons.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	SchedulePod <span style=color:#8be9fd;font-style:italic>func</span>(ctx context.Context, fwk framework.Framework, state <span style=color:#ff79c6>*</span>framework.CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod) (ScheduleResult, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Close this to shut down the scheduler.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	StopEverything <span style=color:#ff79c6>&lt;-</span><span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// SchedulingQueue holds pods to be scheduled
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	SchedulingQueue internalqueue.SchedulingQueue
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Profiles are the scheduling profiles.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	Profiles profile.Map
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	client clientset.Interface
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	nodeInfoSnapshot <span style=color:#ff79c6>*</span>internalcache.Snapshot
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	percentageOfNodesToScore <span style=color:#8be9fd>int32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	nextStartNodeIndex <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// logger *must* be initialized when creating a Scheduler,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// otherwise logging functions will access a nil sink and
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// panic.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	logger klog.Logger
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// registeredHandlers contains the registrations of all handlers. It&#39;s used to check if all handlers have finished syncing before the scheduling cycles start.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	registeredHandlers []cache.ResourceEventHandlerRegistration
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以 preFilter 为例，扩展点内的插件，你既可以调整插件的执行顺序，可以关闭某个内置插件，还可以增加自己开发的插件，如下所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/6.svg alt></p><p>那么自定义插件又是怎么注册的？Scheduler 里面有最重要的一个成员 Profiles profile.Map。从 pkg/scheduler/profile/profile.go#L46 中可以看到 Profiles 是一个 key 为 scheduler name，value 是 framework.Framework 的 map，表示根据 scheduler name 来获取 framework.Framework 类型的值，如下调度器配置文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>apiVersion</span>: kubescheduler.config.k8s.io/v1beta2
</span></span><span style=display:flex><span><span style=color:#ff79c6>kind</span>: KubeSchedulerConfiguration
</span></span><span style=display:flex><span><span style=color:#ff79c6>leaderElection</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>leaderElect</span>: <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>clientConnection</span>:
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>kubeconfig</span>: <span style=color:#f1fa8c>&#34;/etc/kubernetes/scheduler.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>profiles</span>:
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>schedulerName</span>: my-scheduler-1
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>plugins</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>preFilter</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>enabled</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>name</span>: ZoneNodeLabel
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>disabled</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>name</span>: NodePorts
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>schedulerName</span>: my-scheduler-2
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>plugins</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>queueSort</span>:
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>enabled</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ff79c6>name</span>: MySort
</span></span></code></pre></div><p>通过配置文件，可以使用 enabled，disabled 开关来关闭或打开某个插件，还可以控制扩展点的调用顺序，规则如下：</p><ul><li>如果某个扩展点没有配置对应的扩展，调度框架将使用默认插件中的扩展；</li><li>如果为某个扩展点配置且激活了扩展，则调度框架将先调用默认插件的扩展，再调用配置中的扩展；</li><li>默认插件的扩展始终被最先调用，然后按照 KubeSchedulerConfiguration 中扩展的激活 enabled 顺序逐个调用扩展点的扩展；</li><li>可以先禁用默认插件的扩展，然后在 enabled 列表中的某个位置激活默认插件的扩展，这种做法可以改变默认插件的扩展被调用时的顺序；
更多 profile 调度规则可参见 <a href=https://v1-28.docs.kubernetes.io/docs/reference/scheduling/config/>https://v1-28.docs.kubernetes.io/docs/reference/scheduling/config/</a> 。</li></ul><p>通过 profile 如何获取到具体的 framework 调度框架？当一个 Pod 需要被调度的时候，kube-scheduler 会先取出 Pod 的 schedulerName 字段的值，然后通过 Profiles[schedulerName]，拿到 framework.Framework 对象，进而使用这个对象开始调度。现在 Profiles 成员（一个map）包含了两个元素，{&ldquo;my-scheduler-1&rdquo;: framework.Framework ,&ldquo;my-scheduler-2&rdquo;: framework.Framework}，如下所示：</p><p><img src=/images/2024-04-06-scheduler-framework-01/7.svg alt></p><p>见 pkg/scheduler/framework/interface.go 源码，下面是 framework.Framework 的定义。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Framework manages the set of plugins in use by the scheduling framework.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Configured plugins are called at specified points in a scheduling context.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Framework <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	Handle
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// PreEnqueuePlugins returns the registered preEnqueue plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>PreEnqueuePlugins</span>() []PreEnqueuePlugin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// EnqueueExtensions returns the registered Enqueue extensions.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>EnqueueExtensions</span>() []EnqueueExtensions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// QueueSortFunc returns the function to sort pods in scheduling queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>QueueSortFunc</span>() LessFunc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// RunPreFilterPlugins runs the set of configured PreFilter plugins. It returns
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// *Status and its code is set to non-success if any of the plugins returns
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// anything but Success. If a non-success status is returned, then the scheduling
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// cycle is aborted.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// It also returns a PreFilterResult, which may influence what or how many nodes to
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// evaluate downstream.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>RunPreFilterPlugins</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod) (<span style=color:#ff79c6>*</span>PreFilterResult, <span style=color:#ff79c6>*</span>Status)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// RunPostFilterPlugins runs the set of configured PostFilter plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// PostFilter plugins can either be informational, in which case should be configured
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// to execute first and return Unschedulable status, or ones that try to change the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// cluster state to make the pod potentially schedulable in a future scheduling cycle.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>RunPostFilterPlugins</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod, filteredNodeStatusMap NodeToStatusMap) (<span style=color:#ff79c6>*</span>PostFilterResult, <span style=color:#ff79c6>*</span>Status)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>......</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Close calls Close method of each plugin.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>Close</span>() <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Framework 是一个接口，需要实现的方法大部分为 RunXXXPlugins()，也就是运行某个扩展点的插件，那么只要实现这个 Framework 接口就可以对 Pod 进行调度。kube-scheduler 目前已有接口实现 frameworkImpl，见 pkg/scheduler/framework/runtime/framework.go。frameworkImpl 包含每个扩展点插件数组，所以某个扩展点要被执行的时候，只要遍历这个数组里面的所有插件，然后执行这些插件就可以。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// frameworkImpl is the component responsible for initializing and running scheduler
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> frameworkImpl <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	registry             Registry
</span></span><span style=display:flex><span>	snapshotSharedLister framework.SharedLister
</span></span><span style=display:flex><span>	waitingPods          <span style=color:#ff79c6>*</span>waitingPodsMap
</span></span><span style=display:flex><span>	scorePluginWeight    <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>	preEnqueuePlugins    []framework.PreEnqueuePlugin
</span></span><span style=display:flex><span>	enqueueExtensions    []framework.EnqueueExtensions
</span></span><span style=display:flex><span>	queueSortPlugins     []framework.QueueSortPlugin
</span></span><span style=display:flex><span>	preFilterPlugins     []framework.PreFilterPlugin
</span></span><span style=display:flex><span>	filterPlugins        []framework.FilterPlugin
</span></span><span style=display:flex><span>	postFilterPlugins    []framework.PostFilterPlugin
</span></span><span style=display:flex><span>	preScorePlugins      []framework.PreScorePlugin
</span></span><span style=display:flex><span>	scorePlugins         []framework.ScorePlugin
</span></span><span style=display:flex><span>	reservePlugins       []framework.ReservePlugin
</span></span><span style=display:flex><span>	preBindPlugins       []framework.PreBindPlugin
</span></span><span style=display:flex><span>	bindPlugins          []framework.BindPlugin
</span></span><span style=display:flex><span>	postBindPlugins      []framework.PostBindPlugin
</span></span><span style=display:flex><span>	permitPlugins        []framework.PermitPlugin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pluginsMap contains all plugins, by name.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	pluginsMap <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]framework.Plugin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	clientSet       clientset.Interface
</span></span><span style=display:flex><span>	kubeConfig      <span style=color:#ff79c6>*</span>restclient.Config
</span></span><span style=display:flex><span>	eventRecorder   events.EventRecorder
</span></span><span style=display:flex><span>	informerFactory informers.SharedInformerFactory
</span></span><span style=display:flex><span>	logger          klog.Logger
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	metricsRecorder          <span style=color:#ff79c6>*</span>metrics.MetricAsyncRecorder
</span></span><span style=display:flex><span>	profileName              <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>	percentageOfNodesToScore <span style=color:#ff79c6>*</span><span style=color:#8be9fd>int32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	extenders []framework.Extender
</span></span><span style=display:flex><span>	framework.PodNominator
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	parallelizer parallelize.Parallelizer
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 pkg/scheduler/framework/plugins 目录下包含了所有内置插件对 Plugin 接口的实现，framework.FilterPlugin 定义如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Plugin is the parent type for all the scheduling framework plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Plugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>Name</span>() <span style=color:#8be9fd>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// FilterPlugin is an interface for Filter plugins. These plugins are called at the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// filter extension point for filtering out hosts that cannot run a pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// This concept used to be called &#39;predicate&#39; in the original scheduler.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// These plugins should return &#34;Success&#34;, &#34;Unschedulable&#34; or &#34;Error&#34; in Status.code.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// However, the scheduler accepts other valid codes as well.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Anything other than &#34;Success&#34; will lead to exclusion of the given host from
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// running the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> FilterPlugin <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	Plugin
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Filter is called by the scheduling framework.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// All FilterPlugins should return &#34;Success&#34; to declare that
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// the given node fits the pod. If Filter doesn&#39;t return &#34;Success&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// it will return &#34;Unschedulable&#34;, &#34;UnschedulableAndUnresolvable&#34; or &#34;Error&#34;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// For the node being evaluated, Filter plugins should look at the passed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// nodeInfo reference for this particular node&#39;s information (e.g., pods
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// considered to be running on the node) instead of looking it up in the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// NodeInfoSnapshot because we don&#39;t guarantee that they will be the same.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// For example, during preemption, we may pass a copy of the original
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// nodeInfo object that has some pods removed from it to evaluate the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// possibility of preempting them to schedule the target pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>Filter</span>(ctx context.Context, state <span style=color:#ff79c6>*</span>CycleState, pod <span style=color:#ff79c6>*</span>v1.Pod, nodeInfo <span style=color:#ff79c6>*</span>NodeInfo) <span style=color:#ff79c6>*</span>Status
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这些默认插件是怎么加到 framework？主要步骤如下所示：</p><ul><li>根据配置文件（&ndash;config 指定的）、系统默认插件，按照扩展点生成需要被加载的插件数组（包括插件名称，权重），也就是初始化 KubeSchedulerConfiguration 中的 Profiles 成员；</li><li>创建 registry 集合，这个集合内是每个插件实例化函数，也就是插件名称到插件实例化函数的映射；</li><li>将上述步骤1中每个扩展点的每个插件（就是插件名字）拿出来，去步骤2的映射（map）中获取实例化函数，然后运行这个实例化函数，最后把这个实例化出来的插件（可以被运行的）追加到上面提到过的 frameworkImpl 对应扩展点数组中，这样后面要运行某个扩展点插件的时候遍历运行就可以；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// PluginFactory is a function that builds a plugin.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PluginFactory = <span style=color:#8be9fd;font-style:italic>func</span>(ctx context.Context, configuration runtime.Object, f framework.Handle) (framework.Plugin, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// PluginFactoryWithFts is a function that builds a plugin with certain feature gates.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PluginFactoryWithFts <span style=color:#8be9fd;font-style:italic>func</span>(context.Context, runtime.Object, framework.Handle, plfeature.Features) (framework.Plugin, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Registry is a collection of all available plugins. The framework uses a
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// registry to enable and initialize configured plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// All plugins must be in the registry before initializing the framework.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Registry <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]PluginFactory
</span></span></code></pre></div><p>包含内置（叫inTree）默认的插件映射和用户自定义（outOfTree）插件映射，内置的映射通过下面函数创建（见源码 pkg/scheduler/framework/plugins/registry.go）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// NewInTreeRegistry builds the registry with all the in-tree plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// A scheduler that runs out of tree plugins can register additional plugins
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// through the WithFrameworkOutOfTreeRegistry option.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>NewInTreeRegistry</span>() runtime.Registry {
</span></span><span style=display:flex><span>	fts <span style=color:#ff79c6>:=</span> plfeature.Features{
</span></span><span style=display:flex><span>		EnableDynamicResourceAllocation:              feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.DynamicResourceAllocation),
</span></span><span style=display:flex><span>		EnableVolumeCapacityPriority:                 feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.VolumeCapacityPriority),
</span></span><span style=display:flex><span>		EnableNodeInclusionPolicyInPodTopologySpread: feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.NodeInclusionPolicyInPodTopologySpread),
</span></span><span style=display:flex><span>		EnableMatchLabelKeysInPodTopologySpread:      feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.MatchLabelKeysInPodTopologySpread),
</span></span><span style=display:flex><span>		EnablePodDisruptionConditions:                feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.PodDisruptionConditions),
</span></span><span style=display:flex><span>		EnableInPlacePodVerticalScaling:              feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.InPlacePodVerticalScaling),
</span></span><span style=display:flex><span>		EnableSidecarContainers:                      feature.DefaultFeatureGate.<span style=color:#50fa7b>Enabled</span>(features.SidecarContainers),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	registry <span style=color:#ff79c6>:=</span> runtime.Registry{
</span></span><span style=display:flex><span>		dynamicresources.Name:                runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, dynamicresources.New),
</span></span><span style=display:flex><span>		imagelocality.Name:                   imagelocality.New,
</span></span><span style=display:flex><span>		tainttoleration.Name:                 tainttoleration.New,
</span></span><span style=display:flex><span>		nodename.Name:                        nodename.New,
</span></span><span style=display:flex><span>		nodeports.Name:                       nodeports.New,
</span></span><span style=display:flex><span>		nodeaffinity.Name:                    nodeaffinity.New,
</span></span><span style=display:flex><span>		podtopologyspread.Name:               runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, podtopologyspread.New),
</span></span><span style=display:flex><span>		nodeunschedulable.Name:               nodeunschedulable.New,
</span></span><span style=display:flex><span>		noderesources.Name:                   runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, noderesources.NewFit),
</span></span><span style=display:flex><span>		noderesources.BalancedAllocationName: runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, noderesources.NewBalancedAllocation),
</span></span><span style=display:flex><span>		volumebinding.Name:                   runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, volumebinding.New),
</span></span><span style=display:flex><span>		volumerestrictions.Name:              runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, volumerestrictions.New),
</span></span><span style=display:flex><span>		volumezone.Name:                      volumezone.New,
</span></span><span style=display:flex><span>		nodevolumelimits.CSIName:             runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, nodevolumelimits.NewCSI),
</span></span><span style=display:flex><span>		nodevolumelimits.EBSName:             runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, nodevolumelimits.NewEBS),
</span></span><span style=display:flex><span>		nodevolumelimits.GCEPDName:           runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, nodevolumelimits.NewGCEPD),
</span></span><span style=display:flex><span>		nodevolumelimits.AzureDiskName:       runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, nodevolumelimits.NewAzureDisk),
</span></span><span style=display:flex><span>		nodevolumelimits.CinderName:          runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, nodevolumelimits.NewCinder),
</span></span><span style=display:flex><span>		interpodaffinity.Name:                interpodaffinity.New,
</span></span><span style=display:flex><span>		queuesort.Name:                       queuesort.New,
</span></span><span style=display:flex><span>		defaultbinder.Name:                   defaultbinder.New,
</span></span><span style=display:flex><span>		defaultpreemption.Name:               runtime.<span style=color:#50fa7b>FactoryAdapter</span>(fts, defaultpreemption.New),
</span></span><span style=display:flex><span>		schedulinggates.Name:                 schedulinggates.New,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> registry
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用户自定义插件见源码 pkg/scheduler/scheduler.go，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// pkg/scheduler/scheduler.go
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>registry <span style=color:#ff79c6>:=</span> frameworkplugins.<span style=color:#50fa7b>NewInTreeRegistry</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> registry.<span style=color:#50fa7b>Merge</span>(options.frameworkOutOfTreeRegistry); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, err
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=schedulerqueue>SchedulerQueue</h2><p>SchedulerQueue 见源码 pkg/scheduler/scheduler.go 如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>podQueue <span style=color:#ff79c6>:=</span> internalqueue.<span style=color:#50fa7b>NewSchedulingQueue</span>(
</span></span><span style=display:flex><span>    profiles[options.profiles[<span style=color:#bd93f9>0</span>].SchedulerName].<span style=color:#50fa7b>QueueSortFunc</span>(),
</span></span><span style=display:flex><span>    informerFactory,
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPodInitialBackoffDuration</span>(time.<span style=color:#50fa7b>Duration</span>(options.podInitialBackoffSeconds)<span style=color:#ff79c6>*</span>time.Second),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPodMaxBackoffDuration</span>(time.<span style=color:#50fa7b>Duration</span>(options.podMaxBackoffSeconds)<span style=color:#ff79c6>*</span>time.Second),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPodLister</span>(podLister),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPodMaxInUnschedulablePodsDuration</span>(options.podMaxInUnschedulablePodsDuration),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPreEnqueuePluginMap</span>(preEnqueuePluginMap),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithQueueingHintMapPerProfile</span>(queueingHintsPerProfile),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithPluginMetricsSamplePercent</span>(pluginMetricsSamplePercent),
</span></span><span style=display:flex><span>    internalqueue.<span style=color:#50fa7b>WithMetricsRecorder</span>(<span style=color:#ff79c6>*</span>metricsRecorder),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// NewSchedulingQueue initializes a priority queue as a new scheduling queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>NewSchedulingQueue</span>(
</span></span><span style=display:flex><span>	lessFn framework.LessFunc,
</span></span><span style=display:flex><span>	informerFactory informers.SharedInformerFactory,
</span></span><span style=display:flex><span>	opts <span style=color:#ff79c6>...</span>Option) SchedulingQueue {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>NewPriorityQueue</span>(lessFn, informerFactory, opts<span style=color:#ff79c6>...</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// PriorityQueue implements a scheduling queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// The head of PriorityQueue is the highest priority pending pod. This structure
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// has two sub queues and a additional data structure, namely: activeQ,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// backoffQ and unschedulablePods.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - activeQ holds pods that are being considered for scheduling.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - backoffQ holds pods that moved from unschedulablePods and will move to
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     activeQ when their backoff periods complete.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - unschedulablePods holds pods that were already attempted for scheduling and
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     are currently determined to be unschedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> PriorityQueue <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>*</span>nominator
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	stop  <span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>	clock clock.Clock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pod initial backoff duration.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podInitialBackoffDuration time.Duration
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pod maximum backoff duration.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podMaxBackoffDuration time.Duration
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// the maximum time a pod can stay in the unschedulablePods.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podMaxInUnschedulablePodsDuration time.Duration
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	cond sync.Cond
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// inFlightPods holds the UID of all pods which have been popped out for which Done
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// hasn&#39;t been called yet - in other words, all pods that are currently being
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// processed (being scheduled, in permit, or in the binding cycle).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The values in the map are the entry of each pod in the inFlightEvents list.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The value of that entry is the *v1.Pod at the time that scheduling of that
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// pod started, which can be useful for logging or debugging.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	inFlightPods <span style=color:#8be9fd;font-style:italic>map</span>[types.UID]<span style=color:#ff79c6>*</span>list.Element
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// inFlightEvents holds the events received by the scheduling queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// (entry value is clusterEvent) together with in-flight pods (entry
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// value is *v1.Pod). Entries get added at the end while the mutex is
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// locked, so they get serialized.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The pod entries are added in Pop and used to track which events
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// occurred after the pod scheduling attempt for that pod started.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// They get removed when the scheduling attempt is done, at which
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// point all events that occurred in the meantime are processed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// After removal of a pod, events at the start of the list are no
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// longer needed because all of the other in-flight pods started
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// later. Those events can be removed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	inFlightEvents <span style=color:#ff79c6>*</span>list.List
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// activeQ is heap structure that scheduler actively looks at to find pods to
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// schedule. Head of heap is the highest priority pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	activeQ <span style=color:#ff79c6>*</span>heap.Heap
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// podBackoffQ is a heap ordered by backoff expiry. Pods which have completed backoff
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// are popped from this heap before the scheduler looks at activeQ
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podBackoffQ <span style=color:#ff79c6>*</span>heap.Heap
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// unschedulablePods holds pods that have been tried and determined unschedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	unschedulablePods <span style=color:#ff79c6>*</span>UnschedulablePods
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// schedulingCycle represents sequence number of scheduling cycle and is incremented
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// when a pod is popped.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	schedulingCycle <span style=color:#8be9fd>int64</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// moveRequestCycle caches the sequence number of scheduling cycle when we
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// received a move request. Unschedulable pods in and before this scheduling
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// cycle will be put back to activeQueue if we were trying to schedule them
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// when we received move request.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// TODO: this will be removed after SchedulingQueueHint goes to stable and the feature gate is removed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	moveRequestCycle <span style=color:#8be9fd>int64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// preEnqueuePluginMap is keyed with profile name, valued with registered preEnqueue plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	preEnqueuePluginMap <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>][]framework.PreEnqueuePlugin
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// queueingHintMap is keyed with profile name, valued with registered queueing hint functions.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	queueingHintMap QueueingHintMapPerProfile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// closed indicates that the queue is closed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// It is mainly used to let Pop() exit its control loop while waiting for an item.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	closed <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	nsLister listersv1.NamespaceLister
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	metricsRecorder metrics.MetricAsyncRecorder
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pluginMetricsSamplePercent is the percentage of plugin metrics to be sampled.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	pluginMetricsSamplePercent <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// isSchedulingQueueHintEnabled indicates whether the feature gate for the scheduling queue is enabled.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	isSchedulingQueueHintEnabled <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>SchedulingQueue 是一个 internalqueue.SchedulingQueue 接口类型，PriorityQueue 对这个接口进行了实现，创建 Scheduler 的时候 SchedulingQueue 会被 PriorityQueue 类型对象赋值。SchedulerQueue 包含三个队列：activeQ、podBackoffQ、unschedulablePods。</p><ul><li>activeQ 是一个优先队列，基于堆实现，用于存放待调度的 Pod，优先级高的会放在队列头部，优先被调度。该队列存放的 Pod 可能的情况有：刚创建未被调度的Pod；backOffPod 队列中转移过来的Pod；unschedule 队列里转移过来的 Pod；</li><li>podBackoffQ 也是一个优先队列，用于存放那些异常的Pod，这种 Pod 需要等待一定的时间才能够被再次调度，会有协程定期去读取这个队列，然后加入到 activeQ 队列然后重新调度；</li><li>unschedulablePods 严格上来说不属于队列，用于存放调度失败的 Pod。这个队列也会有协程定期（默认30s）去读取，然后判断当前时间距离上次调度时间的差是否超过5min，如果超过这个时间则把 Pod 移动到 activeQ 重新调度；</li></ul><p>PriorityQueue 还有两个方法 flushBackoffQCompleted 与 flushUnschedulablePodsLeftover。</p><ul><li>flushUnschedulablePodsLeftover：调度失败的 Pod 如果满足一定条件，这个函数会将这种 Pod 移动到 activeQ 或 podBackoffQ；</li><li>flushBackoffQCompleted：运行异常的 Pod 等待时间完成后，flushBackoffQCompleted 将该 Pod 移动到 activeQ；</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Run starts the goroutine to pump from podBackoffQ to activeQ
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>Run</span>(logger klog.Logger) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>Until</span>(<span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		p.<span style=color:#50fa7b>flushBackoffQCompleted</span>(logger)
</span></span><span style=display:flex><span>	}, <span style=color:#bd93f9>1.0</span><span style=color:#ff79c6>*</span>time.Second, p.stop)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>Until</span>(<span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		p.<span style=color:#50fa7b>flushUnschedulablePodsLeftover</span>(logger)
</span></span><span style=display:flex><span>	}, <span style=color:#bd93f9>30</span><span style=color:#ff79c6>*</span>time.Second, p.stop)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Scheduler 在启动的时候，会创建2个协程来定期运行这两个函数。除了周期性的执行上述函数，还有新节点加入集群、节点配置或状态发生变化、已经存在的 Pod 发生变化、集群内有Pod被删除等事件会触发。</p><h2 id=schedulercache>SchedulerCache</h2><p>scheduler Cache 缓存 Pod，Node 等信息，各个扩展点的插件在计算时所需要的 Node 和 Pod 信息都是从 scheduler Cache 获取。Scheduler 在启动时首先会 list 一份全量的 Pod 和 Node 数据到上述的缓存中，后续通过 watch 的方式发现变化的 Node 和 Pod，然后将变化的 Node 或 Pod 更新到上述缓存中。scheduler Cache 具体在内部是一个实现了 Cache 接口的结构体 cacheImpl，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Cache collects pods&#39; information and provides node-level aggregated information.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// It&#39;s intended for generic scheduler to do efficient lookup.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Cache&#39;s operations are pod centric. It does incremental updates based on pod events.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Pod events are sent via network. We don&#39;t have guaranteed delivery of all events:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// We use Reflector to list and watch from remote.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Reflector might be slow and do a relist, which would lead to missing events.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// State Machine of a pod&#39;s events in scheduler&#39;s cache:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	+-------------------------------------------+  +----+
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                            Add            |  |    |
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                                           |  |    | Update
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	+      Assume                Add            v  v    |
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Initial +--------&gt; Assumed +------------+---&gt; Added &lt;--+
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	^                +   +               |       +
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                |   |               |       |
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                |   |           Add |       | Remove
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                |   |               |       |
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	|                |   |               +       |
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	+----------------+   +-----------&gt; Expired   +----&gt; Deleted
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//	      Forget             Expire
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Note that an assumed pod can expire, because if we haven&#39;t received Add event notifying us
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// for a while, there might be some problems and we shouldn&#39;t keep the pod in cache anymore.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Note that &#34;Initial&#34;, &#34;Expired&#34;, and &#34;Deleted&#34; pods do not actually exist in cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// Based on existing use cases, we are making the following assumptions:
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - No pod would be assumed twice
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - A pod could be added without going through scheduler. In this case, we will see Add but not Assume event.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - If a pod wasn&#39;t added, it wouldn&#39;t be removed or updated.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   - Both &#34;Expired&#34; and &#34;Deleted&#34; are valid end states. In case of some problems, e.g. network issue,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     a pod might have changed its state (e.g. added and deleted) without delivering notification to the cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>type</span> Cache <span style=color:#8be9fd;font-style:italic>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// NodeCount returns the number of nodes in the cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// DO NOT use outside of tests.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>NodeCount</span>() <span style=color:#8be9fd>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// PodCount returns the number of pods in the cache (including those from deleted nodes).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// DO NOT use outside of tests.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>PodCount</span>() (<span style=color:#8be9fd>int</span>, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// AssumePod assumes a pod scheduled and aggregates the pod&#39;s information into its node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The implementation also decides the policy to expire pod before being confirmed (receiving Add event).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// After expiration, its information would be subtracted.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>AssumePod</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// FinishBinding signals that cache for assumed pod can be expired
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>FinishBinding</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// ForgetPod removes an assumed pod from cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>ForgetPod</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// AddPod either confirms a pod if it&#39;s assumed, or adds it back if it&#39;s expired.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// If added back, the pod&#39;s information would be added again.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>AddPod</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// UpdatePod removes oldPod&#39;s information and adds newPod&#39;s information.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>UpdatePod</span>(logger klog.Logger, oldPod, newPod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// RemovePod removes a pod. The pod&#39;s information would be subtracted from assigned node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>RemovePod</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// GetPod returns the pod from the cache with the same namespace and the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// same name of the specified pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>GetPod</span>(pod <span style=color:#ff79c6>*</span>v1.Pod) (<span style=color:#ff79c6>*</span>v1.Pod, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// IsAssumedPod returns true if the pod is assumed and not expired.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>IsAssumedPod</span>(pod <span style=color:#ff79c6>*</span>v1.Pod) (<span style=color:#8be9fd>bool</span>, <span style=color:#8be9fd>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// AddNode adds overall information about node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// It returns a clone of added NodeInfo object.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>AddNode</span>(logger klog.Logger, node <span style=color:#ff79c6>*</span>v1.Node) <span style=color:#ff79c6>*</span>framework.NodeInfo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// UpdateNode updates overall information about node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// It returns a clone of updated NodeInfo object.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>UpdateNode</span>(logger klog.Logger, oldNode, newNode <span style=color:#ff79c6>*</span>v1.Node) <span style=color:#ff79c6>*</span>framework.NodeInfo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// RemoveNode removes overall information about node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>RemoveNode</span>(logger klog.Logger, node <span style=color:#ff79c6>*</span>v1.Node) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// UpdateSnapshot updates the passed infoSnapshot to the current contents of Cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The node info contains aggregated information of pods scheduled (including assumed to be)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// on this node.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The snapshot only includes Nodes that are not deleted at the time this function is called.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// nodeinfo.Node() is guaranteed to be not nil for all the nodes in the snapshot.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>UpdateSnapshot</span>(logger klog.Logger, nodeSnapshot <span style=color:#ff79c6>*</span>Snapshot) <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Dump produces a dump of the current cache.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#50fa7b>Dump</span>() <span style=color:#ff79c6>*</span>Dump
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> cacheImpl <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	stop   <span style=color:#ff79c6>&lt;-</span><span style=color:#8be9fd;font-style:italic>chan</span> <span style=color:#8be9fd;font-style:italic>struct</span>{}
</span></span><span style=display:flex><span>	ttl    time.Duration
</span></span><span style=display:flex><span>	period time.Duration
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// This mutex guards all fields within this cache struct.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	mu sync.RWMutex
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// a set of assumed pod keys.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// The key could further be used to get an entry in podStates.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	assumedPods sets.Set[<span style=color:#8be9fd>string</span>]
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// a map from pod key to podState.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podStates <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#ff79c6>*</span>podState
</span></span><span style=display:flex><span>	nodes     <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#ff79c6>*</span>nodeInfoListItem
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// headNode points to the most recently updated NodeInfo in &#34;nodes&#34;. It is the
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// head of the linked list.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	headNode <span style=color:#ff79c6>*</span>nodeInfoListItem
</span></span><span style=display:flex><span>	nodeTree <span style=color:#ff79c6>*</span>nodeTree
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// A map from image name to its ImageStateSummary.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	imageStates <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#ff79c6>*</span>framework.ImageStateSummary
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>cacheImpl 中的 nodes 存放集群内所有 Node 信息，podStates 存放所有 Pod 信息。assumedPods 存放已经调度成功但是还没调用 kube-apiserver 的进行绑定的（也就是还没有执行 bind 插件）的Pod，需要这个缓存的原因也是为了提升调度效率，将绑定和调度分开，因为绑定需要调用 kube-apiserver，所以 Scheduler 乐观的假设调度已经成功，然后返回去调度其他 Pod，而这个 Pod 就会放入 assumedPods 中，并且也会放入到 podStates 中，后续其他 Pod 在进行调度的时候，这个 Pod 也会在插件的计算范围内（如亲和性），然后会新起协程进行最后的绑定，要是最后绑定失败了，那么这个 Pod 的信息会从 assumedPods 和 podStates 移除，并且把这个 Pod 重新放入 activeQ 中，重新被调度。</p><h2 id=nextpod-和-schedulepod>NextPod 和 SchedulePod</h2><p>Scheduler 中有个成员 NextPod 会从 activeQ 队列中尝试获取一个待调度的 Pod，该函数在 SchedulePod 中被调用，见源码 pkg/scheduler/scheduler.go，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Run begins watching and scheduling. It starts scheduling and blocked until the context is done.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>Run</span>(ctx context.Context) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>	sched.SchedulingQueue.<span style=color:#50fa7b>Run</span>(logger)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// We need to start scheduleOne loop in a dedicated goroutine,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// because scheduleOne function hangs on getting the next item
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// from the SchedulingQueue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// If there are no new pods to schedule, it will be hanging there
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// and if done in this goroutine it will be blocking closing
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// SchedulingQueue, in effect causing a deadlock on shutdown.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>UntilWithContext</span>(ctx, sched.ScheduleOne, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>&lt;-</span>ctx.<span style=color:#50fa7b>Done</span>()
</span></span><span style=display:flex><span>	sched.SchedulingQueue.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// If the plugins satisfy the io.Closer interface, they are closed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	err <span style=color:#ff79c6>:=</span> sched.Profiles.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Failed to close plugins&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 尝试调度 Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ScheduleOne does the entire scheduling workflow for a single pod. It is serialized on the scheduling algorithm&#39;s host fitting.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>ScheduleOne</span>(ctx context.Context) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 会一直阻塞，直到获取到一个Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podInfo, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>NextPod</span>(logger)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error while retrieving next pod from scheduling queue&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pod could be nil when schedulerQueue is closed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> podInfo <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>||</span> podInfo.Pod <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pod <span style=color:#ff79c6>:=</span> podInfo.Pod
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// TODO(knelasevero): Remove duplicated keys from log entry calls
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// When contextualized logging hits GA
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// https://github.com/kubernetes/kubernetes/issues/111672
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	logger = klog.<span style=color:#50fa7b>LoggerWithValues</span>(logger, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	ctx = klog.<span style=color:#50fa7b>NewContext</span>(ctx, logger)
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>4</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;About to try and schedule pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	fwk, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>frameworkForPod</span>(pod)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// This shouldn&#39;t happen, because we only accept for scheduling the pods
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// which specify a scheduler name that matches one of the profiles.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error occurred&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sched.<span style=color:#50fa7b>skipPodSchedule</span>(ctx, fwk, pod) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Attempting to schedule pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Synchronously attempt to find a fit for the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	start <span style=color:#ff79c6>:=</span> time.<span style=color:#50fa7b>Now</span>()
</span></span><span style=display:flex><span>	state <span style=color:#ff79c6>:=</span> framework.<span style=color:#50fa7b>NewCycleState</span>()
</span></span><span style=display:flex><span>	state.<span style=color:#50fa7b>SetRecordPluginMetrics</span>(rand.<span style=color:#50fa7b>Intn</span>(<span style=color:#bd93f9>100</span>) &lt; pluginMetricsSamplePercent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Initialize an empty podsToActivate struct, which will be filled up by plugins or stay empty.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podsToActivate <span style=color:#ff79c6>:=</span> framework.<span style=color:#50fa7b>NewPodsToActivate</span>()
</span></span><span style=display:flex><span>	state.<span style=color:#50fa7b>Write</span>(framework.PodsToActivateKey, podsToActivate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	schedulingCycleCtx, cancel <span style=color:#ff79c6>:=</span> context.<span style=color:#50fa7b>WithCancel</span>(ctx)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> <span style=color:#50fa7b>cancel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	scheduleResult, assumedPodInfo, status <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>schedulingCycle</span>(schedulingCycleCtx, state, fwk, podInfo, start, podsToActivate)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		sched.<span style=color:#50fa7b>FailureHandler</span>(schedulingCycleCtx, fwk, assumedPodInfo, status, scheduleResult.nominatingInfo, start)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>go</span> <span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		bindingCycleCtx, cancel <span style=color:#ff79c6>:=</span> context.<span style=color:#50fa7b>WithCancel</span>(ctx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>defer</span> <span style=color:#50fa7b>cancel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		metrics.Goroutines.<span style=color:#50fa7b>WithLabelValues</span>(metrics.Binding).<span style=color:#50fa7b>Inc</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>defer</span> metrics.Goroutines.<span style=color:#50fa7b>WithLabelValues</span>(metrics.Binding).<span style=color:#50fa7b>Dec</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		status <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>bindingCycle</span>(bindingCycleCtx, state, fwk, scheduleResult, assumedPodInfo, start, podsToActivate)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>			sched.<span style=color:#50fa7b>handleBindingCycleError</span>(bindingCycleCtx, state, fwk, assumedPodInfo, start, scheduleResult, status)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Usually, DonePod is called inside the scheduling queue,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// but in this case, we need to call it here because this Pod won&#39;t go back to the scheduling queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		sched.SchedulingQueue.<span style=color:#50fa7b>Done</span>(assumedPodInfo.Pod.UID)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pop 会一直阻塞，直到 activeQ 长度大于0，然后去取出一个 Pod 返回，Pod() 函数如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Pop removes the head of the active queue and returns it. It blocks if the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// activeQ is empty and waits until a new item is added to the queue. It
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// increments scheduling cycle when a pod is popped.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>Pop</span>(logger klog.Logger) (<span style=color:#ff79c6>*</span>framework.QueuedPodInfo, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> p.activeQ.<span style=color:#50fa7b>Len</span>() <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// When Close() is called, the p.closed is set and the condition is broadcast,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// which causes this loop to continue and return from the Pop().
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> p.closed {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>2</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Scheduling queue is closed&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		p.cond.<span style=color:#50fa7b>Wait</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	obj, err <span style=color:#ff79c6>:=</span> p.activeQ.<span style=color:#50fa7b>Pop</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pInfo <span style=color:#ff79c6>:=</span> obj.(<span style=color:#ff79c6>*</span>framework.QueuedPodInfo)
</span></span><span style=display:flex><span>	pInfo.Attempts<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>	p.schedulingCycle<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// In flight, no concurrent events yet.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> p.isSchedulingQueueHintEnabled {
</span></span><span style=display:flex><span>		p.inFlightPods[pInfo.Pod.UID] = p.inFlightEvents.<span style=color:#50fa7b>PushBack</span>(pInfo.Pod)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Update metrics and reset the set of unschedulable plugins for the next attempt.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> plugin <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> pInfo.UnschedulablePlugins.<span style=color:#50fa7b>Union</span>(pInfo.PendingPlugins) {
</span></span><span style=display:flex><span>		metrics.<span style=color:#50fa7b>UnschedulableReason</span>(plugin, pInfo.Pod.Spec.SchedulerName).<span style=color:#50fa7b>Dec</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pInfo.UnschedulablePlugins.<span style=color:#50fa7b>Clear</span>()
</span></span><span style=display:flex><span>	pInfo.PendingPlugins.<span style=color:#50fa7b>Clear</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> pInfo, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=informer>Informer</h2><p>在 k8s 的所有组件包括 controller-manager，kube-proxy，kubelet 等都使用了 informer 来监听 kube-apiserver 来获取资源的变化。kube-scheduler 使用 informer 监听 Node, Pod, CSINode, CSIDriver, CSIStorageCapacity, PersistentVolume, PersistentVolumeClaim, StorageClass。为什么要监听后面那些资源呢？</p><p>后面的那些资源都是跟存储有关，在 preFilter 和 filter 扩展点的插件里面有 Volumebinding 这么一个插件，是检查系统当前是否能够满足 Pod 声明的 PVC，如果不能满足，那么只能把 Pod 放入 unscheduleableQ 里。但是如果系统可以满足 Pod 对存储的需要，Pod 需要第一时间能够被创建出来，所以系统必须要能够实时感知到系统 PVC 等资源的变化及时将 unscheduleableQ 里面调度失败的 Pod 进行重新调度。</p><h1 id=pod-调度过程>Pod 调度过程</h1><p>Pod 是怎么被调度到某个 Node，主要步骤如下所示：</p><ol><li>【监听 Pod】从 activeQ 队列中获取需要被调度的 Pod；</li><li>【取出 Pod】在调度周期（Scheduling Cycle）运行每个扩展点的所有插件，给 Pod 选择一个最合适的 Node；</li><li>【调度 Pod】在绑定周期（Binding Cycle）将 Pod 绑定到选出来的 Node；</li></ol><p><img src=/images/2024-04-06-scheduler-framework-01/8.svg alt></p><h2 id=监听-pod>监听 Pod</h2><p>kube-scheduler 会 list-watch Pod 事件，监测到 Pod 需要被调度后，将待调度的 Pod 分为两种情况：已经调度过的 Pod 和未调度的 Pod。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// addAllEventHandlers is a helper function used in tests and in Scheduler
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// to add event handlers for various informers.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>addAllEventHandlers</span>(
</span></span><span style=display:flex><span>	sched <span style=color:#ff79c6>*</span>Scheduler,
</span></span><span style=display:flex><span>	informerFactory informers.SharedInformerFactory,
</span></span><span style=display:flex><span>	dynInformerFactory dynamicinformer.DynamicSharedInformerFactory,
</span></span><span style=display:flex><span>	gvkMap <span style=color:#8be9fd;font-style:italic>map</span>[framework.GVK]framework.ActionType,
</span></span><span style=display:flex><span>) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> (
</span></span><span style=display:flex><span>		handlerRegistration cache.ResourceEventHandlerRegistration
</span></span><span style=display:flex><span>		err                 <span style=color:#8be9fd>error</span>
</span></span><span style=display:flex><span>		handlers            []cache.ResourceEventHandlerRegistration
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// scheduled pod cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 已经调度过的 Pod 则加到本地缓存，并判断是加入到调度队列还是加入到backoff队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> handlerRegistration, err = informerFactory.<span style=color:#50fa7b>Core</span>().<span style=color:#50fa7b>V1</span>().<span style=color:#50fa7b>Pods</span>().<span style=color:#50fa7b>Informer</span>().<span style=color:#50fa7b>AddEventHandler</span>(
</span></span><span style=display:flex><span>		cache.FilteringResourceEventHandler{
</span></span><span style=display:flex><span>			FilterFunc: <span style=color:#8be9fd;font-style:italic>func</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>switch</span> t <span style=color:#ff79c6>:=</span> obj.(<span style=color:#8be9fd;font-style:italic>type</span>) {
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>case</span> <span style=color:#ff79c6>*</span>v1.Pod:
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>assignedPod</span>(t)
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>case</span> cache.DeletedFinalStateUnknown:
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>if</span> _, ok <span style=color:#ff79c6>:=</span> t.Obj.(<span style=color:#ff79c6>*</span>v1.Pod); ok {
</span></span><span style=display:flex><span>						<span style=color:#6272a4>// The carried object may be stale, so we don&#39;t use it to check if
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>						<span style=color:#6272a4>// it&#39;s assigned or not. Attempting to cleanup anyways.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>						<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					utilruntime.<span style=color:#50fa7b>HandleError</span>(fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;unable to convert object %T to *v1.Pod in %T&#34;</span>, obj, sched))
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>					utilruntime.<span style=color:#50fa7b>HandleError</span>(fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;unable to handle object in %T: %T&#34;</span>, sched, obj))
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>			Handler: cache.ResourceEventHandlerFuncs{
</span></span><span style=display:flex><span>				AddFunc:    sched.addPodToCache,
</span></span><span style=display:flex><span>				UpdateFunc: sched.updatePodInCache,
</span></span><span style=display:flex><span>				DeleteFunc: sched.deletePodFromCache,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	handlers = <span style=color:#8be9fd;font-style:italic>append</span>(handlers, handlerRegistration)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// unscheduled pod queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 没有调度过的 Pod，放到调度队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> handlerRegistration, err = informerFactory.<span style=color:#50fa7b>Core</span>().<span style=color:#50fa7b>V1</span>().<span style=color:#50fa7b>Pods</span>().<span style=color:#50fa7b>Informer</span>().<span style=color:#50fa7b>AddEventHandler</span>(
</span></span><span style=display:flex><span>		cache.FilteringResourceEventHandler{
</span></span><span style=display:flex><span>			FilterFunc: <span style=color:#8be9fd;font-style:italic>func</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>switch</span> t <span style=color:#ff79c6>:=</span> obj.(<span style=color:#8be9fd;font-style:italic>type</span>) {
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>case</span> <span style=color:#ff79c6>*</span>v1.Pod:
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> !<span style=color:#50fa7b>assignedPod</span>(t) <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>responsibleForPod</span>(t, sched.Profiles)
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>case</span> cache.DeletedFinalStateUnknown:
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>if</span> pod, ok <span style=color:#ff79c6>:=</span> t.Obj.(<span style=color:#ff79c6>*</span>v1.Pod); ok {
</span></span><span style=display:flex><span>						<span style=color:#6272a4>// The carried object may be stale, so we don&#39;t use it to check if
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>						<span style=color:#6272a4>// it&#39;s assigned or not.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>						<span style=color:#ff79c6>return</span> <span style=color:#50fa7b>responsibleForPod</span>(pod, sched.Profiles)
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					utilruntime.<span style=color:#50fa7b>HandleError</span>(fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;unable to convert object %T to *v1.Pod in %T&#34;</span>, obj, sched))
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>					utilruntime.<span style=color:#50fa7b>HandleError</span>(fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;unable to handle object in %T: %T&#34;</span>, sched, obj))
</span></span><span style=display:flex><span>					<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>			Handler: cache.ResourceEventHandlerFuncs{
</span></span><span style=display:flex><span>				AddFunc:    sched.addPodToSchedulingQueue,
</span></span><span style=display:flex><span>				UpdateFunc: sched.updatePodInSchedulingQueue,
</span></span><span style=display:flex><span>				DeleteFunc: sched.deletePodFromSchedulingQueue,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	handlers = <span style=color:#8be9fd;font-style:italic>append</span>(handlers, handlerRegistration)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 监听 Node 事件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> handlerRegistration, err = informerFactory.<span style=color:#50fa7b>Core</span>().<span style=color:#50fa7b>V1</span>().<span style=color:#50fa7b>Nodes</span>().<span style=color:#50fa7b>Informer</span>().<span style=color:#50fa7b>AddEventHandler</span>(
</span></span><span style=display:flex><span>		cache.ResourceEventHandlerFuncs{
</span></span><span style=display:flex><span>			AddFunc:    sched.addNodeToCache,
</span></span><span style=display:flex><span>			UpdateFunc: sched.updateNodeInCache,
</span></span><span style=display:flex><span>			DeleteFunc: sched.deleteNodeFromCache,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	handlers = <span style=color:#8be9fd;font-style:italic>append</span>(handlers, handlerRegistration)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>	buildEvtResHandler <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>func</span>(at framework.ActionType, gvk framework.GVK, shortGVK <span style=color:#8be9fd>string</span>) cache.ResourceEventHandlerFuncs {
</span></span><span style=display:flex><span>		funcs <span style=color:#ff79c6>:=</span> cache.ResourceEventHandlerFuncs{}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> at<span style=color:#ff79c6>&amp;</span>framework.Add <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			evt <span style=color:#ff79c6>:=</span> framework.ClusterEvent{Resource: gvk, ActionType: framework.Add, Label: fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;%vAdd&#34;</span>, shortGVK)}
</span></span><span style=display:flex><span>			funcs.AddFunc = <span style=color:#8be9fd;font-style:italic>func</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 将 Pod 加入 Active 队列或者 Backoff 队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>				sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, evt, <span style=color:#ff79c6>nil</span>, obj, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> at<span style=color:#ff79c6>&amp;</span>framework.Update <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			evt <span style=color:#ff79c6>:=</span> framework.ClusterEvent{Resource: gvk, ActionType: framework.Update, Label: fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;%vUpdate&#34;</span>, shortGVK)}
</span></span><span style=display:flex><span>			funcs.UpdateFunc = <span style=color:#8be9fd;font-style:italic>func</span>(old, obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 将 Pod 加入 Active 队列或者 Backoff 队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>				sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, evt, old, obj, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> at<span style=color:#ff79c6>&amp;</span>framework.Delete <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			evt <span style=color:#ff79c6>:=</span> framework.ClusterEvent{Resource: gvk, ActionType: framework.Delete, Label: fmt.<span style=color:#50fa7b>Sprintf</span>(<span style=color:#f1fa8c>&#34;%vDelete&#34;</span>, shortGVK)}
</span></span><span style=display:flex><span>			funcs.DeleteFunc = <span style=color:#8be9fd;font-style:italic>func</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 将 Pod 加入 Active 队列或者 Backoff 队列
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>				sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, evt, obj, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> funcs
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 监听 CSINode、CSIDriver、CSIStorageCapacity、PersistentVolume、PersistentVolumeClaim、PodSchedulingContext、
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// ResourceClaim、ResourceClass、ResourceClaimParameters、ResourceClassParameters、StorageClass 等事件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> gvk, at <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> gvkMap {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>switch</span> gvk {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.Node, framework.Pod:
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// Do nothing.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>case</span> framework.CSINode:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.CSIDriver:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.CSIStorageCapacity:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.PersistentVolume:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.PersistentVolumeClaim:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.PodSchedulingContext:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.ResourceClaim:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.ResourceClass:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.ResourceClaimParameters:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.ResourceClassParameters:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>case</span> framework.StorageClass:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	sched.registeredHandlers = handlers
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=已调度-pod>已调度 Pod</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// assignedPod selects pods that are assigned (scheduled and running).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>assignedPod</span>(pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>len</span>(pod.Spec.NodeName) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过代码 len(pod.Spec.NodeName) != 0 来判断是不是已调度过的 Pod，因为调度过的 Pod 这个字段总是会被赋予被选中的 Node 名称。但是，既然是调度过的 Pod，那代码中为什么还要区分 sched.addPodToCache 和 sched.updatePodInCache？原因在于可以在创建 Pod 时给它分配一个 Node（即给 pod.Spec.NodeName 赋值），kube-scheduler 在监听到该 Pod 后，判断这个 Pod 该字段不为空就会认为这个 Pod 已经被调度，就不太合理。</p><p>在监听到 Pod 后 sched.addPodToCache 和 sched.updatePodInCache 哪个会被调用，这是 Informer 所决定的，它会根据监听到变化的 Pod 和 Informer 的本地缓存做对比，要是缓存中没有这个 Pod，那么就调用 add 函数，否则就调用 update 函数。加入或更新缓存后，还需要去 unschedulablePods（调度失败的Pod） 中获取 Pod，这些 Pod 的亲和性和刚刚加入的这个 Pod 匹配，然后根据下面的规则判断是把 Pod 放入 backoffQ 还是放入 activeQ。</p><ul><li>根据 Pod 尝试被调度的次数计算这个 Pod 下次调度应该等待的时间，计算规则为指数级增长，即按照1s、2s、4s、8s时间进行等待，但是等待时间也不会无限增加，会受到 podMaxBackoffDuration（默认10s） 限制，参数表示 Pod 处于 backoff 的最大时间，如果等待的时间如果超过了 podMaxBackoffDuration，那么就只等待 podMaxBackoffDuration 就会再次被调度；</li><li>当前时间 - 上次调度的时间 > 根据步骤 1 获取到的应该等待的时间，如果大于等待时间则把Pod放到activeQ里面，否则Pod被放入 backoff 队列里继续等待；</li></ul><p>从上面可以看到，一个 Pod 的变更会触发此前调度失败的 Pod 被重新调度。</p><h2 id=未调度-pod>未调度 Pod</h2><p>如果 pod.Spec.NodeName 为空，那么 Pod 可能是没有被调度过或者是此前调度过但是调度失败的，没有调度过的 Pod 直接加入到 activeQ，调度失败的 Pod 则根据上述规则判断是加入 backoffQ 队列还是 activeQ 队列，加入到 activeQ 会马上被取走，然后开始调度。因为调度失败而被放入 unscheduleable 的 Pod 还可以重新被调度么，有两种途径可以实现重新被调度。</p><ul><li>定期将 unscheduleable 的 Pod 放入 backoffQ 或 activeQ，或者定期将 backoffQ 等待超时的 Pod 放入 activeQ；</li><li>集群内其他相关资源（Node、Pod、CSI等）发生变化时，判断 unscheduleable 中的 Pod 是不是要放入 backoffQ 或 activeQ；</li></ul><p>对于第一种方式，在 kube-scheduler 启动的时候中会起两个协程，周期性将不可调度的 Pod 放入 backoffQ 或者 activeQ 队列，或者将 backoffQ 中超时的 Pod 放入 activeQ 队列；</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Run starts the goroutine to pump from podBackoffQ to activeQ
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>Run</span>(logger klog.Logger) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>Until</span>(<span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		p.<span style=color:#50fa7b>flushBackoffQCompleted</span>(logger)
</span></span><span style=display:flex><span>	}, <span style=color:#bd93f9>1.0</span><span style=color:#ff79c6>*</span>time.Second, p.stop)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>Until</span>(<span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		p.<span style=color:#50fa7b>flushUnschedulablePodsLeftover</span>(logger)
</span></span><span style=display:flex><span>	}, <span style=color:#bd93f9>30</span><span style=color:#ff79c6>*</span>time.Second, p.stop)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// flushBackoffQCompleted Moves all pods from backoffQ which have completed backoff in to activeQ
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>flushBackoffQCompleted</span>(logger klog.Logger) {
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>	activated <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		rawPodInfo <span style=color:#ff79c6>:=</span> p.podBackoffQ.<span style=color:#50fa7b>Peek</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> rawPodInfo <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		pInfo <span style=color:#ff79c6>:=</span> rawPodInfo.(<span style=color:#ff79c6>*</span>framework.QueuedPodInfo)
</span></span><span style=display:flex><span>		pod <span style=color:#ff79c6>:=</span> pInfo.Pod
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> p.<span style=color:#50fa7b>isPodBackingoff</span>(pInfo) {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		_, err <span style=color:#ff79c6>:=</span> p.podBackoffQ.<span style=color:#50fa7b>Pop</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Unable to pop pod from backoff queue despite backoff completion&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> added, _ <span style=color:#ff79c6>:=</span> p.<span style=color:#50fa7b>addToActiveQ</span>(logger, pInfo); added {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>5</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Pod moved to an internal scheduling queue&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod), <span style=color:#f1fa8c>&#34;event&#34;</span>, BackoffComplete, <span style=color:#f1fa8c>&#34;queue&#34;</span>, activeQ)
</span></span><span style=display:flex><span>			metrics.SchedulerQueueIncomingPods.<span style=color:#50fa7b>WithLabelValues</span>(<span style=color:#f1fa8c>&#34;active&#34;</span>, BackoffComplete).<span style=color:#50fa7b>Inc</span>()
</span></span><span style=display:flex><span>			activated = <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> activated {
</span></span><span style=display:flex><span>		p.cond.<span style=color:#50fa7b>Broadcast</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// flushUnschedulablePodsLeftover moves pods which stay in unschedulablePods
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// longer than podMaxInUnschedulablePodsDuration to backoffQ or activeQ.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>flushUnschedulablePodsLeftover</span>(logger klog.Logger) {
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> podsToMove []<span style=color:#ff79c6>*</span>framework.QueuedPodInfo
</span></span><span style=display:flex><span>	currentTime <span style=color:#ff79c6>:=</span> p.clock.<span style=color:#50fa7b>Now</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> _, pInfo <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> p.unschedulablePods.podInfoMap {
</span></span><span style=display:flex><span>		lastScheduleTime <span style=color:#ff79c6>:=</span> pInfo.Timestamp
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 	DefaultPodMaxInUnschedulablePodsDuration time.Duration = 5 * time.Minute
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> currentTime.<span style=color:#50fa7b>Sub</span>(lastScheduleTime) &gt; p.podMaxInUnschedulablePodsDuration {
</span></span><span style=display:flex><span>			podsToMove = <span style=color:#8be9fd;font-style:italic>append</span>(podsToMove, pInfo)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(podsToMove) &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		p.<span style=color:#50fa7b>movePodsToActiveOrBackoffQueue</span>(logger, podsToMove, UnschedulableTimeout, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>flushBackoffQCompleted 去 backoffQ 获取等待结束的 Pod，放入 activeQ 队列。将在 unscheduleable 里面停留时长超过 podMaxInUnschedulablePodsDuration（默认是 5min）的pod放入到 ActiveQ 或 BackoffQueue，具体是放到哪个队列里面，还是根据上文说的计算规则进行判断。</p><p>第二种方式，Kubernetes 集群中的资源发生变更会触发 Pod 被重新调度，如新增或者删除Node、Node 配置发生变更、已存在的 Pod 发生变更、新增或者删除 Pod、PV与PVC发生变更。Node 节点事件（新增 Node 节点、Node 节点配置更新等事件）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>addAllEventHandlers</span>(
</span></span><span style=display:flex><span>    sched <span style=color:#ff79c6>*</span>Scheduler,
</span></span><span style=display:flex><span>    informerFactory informers.SharedInformerFactory,
</span></span><span style=display:flex><span>    dynInformerFactory dynamicinformer.DynamicSharedInformerFactory,
</span></span><span style=display:flex><span>    gvkMap <span style=color:#8be9fd;font-style:italic>map</span>[framework.GVK]framework.ActionType,
</span></span><span style=display:flex><span>) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> handlerRegistration, err = informerFactory.<span style=color:#50fa7b>Core</span>().<span style=color:#50fa7b>V1</span>().<span style=color:#50fa7b>Nodes</span>().<span style=color:#50fa7b>Informer</span>().<span style=color:#50fa7b>AddEventHandler</span>(
</span></span><span style=display:flex><span>		cache.ResourceEventHandlerFuncs{
</span></span><span style=display:flex><span>			AddFunc:    sched.addNodeToCache,
</span></span><span style=display:flex><span>			UpdateFunc: sched.updateNodeInCache,
</span></span><span style=display:flex><span>			DeleteFunc: sched.deleteNodeFromCache,
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	handlers = <span style=color:#8be9fd;font-style:italic>append</span>(handlers, handlerRegistration)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>......</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>addNodeToCache</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>	node, ok <span style=color:#ff79c6>:=</span> obj.(<span style=color:#ff79c6>*</span>v1.Node)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert to *v1.Node&#34;</span>, <span style=color:#f1fa8c>&#34;obj&#34;</span>, obj)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Add event for node&#34;</span>, <span style=color:#f1fa8c>&#34;node&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(node))
</span></span><span style=display:flex><span>	nodeInfo <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>AddNode</span>(logger, node)
</span></span><span style=display:flex><span>	sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, queue.NodeAdd, <span style=color:#ff79c6>nil</span>, node, <span style=color:#50fa7b>preCheckForNode</span>(nodeInfo))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>preCheckForNode</span>(nodeInfo <span style=color:#ff79c6>*</span>framework.NodeInfo) queue.PreEnqueueCheck {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Note: the following checks doesn&#39;t take preemption into considerations, in very rare
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// cases (e.g., node resizing), &#34;pod&#34; may still fail a check but preemption helps. We deliberately
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// chose to ignore those cases as unschedulable pods will be re-queued eventually.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>func</span>(pod <span style=color:#ff79c6>*</span>v1.Pod) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>		admissionResults <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>AdmissionCheck</span>(pod, nodeInfo, <span style=color:#ff79c6>false</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(admissionResults) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		_, isUntolerated <span style=color:#ff79c6>:=</span> corev1helpers.<span style=color:#50fa7b>FindMatchingUntoleratedTaint</span>(nodeInfo.<span style=color:#50fa7b>Node</span>().Spec.Taints, pod.Spec.Tolerations, <span style=color:#8be9fd;font-style:italic>func</span>(t <span style=color:#ff79c6>*</span>v1.Taint) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> t.Effect <span style=color:#ff79c6>==</span> v1.TaintEffectNoSchedule
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> !isUntolerated
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// AdmissionCheck calls the filtering logic of noderesources/nodeport/nodeAffinity/nodename
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// and returns the failure reasons. It&#39;s used in kubelet(pkg/kubelet/lifecycle/predicate.go) and scheduler.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// It returns the first failure if `includeAllFailures` is set to false; otherwise
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// returns all failures.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>AdmissionCheck</span>(pod <span style=color:#ff79c6>*</span>v1.Pod, nodeInfo <span style=color:#ff79c6>*</span>framework.NodeInfo, includeAllFailures <span style=color:#8be9fd>bool</span>) []AdmissionResult {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> admissionResults []AdmissionResult
</span></span><span style=display:flex><span>    insufficientResources <span style=color:#ff79c6>:=</span> noderesources.<span style=color:#50fa7b>Fits</span>(pod, nodeInfo)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断资源是否足够 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(insufficientResources) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> insufficientResources {
</span></span><span style=display:flex><span>            admissionResults = <span style=color:#8be9fd;font-style:italic>append</span>(admissionResults, AdmissionResult{InsufficientResource: <span style=color:#ff79c6>&amp;</span>insufficientResources[i]})
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !includeAllFailures {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> admissionResults
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Node 节点亲和性
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> matches, _ <span style=color:#ff79c6>:=</span> corev1nodeaffinity.<span style=color:#50fa7b>GetRequiredNodeAffinity</span>(pod).<span style=color:#50fa7b>Match</span>(nodeInfo.<span style=color:#50fa7b>Node</span>()); !matches {
</span></span><span style=display:flex><span>        admissionResults = <span style=color:#8be9fd;font-style:italic>append</span>(admissionResults, AdmissionResult{Name: nodeaffinity.Name, Reason: nodeaffinity.ErrReasonPod})
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !includeAllFailures {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> admissionResults
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断 Node Name 是否匹配 
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> !nodename.<span style=color:#50fa7b>Fits</span>(pod, nodeInfo) {
</span></span><span style=display:flex><span>        admissionResults = <span style=color:#8be9fd;font-style:italic>append</span>(admissionResults, AdmissionResult{Name: nodename.Name, Reason: nodename.ErrReason})
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !includeAllFailures {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> admissionResults
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 判断节点 port 端口是否匹配
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> !nodeports.<span style=color:#50fa7b>Fits</span>(pod, nodeInfo) {
</span></span><span style=display:flex><span>        admissionResults = <span style=color:#8be9fd;font-style:italic>append</span>(admissionResults, AdmissionResult{Name: nodeports.Name, Reason: nodeports.ErrReason})
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !includeAllFailures {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> admissionResults
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> admissionResults
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>updateNodeInCache</span>(oldObj, newObj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>    logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>    oldNode, ok <span style=color:#ff79c6>:=</span> oldObj.(<span style=color:#ff79c6>*</span>v1.Node)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert oldObj to *v1.Node&#34;</span>, <span style=color:#f1fa8c>&#34;oldObj&#34;</span>, oldObj)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    newNode, ok <span style=color:#ff79c6>:=</span> newObj.(<span style=color:#ff79c6>*</span>v1.Node)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert newObj to *v1.Node&#34;</span>, <span style=color:#f1fa8c>&#34;newObj&#34;</span>, newObj)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>4</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Update event for node&#34;</span>, <span style=color:#f1fa8c>&#34;node&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(newNode))
</span></span><span style=display:flex><span>    nodeInfo <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>UpdateNode</span>(logger, oldNode, newNode)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Only requeue unschedulable pods if the node became more schedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>for</span> _, evt <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> <span style=color:#50fa7b>nodeSchedulingPropertiesChange</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>        sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, evt, oldNode, newNode, <span style=color:#50fa7b>preCheckForNode</span>(nodeInfo))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>nodeSchedulingPropertiesChange</span>(newNode <span style=color:#ff79c6>*</span>v1.Node, oldNode <span style=color:#ff79c6>*</span>v1.Node) []framework.ClusterEvent {
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> events []framework.ClusterEvent
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点可调度变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeSpecUnschedulableChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeSpecUnschedulableChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点可分配资源变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeAllocatableChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeAllocatableChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点标签变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeLabelsChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeLabelChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点污点变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeTaintsChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeTaintChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点状态变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeConditionsChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeConditionChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 节点注解变更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>nodeAnnotationsChanged</span>(newNode, oldNode) {
</span></span><span style=display:flex><span>		events = <span style=color:#8be9fd;font-style:italic>append</span>(events, queue.NodeAnnotationChange)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> events
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当新增 Node 节点时，以下因素可能会触发未被调度的Pod加入到 backoffQ 队列或者 activeQ 队列。</p><ul><li>Pod 对 Node 节点的亲和性；</li><li>Pod 中 Nodename 不为空，判断新加入节点的 Name 与 pod Nodename 是否相等；</li><li>判断 Pod 中容器对端口的要求是否和新加入节点已经被使用的端口冲突；</li><li>Pod 是否容忍了 Node 的已调度的 Pod；</li></ul><p>当 Node 节点配置发生变更时，以下因素可能会触发未被调度的Pod加入到 backoffQ 队列或者 activeQ 队列。</p><ul><li>节点可调度变更</li><li>节点可分配资源变更</li><li>节点标签变更</li><li>节点污点变更</li><li>节点状态变更</li><li>节点注解变更</li></ul><p>Pod 事件（新增 Pod、删除 Pod 等事件）。已经存在的Pod发生变更后，会把这个Pod亲和性配置依次和 unscheduleable 里面的Pod匹配，如果能够匹配上，那么Pod更新这个事件才会触发这个未被调度的Pod加入到 backoffQ 队列或者 activeQ 队列。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// addAllEventHandlers is a helper function used in tests and in Scheduler
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// to add event handlers for various informers.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>addAllEventHandlers</span>(
</span></span><span style=display:flex><span>	sched <span style=color:#ff79c6>*</span>Scheduler,
</span></span><span style=display:flex><span>	informerFactory informers.SharedInformerFactory,
</span></span><span style=display:flex><span>	dynInformerFactory dynamicinformer.DynamicSharedInformerFactory,
</span></span><span style=display:flex><span>	gvkMap <span style=color:#8be9fd;font-style:italic>map</span>[framework.GVK]framework.ActionType,
</span></span><span style=display:flex><span>) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// scheduled pod cache
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> handlerRegistration, err = informerFactory.<span style=color:#50fa7b>Core</span>().<span style=color:#50fa7b>V1</span>().<span style=color:#50fa7b>Pods</span>().<span style=color:#50fa7b>Informer</span>().<span style=color:#50fa7b>AddEventHandler</span>(
</span></span><span style=display:flex><span>		cache.FilteringResourceEventHandler{
</span></span><span style=display:flex><span>			Handler: cache.ResourceEventHandlerFuncs{
</span></span><span style=display:flex><span>				AddFunc:    sched.addPodToCache,
</span></span><span style=display:flex><span>				UpdateFunc: sched.updatePodInCache,
</span></span><span style=display:flex><span>				DeleteFunc: sched.deletePodFromCache,
</span></span><span style=display:flex><span>			},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 添加 Pod 事件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>addPodToCache</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>	pod, ok <span style=color:#ff79c6>:=</span> obj.(<span style=color:#ff79c6>*</span>v1.Pod)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert to *v1.Pod&#34;</span>, <span style=color:#f1fa8c>&#34;obj&#34;</span>, obj)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Add event for scheduled pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>AddPod</span>(logger, pod); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Scheduler cache AddPod failed&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	sched.SchedulingQueue.<span style=color:#50fa7b>AssignedPodAdded</span>(logger, pod)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// AssignedPodAdded is called when a bound pod is added. Creation of this pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// may make pending pods with matching affinity terms schedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>AssignedPodAdded</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) {
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	p.<span style=color:#50fa7b>movePodsToActiveOrBackoffQueue</span>(logger, p.<span style=color:#50fa7b>getUnschedulablePodsWithMatchingAffinityTerm</span>(logger, pod), AssignedPodAdd, <span style=color:#ff79c6>nil</span>, pod)
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 更新 Pod 事件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>updatePodInCache</span>(oldObj, newObj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>    logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>    oldPod, ok <span style=color:#ff79c6>:=</span> oldObj.(<span style=color:#ff79c6>*</span>v1.Pod)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert oldObj to *v1.Pod&#34;</span>, <span style=color:#f1fa8c>&#34;oldObj&#34;</span>, oldObj)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    newPod, ok <span style=color:#ff79c6>:=</span> newObj.(<span style=color:#ff79c6>*</span>v1.Pod)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert newObj to *v1.Pod&#34;</span>, <span style=color:#f1fa8c>&#34;newObj&#34;</span>, newObj)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>4</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Update event for scheduled pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(oldPod))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>UpdatePod</span>(logger, oldPod, newPod); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Scheduler cache UpdatePod failed&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(oldPod))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sched.SchedulingQueue.<span style=color:#50fa7b>AssignedPodUpdated</span>(logger, oldPod, newPod)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// AssignedPodUpdated is called when a bound pod is updated. Change of labels
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// may make pending pods with matching affinity terms schedulable.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>AssignedPodUpdated</span>(logger klog.Logger, oldPod, newPod <span style=color:#ff79c6>*</span>v1.Pod) {
</span></span><span style=display:flex><span>    p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> <span style=color:#50fa7b>isPodResourcesResizedDown</span>(newPod) {
</span></span><span style=display:flex><span>        p.<span style=color:#50fa7b>moveAllToActiveOrBackoffQueue</span>(logger, AssignedPodUpdate, oldPod, newPod, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        p.<span style=color:#50fa7b>movePodsToActiveOrBackoffQueue</span>(logger, p.<span style=color:#50fa7b>getUnschedulablePodsWithMatchingAffinityTerm</span>(logger, newPod), AssignedPodUpdate, oldPod, newPod)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// getUnschedulablePodsWithMatchingAffinityTerm returns unschedulable pods which have
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// any affinity term that matches &#34;pod&#34;.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// NOTE: this function assumes lock has been acquired in caller.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>getUnschedulablePodsWithMatchingAffinityTerm</span>(logger klog.Logger, pod <span style=color:#ff79c6>*</span>v1.Pod) []<span style=color:#ff79c6>*</span>framework.QueuedPodInfo {
</span></span><span style=display:flex><span>	nsLabels <span style=color:#ff79c6>:=</span> interpodaffinity.<span style=color:#50fa7b>GetNamespaceLabelsSnapshot</span>(logger, pod.Namespace, p.nsLister)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> podsToMove []<span style=color:#ff79c6>*</span>framework.QueuedPodInfo
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> _, pInfo <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> p.unschedulablePods.podInfoMap {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>for</span> _, term <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> pInfo.RequiredAffinityTerms {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> term.<span style=color:#50fa7b>Matches</span>(pod, nsLabels) {
</span></span><span style=display:flex><span>				podsToMove = <span style=color:#8be9fd;font-style:italic>append</span>(podsToMove, pInfo)
</span></span><span style=display:flex><span>				<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> podsToMove
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 删除 Pod 事件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>deletePodFromCache</span>(obj <span style=color:#8be9fd;font-style:italic>interface</span>{}) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> sched.logger
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> pod <span style=color:#ff79c6>*</span>v1.Pod
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> t <span style=color:#ff79c6>:=</span> obj.(<span style=color:#8be9fd;font-style:italic>type</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> <span style=color:#ff79c6>*</span>v1.Pod:
</span></span><span style=display:flex><span>		pod = t
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> cache.DeletedFinalStateUnknown:
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>var</span> ok <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>		pod, ok = t.Obj.(<span style=color:#ff79c6>*</span>v1.Pod)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert to *v1.Pod&#34;</span>, <span style=color:#f1fa8c>&#34;obj&#34;</span>, t.Obj)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Cannot convert to *v1.Pod&#34;</span>, <span style=color:#f1fa8c>&#34;obj&#34;</span>, t)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Delete event for scheduled pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>RemovePod</span>(logger, pod); err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Scheduler cache RemovePod failed&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// preCheckForNode 为空
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	sched.SchedulingQueue.<span style=color:#50fa7b>MoveAllToActiveOrBackoffQueue</span>(logger, queue.AssignedPodDelete, pod, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到Pod删除事件不像其他事件需要做额外的判断，这个preCheck函数是空的，所有 unscheduleable 里面的Pod都会被放到 activeQ 队列或 backoffQ 队列中。</p><h2 id=取出-pod>取出 Pod</h2><p>Scheduler 中有个成员 NextPod 会从 activeQ 队列中尝试获取一个待调度的 Pod，该函数在 SchedulePod 中被调用。见源码 pkg/scheduler/scheduler.go，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Run begins watching and scheduling. It starts scheduling and blocked until the context is done.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 启动 Scheduler
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>Run</span>(ctx context.Context) {
</span></span><span style=display:flex><span>    logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>    sched.SchedulingQueue.<span style=color:#50fa7b>Run</span>(logger)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// We need to start scheduleOne loop in a dedicated goroutine,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// because scheduleOne function hangs on getting the next item
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// from the SchedulingQueue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// If there are no new pods to schedule, it will be hanging there
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// and if done in this goroutine it will be blocking closing
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// SchedulingQueue, in effect causing a deadlock on shutdown.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>go</span> wait.<span style=color:#50fa7b>UntilWithContext</span>(ctx, sched.ScheduleOne, <span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;-</span>ctx.<span style=color:#50fa7b>Done</span>()
</span></span><span style=display:flex><span>    sched.SchedulingQueue.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// If the plugins satisfy the io.Closer interface, they are closed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    err <span style=color:#ff79c6>:=</span> sched.Profiles.<span style=color:#50fa7b>Close</span>()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Failed to close plugins&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 尝试调度 Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ScheduleOne does the entire scheduling workflow for a single pod. It is serialized on the scheduling algorithm&#39;s host fitting.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>ScheduleOne</span>(ctx context.Context) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 会一直阻塞，直到获取到一个Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>......</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// NextPod 对应于 PriorityQueue 的 Pop 函数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    podInfo, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>NextPod</span>(logger)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error while retrieving next pod from scheduling queue&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    pod <span style=color:#ff79c6>:=</span> podInfo.Pod
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>......</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pop 会一直阻塞，直到 activeQ 长度大于0，然后去取出一个 Pod 返回，Pod() 函数如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Pop removes the head of the active queue and returns it. It blocks if the
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// activeQ is empty and waits until a new item is added to the queue. It
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// increments scheduling cycle when a pod is popped.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (p <span style=color:#ff79c6>*</span>PriorityQueue) <span style=color:#50fa7b>Pop</span>(logger klog.Logger) (<span style=color:#ff79c6>*</span>framework.QueuedPodInfo, <span style=color:#8be9fd>error</span>) {
</span></span><span style=display:flex><span>	p.lock.<span style=color:#50fa7b>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> p.lock.<span style=color:#50fa7b>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> p.activeQ.<span style=color:#50fa7b>Len</span>() <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// When Close() is called, the p.closed is set and the condition is broadcast,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// which causes this loop to continue and return from the Pop().
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>if</span> p.closed {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>2</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Scheduling queue is closed&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		p.cond.<span style=color:#50fa7b>Wait</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	obj, err <span style=color:#ff79c6>:=</span> p.activeQ.<span style=color:#50fa7b>Pop</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pInfo <span style=color:#ff79c6>:=</span> obj.(<span style=color:#ff79c6>*</span>framework.QueuedPodInfo)
</span></span><span style=display:flex><span>	pInfo.Attempts<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>	p.schedulingCycle<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// In flight, no concurrent events yet.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> p.isSchedulingQueueHintEnabled {
</span></span><span style=display:flex><span>		p.inFlightPods[pInfo.Pod.UID] = p.inFlightEvents.<span style=color:#50fa7b>PushBack</span>(pInfo.Pod)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Update metrics and reset the set of unschedulable plugins for the next attempt.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>for</span> plugin <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>range</span> pInfo.UnschedulablePlugins.<span style=color:#50fa7b>Union</span>(pInfo.PendingPlugins) {
</span></span><span style=display:flex><span>		metrics.<span style=color:#50fa7b>UnschedulableReason</span>(plugin, pInfo.Pod.Spec.SchedulerName).<span style=color:#50fa7b>Dec</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	pInfo.UnschedulablePlugins.<span style=color:#50fa7b>Clear</span>()
</span></span><span style=display:flex><span>	pInfo.PendingPlugins.<span style=color:#50fa7b>Clear</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> pInfo, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=调度-pod>调度 Pod</h2><p>源码见 pkg/scheduler/schedule_one.go，调度 Pod 到 Node 的过程如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// ScheduleOne does the entire scheduling workflow for a single pod. It is serialized on the scheduling algorithm&#39;s host fitting.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>ScheduleOne</span>(ctx context.Context) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 取出 Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podInfo, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>NextPod</span>(logger)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error while retrieving next pod from scheduling queue&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// pod could be nil when schedulerQueue is closed
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> podInfo <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>||</span> podInfo.Pod <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	pod <span style=color:#ff79c6>:=</span> podInfo.Pod
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// TODO(knelasevero): Remove duplicated keys from log entry calls
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// When contextualized logging hits GA
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// https://github.com/kubernetes/kubernetes/issues/111672
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	logger = klog.<span style=color:#50fa7b>LoggerWithValues</span>(logger, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>	ctx = klog.<span style=color:#50fa7b>NewContext</span>(ctx, logger)
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>4</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;About to try and schedule pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 根据 Pod 名称，获取初始化好的调度框架（framework）
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	fwk, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>frameworkForPod</span>(pod)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// This shouldn&#39;t happen, because we only accept for scheduling the pods
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// which specify a scheduler name that matches one of the profiles.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error occurred&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sched.<span style=color:#50fa7b>skipPodSchedule</span>(ctx, fwk, pod) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Attempting to schedule pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Synchronously attempt to find a fit for the pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	start <span style=color:#ff79c6>:=</span> time.<span style=color:#50fa7b>Now</span>()
</span></span><span style=display:flex><span>	state <span style=color:#ff79c6>:=</span> framework.<span style=color:#50fa7b>NewCycleState</span>()
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 记录指标
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	state.<span style=color:#50fa7b>SetRecordPluginMetrics</span>(rand.<span style=color:#50fa7b>Intn</span>(<span style=color:#bd93f9>100</span>) &lt; pluginMetricsSamplePercent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Initialize an empty podsToActivate struct, which will be filled up by plugins or stay empty.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	podsToActivate <span style=color:#ff79c6>:=</span> framework.<span style=color:#50fa7b>NewPodsToActivate</span>()
</span></span><span style=display:flex><span>	state.<span style=color:#50fa7b>Write</span>(framework.PodsToActivateKey, podsToActivate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	schedulingCycleCtx, cancel <span style=color:#ff79c6>:=</span> context.<span style=color:#50fa7b>WithCancel</span>(ctx)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>defer</span> <span style=color:#50fa7b>cancel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始执行调度周期
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	scheduleResult, assumedPodInfo, status <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>schedulingCycle</span>(schedulingCycleCtx, state, fwk, podInfo, start, podsToActivate)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果获取节点失败，则开始运行 postFilter 开始抢占 Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		sched.<span style=color:#50fa7b>FailureHandler</span>(schedulingCycleCtx, fwk, assumedPodInfo, status, scheduleResult.nominatingInfo, start)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// bind the pod to its host asynchronously (we can do this b/c of the assumption step above).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 主流程到了这里就结束了，然后开始新的一轮调度; 启动一个协程，开始绑定;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>go</span> <span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>		bindingCycleCtx, cancel <span style=color:#ff79c6>:=</span> context.<span style=color:#50fa7b>WithCancel</span>(ctx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>defer</span> <span style=color:#50fa7b>cancel</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		metrics.Goroutines.<span style=color:#50fa7b>WithLabelValues</span>(metrics.Binding).<span style=color:#50fa7b>Inc</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>defer</span> metrics.Goroutines.<span style=color:#50fa7b>WithLabelValues</span>(metrics.Binding).<span style=color:#50fa7b>Dec</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 开始绑定周期 bindingCycle
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		status <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>bindingCycle</span>(bindingCycleCtx, state, fwk, scheduleResult, assumedPodInfo, start, podsToActivate)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>			sched.<span style=color:#50fa7b>handleBindingCycleError</span>(bindingCycleCtx, state, fwk, assumedPodInfo, start, scheduleResult, status)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Usually, DonePod is called inside the scheduling queue,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// but in this case, we need to call it here because this Pod won&#39;t go back to the scheduling queue.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		sched.SchedulingQueue.<span style=color:#50fa7b>Done</span>(assumedPodInfo.Pod.UID)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>源码见 pkg/scheduler/schedule_one.go，调度 Pod 到 Node 的调度周期如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// schedulingCycle tries to schedule a single Pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>schedulingCycle</span>(
</span></span><span style=display:flex><span>	ctx context.Context,
</span></span><span style=display:flex><span>	state <span style=color:#ff79c6>*</span>framework.CycleState,
</span></span><span style=display:flex><span>	fwk framework.Framework,
</span></span><span style=display:flex><span>	podInfo <span style=color:#ff79c6>*</span>framework.QueuedPodInfo,
</span></span><span style=display:flex><span>	start time.Time,
</span></span><span style=display:flex><span>	podsToActivate <span style=color:#ff79c6>*</span>framework.PodsToActivate,
</span></span><span style=display:flex><span>) (ScheduleResult, <span style=color:#ff79c6>*</span>framework.QueuedPodInfo, <span style=color:#ff79c6>*</span>framework.Status) {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>	pod <span style=color:#ff79c6>:=</span> podInfo.Pod
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 开始执行插件，包括 filter, socre 两个扩展点内的所有插件，获取一个最合适 Pod 的节点
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	scheduleResult, err <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>SchedulePod</span>(ctx, fwk, state, pod)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>defer</span> <span style=color:#8be9fd;font-style:italic>func</span>() {
</span></span><span style=display:flex><span>			metrics.SchedulingAlgorithmLatency.<span style=color:#50fa7b>Observe</span>(metrics.<span style=color:#50fa7b>SinceInSeconds</span>(start))
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>==</span> ErrNoNodesAvailable {
</span></span><span style=display:flex><span>			status <span style=color:#ff79c6>:=</span> framework.<span style=color:#50fa7b>NewStatus</span>(framework.UnschedulableAndUnresolvable).<span style=color:#50fa7b>WithError</span>(err)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, podInfo, status
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		fitError, ok <span style=color:#ff79c6>:=</span> err.(<span style=color:#ff79c6>*</span>framework.FitError)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !ok {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(err, <span style=color:#f1fa8c>&#34;Error selecting node for pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod))
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, podInfo, framework.<span style=color:#50fa7b>AsStatus</span>(err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// SchedulePod() may have failed because the pod would not fit on any host, so we try to
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// preempt, with the expectation that the next time the pod is tried for scheduling it
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// will fit due to the preemption. It is also possible that a different pod will schedule
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// into the resources that were preempted, but this is harmless.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !fwk.<span style=color:#50fa7b>HasPostFilterPlugins</span>() {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>3</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;No PostFilter plugins are registered, so no preemption will be performed&#34;</span>)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ScheduleResult{}, podInfo, framework.<span style=color:#50fa7b>NewStatus</span>(framework.Unschedulable).<span style=color:#50fa7b>WithError</span>(err)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Run PostFilter plugins to attempt to make the pod schedulable in a future scheduling cycle.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#6272a4>// 如果获取节点失败，则开始运行 postFilter 开始抢占一个 Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		result, status <span style=color:#ff79c6>:=</span> fwk.<span style=color:#50fa7b>RunPostFilterPlugins</span>(ctx, state, pod, fitError.Diagnosis.NodeToStatusMap)
</span></span><span style=display:flex><span>		msg <span style=color:#ff79c6>:=</span> status.<span style=color:#50fa7b>Message</span>()
</span></span><span style=display:flex><span>		fitError.Diagnosis.PostFilterMsg = msg
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> status.<span style=color:#50fa7b>Code</span>() <span style=color:#ff79c6>==</span> framework.Error {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#f1fa8c>&#34;Status after running PostFilter plugins for pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod), <span style=color:#f1fa8c>&#34;status&#34;</span>, msg)
</span></span><span style=display:flex><span>		} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>5</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Status after running PostFilter plugins for pod&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(pod), <span style=color:#f1fa8c>&#34;status&#34;</span>, msg)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>var</span> nominatingInfo <span style=color:#ff79c6>*</span>framework.NominatingInfo
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> result <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			nominatingInfo = result.NominatingInfo
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: nominatingInfo}, podInfo, framework.<span style=color:#50fa7b>NewStatus</span>(framework.Unschedulable).<span style=color:#50fa7b>WithError</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	metrics.SchedulingAlgorithmLatency.<span style=color:#50fa7b>Observe</span>(metrics.<span style=color:#50fa7b>SinceInSeconds</span>(start))
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Tell the cache to assume that a pod now is running on a given node, even though it hasn&#39;t been bound yet.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#6272a4>// This allows us to keep scheduling without waiting on binding to occur.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	assumedPodInfo <span style=color:#ff79c6>:=</span> podInfo.<span style=color:#50fa7b>DeepCopy</span>()
</span></span><span style=display:flex><span>	assumedPod <span style=color:#ff79c6>:=</span> assumedPodInfo.Pod
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// assume modifies `assumedPod` by setting NodeName=scheduleResult.SuggestedHost
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 将 Pod 放入 assumedPod，即乐观假设 Pod 已经调度成功
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	err = sched.<span style=color:#50fa7b>assume</span>(logger, assumedPod, scheduleResult.SuggestedHost)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// This is most probably result of a BUG in retrying logic.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// We report an error here so that pod scheduling can be retried.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// This relies on the fact that Error will check if the pod has been bound
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// to a node and if so will not add it back to the unscheduled pods queue
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// (otherwise this would cause an infinite loop).
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.<span style=color:#50fa7b>AsStatus</span>(err)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run the Reserve method of reserve plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 运行 Reserve 插件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> sts <span style=color:#ff79c6>:=</span> fwk.<span style=color:#50fa7b>RunReservePluginsReserve</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost); !sts.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// trigger un-reserve to clean up state associated with the reserved Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		fwk.<span style=color:#50fa7b>RunReservePluginsUnreserve</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> forgetErr <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>ForgetPod</span>(logger, assumedPod); forgetErr <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(forgetErr, <span style=color:#f1fa8c>&#34;Scheduler cache ForgetPod failed&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sts.<span style=color:#50fa7b>IsRejected</span>() {
</span></span><span style=display:flex><span>			fitErr <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>framework.FitError{
</span></span><span style=display:flex><span>				NumAllNodes: <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>				Pod:         pod,
</span></span><span style=display:flex><span>				Diagnosis: framework.Diagnosis{
</span></span><span style=display:flex><span>					NodeToStatusMap: framework.NodeToStatusMap{scheduleResult.SuggestedHost: sts},
</span></span><span style=display:flex><span>				},
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			fitErr.Diagnosis.<span style=color:#50fa7b>AddPluginStatus</span>(sts)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.<span style=color:#50fa7b>NewStatus</span>(sts.<span style=color:#50fa7b>Code</span>()).<span style=color:#50fa7b>WithError</span>(fitErr)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, sts
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run &#34;permit&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 运行 Permit 插件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	runPermitStatus <span style=color:#ff79c6>:=</span> fwk.<span style=color:#50fa7b>RunPermitPlugins</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !runPermitStatus.<span style=color:#50fa7b>IsWait</span>() <span style=color:#ff79c6>&amp;&amp;</span> !runPermitStatus.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// trigger un-reserve to clean up state associated with the reserved Pod
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		fwk.<span style=color:#50fa7b>RunReservePluginsUnreserve</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> forgetErr <span style=color:#ff79c6>:=</span> sched.Cache.<span style=color:#50fa7b>ForgetPod</span>(logger, assumedPod); forgetErr <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			logger.<span style=color:#50fa7b>Error</span>(forgetErr, <span style=color:#f1fa8c>&#34;Scheduler cache ForgetPod failed&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> runPermitStatus.<span style=color:#50fa7b>IsRejected</span>() {
</span></span><span style=display:flex><span>			fitErr <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>framework.FitError{
</span></span><span style=display:flex><span>				NumAllNodes: <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>				Pod:         pod,
</span></span><span style=display:flex><span>				Diagnosis: framework.Diagnosis{
</span></span><span style=display:flex><span>					NodeToStatusMap: framework.NodeToStatusMap{scheduleResult.SuggestedHost: runPermitStatus},
</span></span><span style=display:flex><span>				},
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			fitErr.Diagnosis.<span style=color:#50fa7b>AddPluginStatus</span>(runPermitStatus)
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, framework.<span style=color:#50fa7b>NewStatus</span>(runPermitStatus.<span style=color:#50fa7b>Code</span>()).<span style=color:#50fa7b>WithError</span>(fitErr)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> ScheduleResult{nominatingInfo: clearNominatedNode}, assumedPodInfo, runPermitStatus
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// At the end of a successful scheduling cycle, pop and move up Pods if needed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(podsToActivate.Map) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		sched.SchedulingQueue.<span style=color:#50fa7b>Activate</span>(logger, podsToActivate.Map)
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Clear the entries after activation.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		podsToActivate.Map = <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#ff79c6>*</span>v1.Pod)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> scheduleResult, assumedPodInfo, <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>源码见 pkg/scheduler/schedule_one.go，调度 Pod 到 Node 的绑定周期如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// bindingCycle tries to bind an assumed Pod.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd;font-style:italic>func</span> (sched <span style=color:#ff79c6>*</span>Scheduler) <span style=color:#50fa7b>bindingCycle</span>(
</span></span><span style=display:flex><span>	ctx context.Context,
</span></span><span style=display:flex><span>	state <span style=color:#ff79c6>*</span>framework.CycleState,
</span></span><span style=display:flex><span>	fwk framework.Framework,
</span></span><span style=display:flex><span>	scheduleResult ScheduleResult,
</span></span><span style=display:flex><span>	assumedPodInfo <span style=color:#ff79c6>*</span>framework.QueuedPodInfo,
</span></span><span style=display:flex><span>	start time.Time,
</span></span><span style=display:flex><span>	podsToActivate <span style=color:#ff79c6>*</span>framework.PodsToActivate) <span style=color:#ff79c6>*</span>framework.Status {
</span></span><span style=display:flex><span>	logger <span style=color:#ff79c6>:=</span> klog.<span style=color:#50fa7b>FromContext</span>(ctx)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	assumedPod <span style=color:#ff79c6>:=</span> assumedPodInfo.Pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run &#34;permit&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 执行 permit 插件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> status <span style=color:#ff79c6>:=</span> fwk.<span style=color:#50fa7b>WaitOnPermit</span>(ctx, assumedPod); !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> status.<span style=color:#50fa7b>IsRejected</span>() {
</span></span><span style=display:flex><span>			fitErr <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>framework.FitError{
</span></span><span style=display:flex><span>				NumAllNodes: <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>				Pod:         assumedPodInfo.Pod,
</span></span><span style=display:flex><span>				Diagnosis: framework.Diagnosis{
</span></span><span style=display:flex><span>					NodeToStatusMap:      framework.NodeToStatusMap{scheduleResult.SuggestedHost: status},
</span></span><span style=display:flex><span>					UnschedulablePlugins: sets.<span style=color:#50fa7b>New</span>(status.<span style=color:#50fa7b>Plugin</span>()),
</span></span><span style=display:flex><span>				},
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> framework.<span style=color:#50fa7b>NewStatus</span>(status.<span style=color:#50fa7b>Code</span>()).<span style=color:#50fa7b>WithError</span>(fitErr)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> status
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run &#34;prebind&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 执行 preBind 插件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> status <span style=color:#ff79c6>:=</span> fwk.<span style=color:#50fa7b>RunPreBindPlugins</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost); !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> status
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run &#34;bind&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 执行 bind 插件，会调用 kube-apiserver 把调度结果写入 etcd，就是给 Pod 赋予 NodeName
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> status <span style=color:#ff79c6>:=</span> sched.<span style=color:#50fa7b>bind</span>(ctx, fwk, assumedPod, scheduleResult.SuggestedHost, state); !status.<span style=color:#50fa7b>IsSuccess</span>() {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> status
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Calculating nodeResourceString can be heavy. Avoid it if klog verbosity is below 2.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	logger.<span style=color:#50fa7b>V</span>(<span style=color:#bd93f9>2</span>).<span style=color:#50fa7b>Info</span>(<span style=color:#f1fa8c>&#34;Successfully bound pod to node&#34;</span>, <span style=color:#f1fa8c>&#34;pod&#34;</span>, klog.<span style=color:#50fa7b>KObj</span>(assumedPod), <span style=color:#f1fa8c>&#34;node&#34;</span>, scheduleResult.SuggestedHost, <span style=color:#f1fa8c>&#34;evaluatedNodes&#34;</span>, scheduleResult.EvaluatedNodes, <span style=color:#f1fa8c>&#34;feasibleNodes&#34;</span>, scheduleResult.FeasibleNodes)
</span></span><span style=display:flex><span>	metrics.<span style=color:#50fa7b>PodScheduled</span>(fwk.<span style=color:#50fa7b>ProfileName</span>(), metrics.<span style=color:#50fa7b>SinceInSeconds</span>(start))
</span></span><span style=display:flex><span>	metrics.PodSchedulingAttempts.<span style=color:#50fa7b>Observe</span>(<span style=color:#8be9fd;font-style:italic>float64</span>(assumedPodInfo.Attempts))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> assumedPodInfo.InitialAttemptTimestamp <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		metrics.PodSchedulingDuration.<span style=color:#50fa7b>WithLabelValues</span>(<span style=color:#50fa7b>getAttemptsLabel</span>(assumedPodInfo)).<span style=color:#50fa7b>Observe</span>(metrics.<span style=color:#50fa7b>SinceInSeconds</span>(<span style=color:#ff79c6>*</span>assumedPodInfo.InitialAttemptTimestamp))
</span></span><span style=display:flex><span>		metrics.PodSchedulingSLIDuration.<span style=color:#50fa7b>WithLabelValues</span>(<span style=color:#50fa7b>getAttemptsLabel</span>(assumedPodInfo)).<span style=color:#50fa7b>Observe</span>(metrics.<span style=color:#50fa7b>SinceInSeconds</span>(<span style=color:#ff79c6>*</span>assumedPodInfo.InitialAttemptTimestamp))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Run &#34;postbind&#34; plugins.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 执行 postbind 插件
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	fwk.<span style=color:#50fa7b>RunPostBindPlugins</span>(ctx, state, assumedPod, scheduleResult.SuggestedHost)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// At the end of a successful binding cycle, move up Pods if needed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(podsToActivate.Map) <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		sched.SchedulingQueue.<span style=color:#50fa7b>Activate</span>(logger, podsToActivate.Map)
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Unlike the logic in schedulingCycle(), we don&#39;t bother deleting the entries
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>		<span style=color:#6272a4>// as `podsToActivate.Map` is no longer consumed.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pod 调度到 Node 上的流程可以简述如下：</p><ul><li>informer 监听到了有新建 Pod，根据 Pod 的优先级把 Pod 加入到 activeQ 中适当位置（即执行sort插件）；</li><li>scheduler 从 activeQ 队头取一个Pod（如果队列没有Pod可取，则会一直阻塞）；</li><li>执行 filter 类型扩展点（包括preFilter、filter、postFilter）插件，选出所有符合 Pod 的 Node，如果无法找到符合的 Node， 则把 Pod 加入 unscheduleableQ 中，此次调度结束；</li><li>执行 score 扩展点插件，找出最符合 Pod 的 那个Node；</li><li>assume Pod 这一步就是乐观假设 Pod 已经调度成功，更新缓存中 Node 和 PodStats 信息，scheduling cycle 周期就已经结束，然后会开启新的一轮调度；至于真正的绑定，则会新起一个协程；</li><li>执行 reserve 插件；</li><li>启动协程绑定 Pod 到 Node上。实际上就是修改 Pod.spec.nodeName，然后调用 kube-apiserver 接口写入 etcd。如果绑定失败，那么移除缓存中此前加入的信息，然后把 Pod 放入activeQ 中，后续重新调度；</li><li>执行 postBinding；</li></ul><h1 id=常见问题>常见问题</h1><p>1、preFilter 与 Filter 有什么区别？</p><p>像我们常见的 nodeSelector/Pod Affinity 等使用的是 PreFilter，而像 nodeName 使用的是 Filter。</p><p>2、直接在 Pod Spec 模板下填写 nodeName 字段，Pod 调度还会经过 Scheduler 调度周期与绑定周期？</p><p>会经过 Scheduler Framework 调度周期，以 Kubernetes 1.26.9 源码为例，见 <a href=https://github.com/kubernetes/kubernetes/blob/v1.26.9/pkg/scheduler/eventhandlers.go#L186>https://github.com/kubernetes/kubernetes/blob/v1.26.9/pkg/scheduler/eventhandlers.go#L186</a>，当调整 kube-scheduler 日志等级 v=10 时，kube-scheduler 日志依然可以监听 Add/Update/Delete Pod 事件，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>I0417 11:40:02.160555       <span style=color:#bd93f9>1</span> eventhandlers.go:186<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Add event for scheduled pod&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-g6zzq&#34;</span>
</span></span><span style=display:flex><span>I0417 11:40:02.185169       <span style=color:#bd93f9>1</span> eventhandlers.go:206<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Update event for scheduled pod&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-g6zzq&#34;</span>
</span></span><span style=display:flex><span>I0417 11:40:02.757130       <span style=color:#bd93f9>1</span> eventhandlers.go:206<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Update event for scheduled pod&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-g6zzq&#34;</span>
</span></span></code></pre></div><p>kubelet 的日志如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubelet 的日志如下所示：
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.298368    <span style=color:#bd93f9>4170</span> kubelet.go:2199<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;SyncLoop ADD&#34;</span> <span style=color:#8be9fd;font-style:italic>source</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;api&#34;</span> <span style=color:#8be9fd;font-style:italic>pods</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;[default/nginx-cb8956d5f-c5zh8]&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.298414    <span style=color:#bd93f9>4170</span> topology_manager.go:210<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Topology Admit Handler&#34;</span> <span style=color:#8be9fd;font-style:italic>podUID</span><span style=color:#ff79c6>=</span>d054e76b-1d9b-4788-9fc7-b35165ab02fb <span style=color:#8be9fd;font-style:italic>podNamespace</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default&#34;</span> <span style=color:#8be9fd;font-style:italic>podName</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;nginx-cb8956d5f-c5zh8&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: E0417 19:46:19.298465    <span style=color:#bd93f9>4170</span> cpu_manager.go:395<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;RemoveStaleState: removing container&#34;</span> <span style=color:#8be9fd;font-style:italic>podUID</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2e6143f6-fb20-4707-8497-5613b46f6292&#34;</span> <span style=color:#8be9fd;font-style:italic>containerName</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.298475    <span style=color:#bd93f9>4170</span> state_mem.go:107<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Deleted CPUSet assignment&#34;</span> <span style=color:#8be9fd;font-style:italic>podUID</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2e6143f6-fb20-4707-8497-5613b46f6292&#34;</span> <span style=color:#8be9fd;font-style:italic>containerName</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.298521    <span style=color:#bd93f9>4170</span> memory_manager.go:346<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;RemoveStaleState removing state&#34;</span> <span style=color:#8be9fd;font-style:italic>podUID</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2e6143f6-fb20-4707-8497-5613b46f6292&#34;</span> <span style=color:#8be9fd;font-style:italic>containerName</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;nginx&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.419170    <span style=color:#bd93f9>4170</span> reconciler_common.go:253<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;operationExecutor.VerifyControllerAttachedVolume started for volume \&#34;kube-api-access-kq8x5\&#34; (UniqueName: \&#34;kubernetes.io/projected/d054e76b-1d9b-4788-9fc7-b35165ab02fb-kube-api-access-kq8x5\&#34;) pod \&#34;nginx-cb8956d5f-c5zh8\&#34; (UID: \&#34;d054e76b-1d9b-4788-9fc7-b35165ab02fb\&#34;) &#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.520363    <span style=color:#bd93f9>4170</span> reconciler_common.go:228<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;operationExecutor.MountVolume started for volume \&#34;kube-api-access-kq8x5\&#34; (UniqueName: \&#34;kubernetes.io/projected/d054e76b-1d9b-4788-9fc7-b35165ab02fb-kube-api-access-kq8x5\&#34;) pod \&#34;nginx-cb8956d5f-c5zh8\&#34; (UID: \&#34;d054e76b-1d9b-4788-9fc7-b35165ab02fb\&#34;) &#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.534007    <span style=color:#bd93f9>4170</span> operation_generator.go:740<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;MountVolume.SetUp succeeded for volume \&#34;kube-api-access-kq8x5\&#34; (UniqueName: \&#34;kubernetes.io/projected/d054e76b-1d9b-4788-9fc7-b35165ab02fb-kube-api-access-kq8x5\&#34;) pod \&#34;nginx-cb8956d5f-c5zh8\&#34; (UID: \&#34;d054e76b-1d9b-4788-9fc7-b35165ab02fb\&#34;) &#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:19 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:19.618021    <span style=color:#bd93f9>4170</span> util.go:30<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;No sandbox for pod can be found. Need to start a new one&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:20 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:20.280279    <span style=color:#bd93f9>4170</span> kubelet.go:2231<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;SyncLoop (PLEG): event for pod&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span> <span style=color:#8be9fd;font-style:italic>event</span><span style=color:#ff79c6>=</span>&amp;<span style=color:#ff79c6>{</span>ID:d054e76b-1d9b-4788-9fc7-b35165ab02fb Type:ContainerStarted Data:007c2d8915cce53c32d6c4e3b1496fe80441e7a0abbbb3baa4802c7e14cd61f6<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:20 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:20.280307    <span style=color:#bd93f9>4170</span> kubelet.go:2231<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;SyncLoop (PLEG): event for pod&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span> <span style=color:#8be9fd;font-style:italic>event</span><span style=color:#ff79c6>=</span>&amp;<span style=color:#ff79c6>{</span>ID:d054e76b-1d9b-4788-9fc7-b35165ab02fb Type:ContainerStarted Data:644d543bd5d5b89412fdd5b2c36ab961749391f99cbdcb5602a2bd9ee1a042d7<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>Apr <span style=color:#bd93f9>17</span> 19:46:20 8rnr7mhj-nhcz55ua kubelet<span style=color:#ff79c6>[</span>4170<span style=color:#ff79c6>]</span>: I0417 19:46:20.296305    <span style=color:#bd93f9>4170</span> pod_startup_latency_tracker.go:102<span style=color:#ff79c6>]</span> <span style=color:#f1fa8c>&#34;Observed pod startup duration&#34;</span> <span style=color:#8be9fd;font-style:italic>pod</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;default/nginx-cb8956d5f-c5zh8&#34;</span> <span style=color:#8be9fd;font-style:italic>podStartSLOduration</span><span style=color:#ff79c6>=</span>1.296279865 pod.CreationTimestamp<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2024-04-17 19:46:19 +0800 CST&#34;</span> <span style=color:#8be9fd;font-style:italic>firstStartedPulling</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;0001-01-01 00:00:00 +0000 UTC&#34;</span> <span style=color:#8be9fd;font-style:italic>lastFinishedPulling</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;0001-01-01 00:00:00 +0000 UTC&#34;</span> <span style=color:#8be9fd;font-style:italic>observedRunningTime</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2024-04-17 19:46:20.295142614 +0800 CST m=+465268.893586305&#34;</span> <span style=color:#8be9fd;font-style:italic>watchObservedRunningTime</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;2024-04-17 19:46:20.296279865 +0800 CST m=+465268.894723600&#34;</span><span style=color:#8be9fd;font-style:italic>exit</span>
</span></span></code></pre></div><hr><ul class=pager><li class=previous><a href=/post/2024-04-06-scheduler-framework-01/ data-toggle=tooltip data-placement=top title="深入理解 Kubernetes Scheduler Framework 调度框架（Part 1）">&larr;
Previous Post</a></li><li class=next><a href=/post/2024-04-08-scheduler-framework-03/ data-toggle=tooltip data-placement=top title="深入理解 Kubernetes Scheduler Framework 调度框架（Part 3）">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:tanjunchen20@gmail.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/tanjunchen><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; 陈谭军 2024</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>